diff --git a/Documentation/fb/00-INDEX b/Documentation/fb/00-INDEX
index 92e89aeef5..a6cfacce6c 100644
--- a/Documentation/fb/00-INDEX
+++ b/Documentation/fb/00-INDEX
@@ -19,6 +19,8 @@ matroxfb.txt
 	- info on the Matrox frame buffer driver
 pvr2fb.txt
 	- info on the PowerVR 2 frame buffer driver
+splash.txt
+	- info on the Framebuffer Splash
 tgafb.txt
 	- info on the TGA (DECChip 21030) frame buffer driver
 vesafb.txt
diff --git a/Documentation/fb/splash.txt b/Documentation/fb/splash.txt
new file mode 100644
index 0000000000..6931ff637c
--- /dev/null
+++ b/Documentation/fb/splash.txt
@@ -0,0 +1,207 @@
+What is it?
+-----------
+
+The framebuffer splash is a kernel feature that allows displaying a background
+picture on selected consoles.
+
+What do I need to get it to work?
+---------------------------------
+
+To get fb splash up-and-running you will have to:
+ 1) get a copy of splashutils [1] or a similar program
+ 2) get some splash themes
+ 3) build the kernel helper program
+ 4) build your kernel with the FB_SPLASH option enabled.
+
+To get fb splash operational right after fbcon initialization is finished, you
+will have to include a theme and the kernel helper into your initramfs image.
+Please refer to splashutils documentation for instructions on how to do that.
+
+[1] The splashutils package can be downloaded from:
+    http://dev.gentoo.org/~spock/projects/splashutils/
+
+The userspace helper
+--------------------
+
+The userspace splash helper (by default: /sbin/splash_helper) is called by the
+kernel whenever an important event occurs and the kernel needs some kind of
+job to be carried out. Important events include console switches and graphic
+mode switches (the kernel requests background images and configuration
+parameters for the current console). The splash helper must be accessible at
+all times. If it's not, fbsplash will be switched off automatically.
+
+It's possible to set path to the splash helper by writing it to
+/proc/sys/kernel/fbsplash.
+
+*****************************************************************************
+
+The information below is mostly technical stuff. There's probably no need to
+read it unless you plan to develop a userspace helper.
+
+The splash protocol
+-------------------
+
+The splash protocol defines a communication interface between the kernel and
+the userspace splash helper.
+
+The kernel side is responsible for:
+
+ o rendering console text, using an image as a background (instead of a
+   standard solid color fbcon uses),
+ o accepting commands from the user via ioctls on the fbsplash device,
+ o calling the userspace helper to set things up as soon as the fb subsystem
+   is initialized.
+
+The userspace helper is responsible for everything else, including parsing
+configuration files, decompressing the image files whenever the kernel needs
+it, and communicating with the kernel if necessary.
+
+The splash protocol specifies how communication is done in both ways:
+kernel->userspace and userspace->helper.
+
+Kernel -> Userspace
+-------------------
+
+The kernel communicates with the userspace helper by calling it and specifying
+the task to be done in a series of arguments.
+
+The arguments follow the pattern:
+<splash protocol version> <command> <parameters>
+
+All commands defined in splash protocol v2 have the following parameters:
+ virtual console
+ framebuffer number
+ theme
+
+Splash protocol v1 specified an additional 'fbsplash mode' after the
+framebuffer number. Splash protocol v1 is deprecated and should not be used.
+
+Splash protocol v2 specifies the following commands:
+
+getpic
+------
+ The kernel issues this command to request image data. It's up to the userspace
+ helper to find a background image appropriate for the specified theme and the
+ current resolution. The userspace helper should respond by issuing the
+ FBIOSPLASH_SETPIC ioctl.
+
+init
+----
+ The kernel issues this command after the fbsplash device is created and
+ the fbsplash interface is initialized. Upon receiving 'init', the userspace
+ helper should parse the kernel command line (/proc/cmdline) or otherwise
+ decide whether fbsplash is to be activated.
+
+ To activate fbsplash on the first console the helper should issue the
+ FBIOSPLASH_SETCFG, FBIOSPLASH_SETPIC and FBIOSPLASH_SETSTATE commands,
+ in the above-mentioned order.
+
+ When the userspace helper is called in an early phase of the boot process
+ (right after the initialization of fbcon), no filesystems will be mounted.
+ The helper program should mount sysfs and then create the appropriate
+ framebuffer, fbsplash and tty0 devices (if they don't already exist) to get
+ current display settings and to be able to communicate with the kernel side.
+ It should probably also mount the procfs to be able to parse the kernel
+ command line parameters.
+
+ Note that the console sem is not held when the kernel calls splash_helper
+ with the 'init' command. The splash helper should perform all ioctls with
+ origin set to FB_SPLASH_IO_ORIG_USER.
+
+modechange
+----------
+ The kernel issues this command on a mode change. The helper's response should
+ be similar to the response to the 'init' command. Note that this time the
+ console sem is held and all ioctls must be performed with origin set to
+ FB_SPLASH_IO_ORIG_KERNEL.
+
+
+Userspace -> Kernel
+-------------------
+
+Userspace programs can communicate with fbsplash via ioctls on the fbsplash
+device. These ioctls are to be used by both the userspace helper (called
+only by the kernel) and userspace configuration tools (run by the users).
+
+The splash helper should set the origin field to FB_SPLASH_IO_ORIG_KERNEL
+when doing the appropriate ioctls. All userspace configuration tools should
+use FB_SPLASH_IO_ORIG_USER. Failure to set the appropriate value in the origin
+field when performing ioctls from the kernel helper will most likely result
+in a console deadlock.
+
+FB_SPLASH_IO_ORIG_KERNEL instructs fbsplash not to try to acquire the console
+semaphore. Not surprisingly, FB_SPLASH_IO_ORIG_USER instructs it to acquire
+the console sem.
+
+The framebuffer splash provides the following ioctls (all defined in
+linux/fb.h):
+
+FBIOSPLASH_SETPIC
+description: loads a background picture for a virtual console
+argument: struct fb_splash_iowrapper*; data: struct fb_image*
+notes:
+If called for consoles other than the current foreground one, the picture data
+will be ignored.
+
+If the current virtual console is running in a 8-bpp mode, the cmap substruct
+of fb_image has to be filled appropriately: start should be set to 16 (first
+16 colors are reserved for fbcon), len to a value <= 240 and red, green and
+blue should point to valid cmap data. The transp field is ingored. The fields
+dx, dy, bg_color, fg_color in fb_image are ignored as well.
+
+FBIOSPLASH_SETCFG
+description: sets the fbsplash config for a virtual console
+argument: struct fb_splash_iowrapper*; data: struct vc_splash*
+notes: The structure has to be filled with valid data.
+
+FBIOSPLASH_GETCFG
+description: gets the fbsplash config for a virtual console
+argument: struct fb_splash_iowrapper*; data: struct vc_splash*
+
+FBIOSPLASH_SETSTATE
+description: sets the fbsplash state for a virtual console
+argument: struct fb_splash_iowrapper*; data: unsigned int*
+	  values: 0 = disabled, 1 = enabled.
+
+FBIOSPLASH_GETSTATE
+description: gets the fbsplash state for a virtual console
+argument: struct fb_splash_iowrapper*; data: unsigned int*
+          values: as in FBIOSPLASH_SETSTATE
+
+Info on used structures:
+
+Definition of struct vc_splash can be found in linux/console_splash.h. It's
+heavily commented. Note that the 'theme' field should point to a string
+no longer than FB_SPLASH_THEME_LEN. When FBIOSPLASH_GETCFG call is
+performed, the theme field should point to a char buffer of length
+FB_SPLASH_THEME_LEN.
+
+Definition of struct fb_splash_iowrapper can be found in linux/fb.h.
+The fields in this struct have the following meaning:
+
+vc:
+Virtual console number.
+
+origin:
+Specifies if the ioctl is performed as a response to a kernel request. The
+splash helper should set this field to FB_SPLASH_IO_ORIG_KERNEL, userspace
+programs should set it to FB_SPLASH_IO_ORIG_USER. This field is necessary to
+avoid console semaphore deadlocks.
+
+data:
+Pointer to a data structure appropriate for the performed ioctl. Type of
+the data struct is specified in the ioctls description.
+
+*****************************************************************************
+
+Credit
+------
+
+Original 'bootsplash' project & implementation by:
+  Volker Poplawski <volker@poplawski.de>, Stefan Reinauer <stepan@suse.de>,
+  Steffen Winterfeldt <snwint@suse.de>, Michael Schroeder <mls@suse.de>,
+  Ken Wimer <wimer@suse.de>.
+
+Fbsplash, splash protocol design, current implementation & docs by:
+  Michael Januszewski <spock@gentoo.org>
+
diff --git a/Documentation/fb/vesafb.txt b/Documentation/fb/vesafb.txt
index ee277dd204..60f797eb91 100644
--- a/Documentation/fb/vesafb.txt
+++ b/Documentation/fb/vesafb.txt
@@ -2,16 +2,18 @@
 What is vesafb?
 ===============
 
-This is a generic driver for a graphic framebuffer on intel boxes.
+Vesafb is a generic framebuffer driver for x86 and x86_64 boxes.
 
-The idea is simple:  Turn on graphics mode at boot time with the help
-of the BIOS, and use this as framebuffer device /dev/fb0, like the m68k
-(and other) ports do.
+VESA BIOS Extensions Version 2.0 are required, because we need access to
+a linear frame buffer. VBE 3.0 is required if you want to use modes with a
+higher (than the standard 60Hz) refresh rate.
 
-This means we decide at boot time whenever we want to run in text or
-graphics mode.  Switching mode later on (in protected mode) is
-impossible; BIOS calls work in real mode only.  VESA BIOS Extensions
-Version 2.0 are required, because we need a linear frame buffer.
+The VESA framebuffer driver comes in two flavors - the standard 'vesafb'
+and 'vesafb-tng'. Vesafb-tng is available only on 32-bit x86 due to the
+technology it uses (vm86). Vesafb-tng has more features than vesafb
+(adjusting the refresh rate on VBE3.0-compliant boards, switching the
+video mode without rebooting, selecting a mode by providing its
+modedb name, and more).
 
 Advantages:
 
@@ -29,26 +31,35 @@ Disadvantages:
 How to use it?
 ==============
 
-Switching modes is done using the vga=... boot parameter.  Read
-Documentation/svga.txt for details.
+If you are running a 32-bit x86 system and you decide to use vesafb-tng,
+you can either compile the driver into the kernel or use it as a module.
+The graphics mode you want to use is in both cases specified using the
+standard modedb format.
 
-You should compile in both vgacon (for text mode) and vesafb (for
-graphics mode). Which of them takes over the console depends on
-whenever the specified mode is text or graphics.
+If your system doesn't support vm86 calls, things get a little more tricky.
+Since on such systems you can't do BIOS calls from protected mode in which
+kernel runs, you have to decide at boot time whenever you want to run in text
+or in graphics mode. Switching mode later on is impossible. Switching modes
+is done using the vga=... boot parameter.  Read Documentation/svga.txt for
+details. Below is a more detailed description of what to do on systems using
+the standard vesafb driver.
 
-The graphic modes are NOT in the list which you get if you boot with
-vga=ask and hit return. The mode you wish to use is derived from the
-VESA mode number. Here are those VESA mode numbers:
+You should compile in both vgacon (for text mode) and vesafb (for graphics
+mode). Which of them takes over the console depends on whenever the
+specified mode is text or graphics.
+
+The graphic modes are NOT in the list which you get if you boot with vga=ask
+and hit return. The mode you wish to use is derived from the VESA mode number.
+Here are those VESA mode numbers:
 
     | 640x480  800x600  1024x768 1280x1024
 ----+-------------------------------------
-256 |  0x101    0x103    0x105    0x107   
-32k |  0x110    0x113    0x116    0x119   
-64k |  0x111    0x114    0x117    0x11A   
-16M |  0x112    0x115    0x118    0x11B   
+256 |  0x101    0x103    0x105    0x107
+32k |  0x110    0x113    0x116    0x119
+64k |  0x111    0x114    0x117    0x11A
+16M |  0x112    0x115    0x118    0x11B
 
-The video mode number of the Linux kernel is the VESA mode number plus
-0x200.
+The video mode number of the Linux kernel is the VESA mode number plus 0x200.
  
  Linux_kernel_mode_number = VESA_mode_number + 0x200
 
@@ -56,15 +67,15 @@ So the table for the Kernel mode numbers are:
 
     | 640x480  800x600  1024x768 1280x1024
 ----+-------------------------------------
-256 |  0x301    0x303    0x305    0x307   
-32k |  0x310    0x313    0x316    0x319   
-64k |  0x311    0x314    0x317    0x31A   
-16M |  0x312    0x315    0x318    0x31B   
+256 |  0x301    0x303    0x305    0x307
+32k |  0x310    0x313    0x316    0x319
+64k |  0x311    0x314    0x317    0x31A
+16M |  0x312    0x315    0x318    0x31B
 
-To enable one of those modes you have to specify "vga=ask" in the
-lilo.conf file and rerun LILO. Then you can type in the desired
-mode at the "vga=ask" prompt. For example if you like to use 
-1024x768x256 colors you have to say "305" at this prompt.
+To enable one of those modes you have to specify "vga=ask" in the lilo.conf
+file and rerun LILO. Then you can type in the desired mode at the "vga=ask"
+prompt. For example if you like to use 1024x768x256 colors you have to say
+"305" at this prompt.
 
 If this does not work, this might be because your BIOS does not support
 linear framebuffers or because it does not support this mode at all.
@@ -72,11 +83,12 @@ Even if your board does, it might be the BIOS which does not.  VESA BIOS
 Extensions v2.0 are required, 1.2 is NOT sufficient.  You will get a
 "bad mode number" message if something goes wrong.
 
-1. Note: LILO cannot handle hex, for booting directly with 
+1. Note: LILO cannot handle hex, for booting directly with
          "vga=mode-number" you have to transform the numbers to decimal.
 2. Note: Some newer versions of LILO appear to work with those hex values,
          if you set the 0x in front of the numbers.
 
+
 X11
 ===
 
@@ -84,98 +96,162 @@ XF68_FBDev should work just fine, but it is non-accelerated.  Running
 another (accelerated) X-Server like XF86_SVGA might or might not work.
 It depends on X-Server and graphics board.
 
-The X-Server must restore the video mode correctly, else you end up
+The X-Server must restore the video mode correctly, or else you end up
 with a broken console (and vesafb cannot do anything about this).
+With vesafb-tng chances are that the console will be restored properly
+even if the X server messes up the video mode.
 
 
 Refresh rates
 =============
 
-There is no way to change the vesafb video mode and/or timings after
-booting linux.  If you are not happy with the 60 Hz refresh rate, you
-have these options:
+With VBE3.0 compatible BIOSes and vesafb-tng it is possible to change
+the refresh rate either at boot time (by specifying the @<rr> part of
+the mode name) or later, using the fbset utility.
+
+If you want to use the default BIOS refresh rate while switching modes
+on a running system, set pixclock to 0.
 
- * configure and load the DOS-Tools for your the graphics board (if
-   available) and boot linux with loadlin.
+With VBE2.0 there is no way to change the mode timings after booting
+Linux. If you are not happy with the 60 Hz refresh rate, you have
+these options:
+
+ * configure and load the DOS tools for your the graphics board (if
+   available) and boot Linux with loadlin.
  * use a native driver (matroxfb/atyfb) instead if vesafb.  If none
    is available, write a new one!
- * VBE 3.0 might work too.  I have neither a gfx board with VBE 3.0
-   support nor the specs, so I have not checked this yet.
+ * use a BIOS editor to change the default refresh rate (such an
+   editor does exist at least for ATI Radeon BIOSes).
+ * if you're running a non-vm86 and VBE3.0-compatible system, you can
+   use a kernel patch (vesafb-rrc) to hard-code some mode timings in
+   the kernel and use these while setting the graphic mode at boot time.
+
+Note that there are some boards (nVidia 59**, 57** and newer models)
+claiming that their Video BIOS is VBE3.0 compliant, while ignoring the
+CRTC values provided by software such as vesafb-tng. You'll not be able
+to change the refresh rate if you're using one of these boards.
 
 
 Configuration
 =============
 
-The VESA BIOS provides protected mode interface for changing
-some parameters.  vesafb can use it for palette changes and
-to pan the display.  It is turned off by default because it
-seems not to work with some BIOS versions, but there are options
-to turn it on.
-
-You can pass options to vesafb using "video=vesafb:option" on
-the kernel command line.  Multiple options should be separated
-by comma, like this: "video=vesafb:ypan,invers"
-
-Accepted options:
-
-invers	no comment...
-
-ypan	enable display panning using the VESA protected mode 
-	interface.  The visible screen is just a window of the
-	video memory, console scrolling is done by changing the
-	start of the window.
-	pro:	* scrolling (fullscreen) is fast, because there is
-		  no need to copy around data.
-		* You'll get scrollback (the Shift-PgUp thing),
-		  the video memory can be used as scrollback buffer
-	kontra: * scrolling only parts of the screen causes some
-		  ugly flicker effects (boot logo flickers for
-		  example).
-
-ywrap	Same as ypan, but assumes your gfx board can wrap-around 
-	the video memory (i.e. starts reading from top if it
-	reaches the end of video memory).  Faster than ypan.
-
-redraw	scroll by redrawing the affected part of the screen, this
-	is the safe (and slow) default.
-
-
-vgapal	Use the standard vga registers for palette changes.
-	This is the default.
-pmipal	Use the protected mode interface for palette changes.
-
-mtrr:n	setup memory type range registers for the vesafb framebuffer
-	where n:
-	      0 - disabled (equivalent to nomtrr) (default)
-	      1 - uncachable
-	      2 - write-back
-	      3 - write-combining
-	      4 - write-through
-
-	If you see the following in dmesg, choose the type that matches the
-	old one. In this example, use "mtrr:2".
+The VESA BIOS provides protected mode interface for changing some parameters.
+vesafb can use it for palette changes and to pan the display. It is turned
+off by default because it seems not to work with some BIOS versions, but
+there are options to turn it on.
+
+You can pass options to vesafb using "video=vesafb:option" on the kernel
+command line. Multiple options should be separated by comma, like this:
+"video=vesafb:ypan,1024x768-32@85"
+
+Note that vesafb-tng still uses the "video=vesafb:option" format of the
+kernel command line video parameter. "video=vesafb-tng:xxx" is incorrect.
+
+Accepted options (both vesafb and vesafb-tng):
+
+ypan    Enable display panning using the VESA protected mode interface
+        The visible screen is just a window of the video memory,
+        console scrolling is done by changing the start of the window.
+        pro:    * scrolling (fullscreen) is fast, because there is
+                  no need to copy around data.
+                * you'll get scrollback (the Shift-PgUp thing),
+                  the video memory can be used as scrollback buffer
+        con:    * scrolling only parts of the screen causes some
+                  ugly flicker effects (boot logo flickers for
+                  example).
+
+ywrap   Same as ypan, but assumes your gfx board can wrap-around the video
+        memory (i.e. starts reading from top if it reaches the end of
+        video memory). Faster than ypan.
+
+redraw  Scroll by redrawing the affected part of the screen, this is the
+        safe (and slow) default.
+
+vgapal  Use the standard VGA registers for palette changes.
+        This is the default.
+
+pmipal  Use the protected mode interface for palette changes.
+
+mtrr:n  Setup memory type range registers for the vesafb framebuffer
+        where n:
+              0 - disabled (equivalent to nomtrr) (default)
+              1 - uncachable
+              2 - write-back
+              3 - write-combining
+              4 - write-through
+
+	If you see the following in dmesg, choose the type that matches
+        the old one. In this example, use "mtrr:2".
 ...
 mtrr: type mismatch for e0000000,8000000 old: write-back new: write-combining
 ...
 
-nomtrr  disable mtrr
+nomtrr  Do not use memory type range registers for vesafb.
 
 vremap:n
         remap 'n' MiB of video RAM. If 0 or not specified, remap memory
-	according to video mode. (2.5.66 patch/idea by Antonino Daplas
-	reversed to give override possibility (allocate more fb memory
-	than the kernel would) to 2.4 by tmb@iki.fi)
+        according to video mode. (2.5.66 patch/idea by Antonino Daplas
+        reversed to give override possibility (allocate more fb memory
+        than the kernel would) to 2.4 by tmb@iki.fi)
 
 vtotal:n
         if the video BIOS of your card incorrectly determines the total
         amount of video RAM, use this option to override the BIOS (in MiB).
 
-Have fun!
+Options accepted only by vesafb-tng:
+
+<mode>  The mode you want to set, in the standard modedb format. Refer to
+        modedb.txt for detailed description. If you specify a mode that is
+        not supported by your board's BIOS, vesafb will attempt to set a
+        similar mode. The list of supported modes can be found in
+        /proc/fbx/modes, where x is the framebuffer number (usually 0).
+        When vesafb is compiled as a module, the mode string should be
+        provided as a value of the parameter 'mode'.
+
+vbemode:x
+        Force the use of VBE mode x. The mode will only be set if it's
+        found in VBE-provided list of supported modes.
+        NOTE: The mode number 'x' should be specified in VESA mode number
+        notation, not the Linux kernel one (ie. 257 instead of 769).
+        HINT: If you use this option because normal <mode> parameter does
+        not work for you and you use a X server, you'll probably want to
+        set the 'nocrtc' option to ensure that the video mode is properly
+        restored after console <-> X switches.
+
+nocrtc  Do not use CRTC timings while setting the graphic mode. This option
+        makes sence only with VBE3.0 compliant systems. Use it if you have
+        problems with the modes set in the standard way. Note that specifying
+        this option means the refresh rate will be ignored and will stay at
+        your BIOS default (60 Hz).
+
+noedid  Do not try to fetch and use EDID-provided modes.
+
+gtf     Force the use of VESA's GTF (Generalized Timing Formula). Specifying
+        this will cause vesafb to skip it's internal modedb and EDID-modedb
+        and jump straight to the GTF part of the code (normally used only if
+        everything else failed). This can be useful if you want to get as
+        much as possible from you graphics board but your BIOS doesn't
+        support modes with refresh rates you require. Note that you may need
+        to specify the maxhf, maxvf and maxclk parameters if they are not
+        provided by EDID.
+
+Additionally, the following parameters may be provided. They all override the
+EDID-provided values and BIOS defaults. Refer to your monitor's specs to get
+the correct values for maxhf, maxvf and maxclk for your hardware.
+
+maxhf:n     Maximum horizontal frequency (in kHz).
+maxvf:n     Maximum vertical frequency (in Hz).
+maxclk:n    Maximum pixel clock (in MHz).
 
-  Gerd
+Have fun!
 
 --
+Original document for the vesafb driver by
 Gerd Knorr <kraxel@goldbach.in-berlin.de>
 
-Minor (mostly typo) changes 
-by Nico Schmoigl <schmoigl@rumms.uni-mannheim.de>
+Minor (mostly typo) changes by
+Nico Schmoigl <schmoigl@rumms.uni-mannheim.de>
+
+Extended documentation for vm86, VBE3.0 and vesafb-tng by
+Michal Januszewski <spock@gentoo.org>
+
diff --git a/Documentation/sound/alsa/ALSA-Configuration.txt b/Documentation/sound/alsa/ALSA-Configuration.txt
index 77c52d2c89..dc29b40e64 100644
--- a/Documentation/sound/alsa/ALSA-Configuration.txt
+++ b/Documentation/sound/alsa/ALSA-Configuration.txt
@@ -750,6 +750,24 @@ Prior to version 0.9.0rc4 options had a 'snd_' prefix. This was removed.
 	  allout	5-jack in back, 2-jack in front, SPDIF out
 	  auto		auto-config reading BIOS (default)
 
+	AD1981
+	  basic		3-jack (default)
+	  hp		HP nx6320
+
+	AD1986A
+	  6stack	6-jack, separate surrounds (default)
+	  3stack	3-stack, shared surrounds
+	  laptop	2-channel only (FSC V2060, Samsung M50)
+
+	AD1988
+	  6stack	6-jack
+	  6stack-dig	ditto with SPDIF
+	  3stack	3-jack
+	  3stack-dig	ditto with SPDIF
+	  laptop	3-jack with hp-jack automute
+	  laptop-dig	ditto with SPDIF
+	  auto		auto-confgi reading BIOS (default)
+
     If the default configuration doesn't work and one of the above
     matches with your device, report it together with the PCI
     subsystem ID (output of "lspci -nv") to ALSA BTS or alsa-devel
diff --git a/Documentation/speakup/DefaultKeyAssignments b/Documentation/speakup/DefaultKeyAssignments
new file mode 100644
index 0000000000..101c803b21
--- /dev/null
+++ b/Documentation/speakup/DefaultKeyAssignments
@@ -0,0 +1,46 @@
+This file is intended to give you an overview of the default keys used
+by speakup for it's review functions.  You may change them to be
+anything you want but that will take some familiarity with key
+mapping.
+
+We have remapped the insert or zero key on the keypad to act as a
+shift key.  Well, actually as an altgr key.  So in the following list
+InsKeyPad-period means hold down the insert key like a shift key and
+hit the keypad period.
+
+KeyPad-8		Say current Line
+InsKeyPad-8		say from top of screen to reading cursor.
+KeyPad-7		Say Previous Line (UP one line)
+KeyPad-9		Say Next Line (down one line)
+KeyPad-5		Say Current Word
+InsKeyPad-5		Spell Current Word
+KeyPad-4		Say Previous Word (left one word)
+InsKeyPad-4		say from left edge of line to reading cursor.
+KeyPad-6		Say Next Word (right one word)
+InsKeyPad-6		Say from reading cursor to right edge of line.
+KeyPad-2		Say Current Letter
+InsKeyPad-2		say current letter phonetically
+KeyPad-1		Say Previous Character (left one letter)
+KeyPad-3		Say Next Character (right one letter)
+KeyPad-plus		Say Entire Screen
+InsKeyPad-plus		Say from reading cursor line to bottom of screen.
+KeyPad-Minus		Park reading cursor (toggle)
+InsKeyPad-minus		Say character hex and decimal value.
+KeyPad-period		Say Position (current line, position and console)
+InsKeyPad-period	say colour attributes of current position.
+InsKeyPad-9		Move reading cursor to top of screen (insert pgup)
+InsKeyPad-3		Move reading cursor to bottom of screen (insert pgdn)
+InsKeyPad-7		Move reading cursor to left edge of screen (insert home)
+InsKeyPad-1		Move reading cursor to right edge of screen (insert end)
+ControlKeyPad-1		Move reading cursor to last character on current line.
+KeyPad-Enter		Shut Up (until another key is hit) and sync reading cursor
+InsKeyPad-Enter		Shut Up (until toggled back on).
+InsKeyPad-star n<x|y>	go to line (y) or column (x). Where 'n' is any
+		allowed value for the row or column for your current screen.
+KeyPad-/		Mark and Cut screen region.
+InsKeyPad-/		Paste screen region into any console.
+
+Hitting any key while speakup is outputting speech will quiet the
+synth until it has caught up with what is being printed on the
+console.
+
diff --git a/Documentation/speakup/INSTALLATION b/Documentation/speakup/INSTALLATION
new file mode 100644
index 0000000000..0d2167b6d3
--- /dev/null
+++ b/Documentation/speakup/INSTALLATION
@@ -0,0 +1,108 @@
+This document assumes you have had some experience with kernel
+compilation and installation.  If you have not, I recommend you get
+the kernel source and read the README and various documents in the
+linux/Documentation directory.  In particular the Changes file to make
+sure you have the appropriate utilities needed for installing a 2.2.xx
+or 2.4xx kernel.  It isn't as difficult as you might think.  The
+kernel README is intimidating the first time but once you get the
+steps down, it's really pretty easy.  Getting through the "make
+config" is the tedious bit.
+
+The first thing to do is to place a copy of the tarball in the /usr/src
+directory which is the directory the linux tree is located in as well.
+Next untar speakup by typing:
+
+tar zxf speakup-1.00.tar.gz
+cd speakup-1.00
+./install
+
+Note the dot-slash before the install.  This will copy the speakup
+directory to the kernel tree and apply the various patches and
+components to the appropriate kernel files.  Depending on how
+experienced you are with kernel compiling and hacking will determine
+whether you should bother looking at any failed patches.  If this
+happens, you should probably write to the speakup mailing list for
+help or myself.
+
+If all of the patch hunks apply successfully then just continue with
+the standard steps to compile the kernel with:
+
+make mrproper
+make config
+
+When you get to the section console speech output, answer 'y' to the
+CONFIG_SPEAKUP prompt.  You will be given a submenu with the list of
+synthesizers which are currently supported.  You can include as many
+synths in the kernel as you wish but remember each one takes up kernel
+space.  You can only choose one of the synths as the default or none,
+so just type dtlk or whatever is the correct string for the
+synthesizer you have.  You will also be asked if you wish to build-in
+a speakup key map.  If you do not say 'y' to this option you will need
+to load a speakup map at boot time with whichever mechanism your
+distribution uses for loading key maps.
+
+We have placed the speakup configuration options in make config just
+after the vga console choice.  For the DoubleTalk PC driver included
+by Jim Van Zandt.  I recommend you say no to that option.  I have not
+tried configuring them both in, but I wouldn't be at all surprised if
+it didn't work.
+
+If all goes well up to this point you can continue with the compiling
+process by doing:
+
+make dep >dep.file 2>&1 &
+make bzImage >cc.file 2>&1 &
+make modules >mod.file 2>&1 &
+
+I always redirect output to the files dep.file and cc.file so I can
+look over the compilation record to make sure there are no errors and
+warnings.
+
+Okay, you are ready to install the newly compiled kernel.  Make sure
+you make an linux.old entry in your lilo.conf file so you can recover
+if it blows up.  next as root run "make modules_install" to install
+whatever modules you compiled and move the bzImage from
+/usr/src/linux/arch/i386/boot to wherever your kernel lives.  Also
+move the System.map from /usr/src/linux to where your System.map
+lives.  On our systems we use debian so we create an vmlinuz-speakup
+and System.map-speakup in our /boot directory and set the symbolic
+links vmlinuz and System.map in the root (/) directory to point to the
+images.  Now type lilo to tell lilo to build the new booter file and
+install it.
+
+As of version 0.07, the keymap for speakup is automatically built in
+at compile time.  If you have other keymaps installed at boot time,
+you might want to consider removing them before you reboot the system.
+
+If everything has gone OK up until now, cross your fingers and type:
+
+shutdown -r now
+
+Your system should start talking to you as soon as it starts booting.
+It will talk and talk and ... well, you might want to hit the
+keypad-enter key to tell it to shut up.  You should also read the
+DefaultKeyAssignments file to learn the various review functions
+available.
+
+As of v-0.10 the speakup configuration options are in the
+/proc/speakup subtree.  The individual options should be fairly
+obvious by their names such as rate, volume, punc_level and so forth.
+You can manipulate them by cat'ing or echoing new values to them such
+as:
+
+echo 9 >/proc/speakup/rate
+
+You can see what the current values are by cat'ing those files to the console:
+
+cat /proc/speakup/rate
+
+I have probably managed to overlook a whole whack of things because
+this is the, enter version number here, draft.  Don't worry we'll get
+it right eventually.  If you like the package you really should get on
+the mailing list and start participating in it's development.
+
+  Kirk
+
+email: kirk@braille.uwo.ca
+phone: (519) 679-6845 (home)
+
diff --git a/Documentation/speakup/README b/Documentation/speakup/README
new file mode 100644
index 0000000000..4b057e7815
--- /dev/null
+++ b/Documentation/speakup/README
@@ -0,0 +1,98 @@
+Welcome to the speakup project for the Speakup speech package for Linux.
+
+Speakup is written by Kirk Reiser and Andy Berdan.  It is licensed
+under the GPL.  If you don't already know, the GPL stands for the GNU
+General Public License.  Which basically states that this code is free to
+copy, modify and distribute to anyone interested in playing with it.
+The one thing you may not do is turn any part of it into proprietary
+or commercial code without the permission of the author.  That's me.
+
+If you are interested in being involved with the development of speech
+output for Linux you can subscribe to the Speakup mailing list by
+sending a message to speakup-request@braille.uwo.ca with the line: subscribe.  You can also subscribe by going to the speakup web page and following the links at http://www.linux-speakup.org.
+
+We are at a very early stage in the development of this package.
+Hopefully changes will happen often and many.  The current files in
+this directory are:
+
+DefaultKeyAssignments		# speakup's default review keys
+INSTALLATION			#  for installing speakup from the tar ball.
+README				# this file
+keymap-tutorial			# a tutorial on how to layout the keyboard
+
+Read the INSTALLATION file to learn how to apply the patches and the
+default.map for the keyboard.  You should also read the Changes file.
+It really has any new things I've added since last time.
+
+There is no documentation in any of these files to instruct you what
+to do if something goes wrong with the patching or compilation.  If
+you would like that information you will need to subscribe to the
+mailing list and ask for help, or write me kirk@braille.uwo.ca for
+help.  I suggest the mailing list because I will probably tire quickly
+of answering the same questions over and over.  You could always
+decide to dig-in and take on the task, and write documentation to help
+others.
+
+There also is a speakup reflector for the Speak Freely package, which
+many of us hang out on and discuss all sorts of topics from speakup
+problems to ALSA driver installation and just about anything else
+you'd like to talk about.  The reflector is at lwl.braille.uwo.ca:4074
+with it's lwl page at lwl.braille.uwo.ca/speakup.html.  Come and join
+us, it's fun!
+
+Acknowledgements:
+
+I am really very new at kernel hacking and screen review package
+writing, so I have depended heavily on other folks kindness to help me
+a long.  No doubt I will continue to abuse them freely and others
+before this is a really good speech solution for Linux.  (Oh Well!,
+somebody's got to do it.)
+
+Theodore Ts'o.  He gave me a good discussion of unicode and UTF and
+the like.  He doesn't even remember writing me about it.
+
+Alan Cox.  He has answered many questions about scheduling and wait
+queues and timers along with code fragments and so on.  I just wish I
+understood it all totally.  He has also helped immensely in moving
+this package toward inclusion in the standard kernel tree. (Maybe next
+release!)
+
+Martin Mares.  He pointed me in the right direction to figuring out
+the colour attributes and other useful tidbits.
+
+Paul McDermott.  He really is the catalyst for me to actually get
+this all working.  Besides I like seeing him bounce around and get all
+excited every time I have something new working.
+
+John Covici, He was the first person to actually attempt writing
+another synthesizer driver for speakup.  It was the Speakout driver so
+it was also the first serial driver.
+
+Brian Borowski, he was the first person to actually write a speakup
+function other than Andy and I.
+
+Jim Danley, he has more or less become my main man in helping test
+code, add new features, bounce ideas off and generally become a good
+friend.
+
+Matt Campbell, he basically rewrote the drivers to be able to include
+all synths in the kernel at the same time.  The distribution
+maintainers appreciate him a lot as well.
+
+Gene Collins, he was very helpful debugging the current release prior
+to its public showing.  He has also worked hard educating others on
+the list and writing the ALSA mini howto.
+
+I would also like to really thank the folks that handle the
+distribution packages.  I and many other people would not find access
+to speakup nearly so convenient without their efforts.  They include
+Bill Acker, Tom Moore, Matt Campbell, Joe Norton and Joshua Lambert.
+
+There are probably many more I am forgetting right now.  I guess I'll
+just have to add you all later.
+
+
+Happy Hacking!
+
+  Kirk
+
diff --git a/Documentation/speakup/keymap-tutorial b/Documentation/speakup/keymap-tutorial
new file mode 100644
index 0000000000..19896b8ce8
--- /dev/null
+++ b/Documentation/speakup/keymap-tutorial
@@ -0,0 +1,140 @@
+		       Speakup Keymap Tutorial
+
+This is meant to be a basic tutorial on how to change the Linux keymap
+file to assign speakup review functions to desired keys.  It is not
+intended to be a replacement for the loadkeys(8) or keymap(5) man
+pages.
+
+The basic lay-out of the keymap file is a series of lines with the
+following fields.  The keyword keycode indicates this is the start of
+a new key assignment.  It is then followed by a number which
+represents the actual key on the keyboard.  That number is followed by
+the equals '=' operator and finally a list of keywords representing
+key names such as keypad5.  Each line can have quite a few key
+functions on it.  They are interpreted by loadkeys in order and
+assigned to key shift states depending on the order they are
+encountered.  So for example, the first value after the equals is the
+keys unshifted state, while the second is the keys shifted state.  If
+you wish to learn the order they are interpreted in read the
+loadkeys(8) and keymap(5) man pages.
+
+You can have subsequent lines which are indented and start with
+another keyword for the various shifted states.  This way you can
+assign some of the states without having to specify them all in order
+up until you get to the one you want to assign.
+
+In speakup, we have assigned the insert key on the number pad to the
+altgr keyword.  This is not required; you could choose any other
+shifted state keyword.  We used altgr because it typically represents
+the right hand alt key.  In Linux each shift key is separate and
+independent, so the left shift and the right shift keys are not
+necessarily the same.  The altgr key is not really used for anything
+important, so we steel it.
+
+Here are the default key assignments for the number eight on the
+keypad:
+
+keycode  72 = KP_8
+	alt     keycode  72 = Ascii_8
+
+As you can see, the first line starts with keycode followed by 72
+which is the actual number assigned to the key when the keyboard port
+is read.  The KP_8 after the equal sign, is the symbolic representation
+of the function called when that key is hit.
+
+The second line is the same format except it starts with the keyword
+alt which is indented.  That means that the function at the end of
+that line Ascii_8 is applied to the alt-shifted eight key.
+
+Now here are the speakup assignments for that key:
+
+keycode  72 = 0x0d0a
+	altgr keycode 72 = 0x0d20
+#keycode  72 = KP_8
+	alt     keycode  72 = Ascii_8
+
+Notice that the only thing which has changed on the first line is the
+function called when the key is struck.  It is a hexadecimal number
+identifying the function called in a look up table.  It is not a
+symbolic representation yet because that means we need to change the
+loadkeys program to understand our symbolic names.  We will do this in
+the future but for now it is more expedient to just use the table
+indices.  You will find a table at the bottom of this document
+listing the review functions and their corresponding hex lookups.
+
+The 0x0d0a in the first line above is speakup's say line function.
+The second line ends with 0x0d20 which is speakup's read from top of
+screen to reading cursor line.
+
+The third line is the original key assignment commented out with a
+number-sign '#' at the beginning.  I do that so I can easily find the
+keys I want to affect by symbolic name.  Otherwise I would need to
+keep a look up table for all the keycodes.  I recommend you do this as
+well or you'll be very sorry at some point in the future.
+
+The forth line is just the standard key assignment for the left hand
+alt key.
+
+Now let's say we want to design a different keyboard layout.  I'll use
+an example for the JAWS style keypad because I've specifically been
+asked to help with that.  JAWS uses the eight on the keypad to move up
+a line or the speakup function to read previous line.  JAWS also uses
+the keypad_8 key in a shifted mode to read the current line.  I
+apologize if these are not quite right.  It has been a long time since
+I used JAWS.  So we would have the following two lines:
+
+keycode  72 = 0x0d0b
+	altgr keycode 72 = 0x0d0a
+
+The hex value 0x0d0b in the first line is speakup's SAY_PREVIOUS_LINE
+function.  The 0x0d0a in the second line is the same say_line function
+as we had earlier.  So when the number eight is hit on the keypad
+speakup will read the previous line and when the number eight is
+shifted with the insert key on the keypad it will read the current
+line.
+
+As you can tell, it is not really very difficult to reassign the keys
+to different review functions.
+
+Once you have carefully edited the keymap file, called default.map in
+the speakup distribution, you copy it into the /etc/kbd directory.
+Make sure you back up the original default.map from that directory
+first, if there is one.  Then you run loadkeys to load the new map
+into the kernel:
+
+loadkeys /etc/kbd/default.map
+
+If you wish to build your new keyboard lay-out into the kernel, after
+testing it, copy the default.map file into the drivers/char directory,
+with the name defkeymap.map, of your Linux source tree.  Then rm the
+defkeymap.c file and recompile the kernel.  Because there is no
+defkeymap.c `make' will rebuild it on the next compile.
+
+Here is a list of the available speakup review functions at this point
+in time.
+
+SAY_CHAR 0x0d04 /* say this character */
+SAY_PREV_CHAR 0x0d05 /* say character left of this char */
+SAY_NEXT_CHAR 0x0d06 /* say char right of this char */
+SAY_WORD 0x0d07 /* say this word under reading cursor */
+SAY_PREV_WORD 0x0d08
+SAY_NEXT_WORD 0x0d09
+SAY_LINE 0x0d0a /* say this line */
+SAY_PREV_LINE 0x0d0b /* say line above this line */
+SAY_NEXT_LINE 0x0d0c
+TOP_EDGE 0x0d0d /* move to top edge of screen */
+BOTTOM_EDGE 0x0d0e
+LEFT_EDGE 0x0d0f
+RIGHT_EDGE 0x0d10
+SAY_PHONETIC_CHAR 0x0d11 /* say this character phonetically */
+SPELL_WORD 0x0d12 /* spell this word letter by letter */
+SAY_SCREEN 0x0d14
+SAY_POSITION 0x0d1b
+SPEECH_OFF 0x0d1c
+SAY_ATTRIBUTES 0x0d1d
+SPEAKUP_PARKED 0x0d1e
+SAY_FROM_TOP 0x0d20
+SAY_TO_BOTTOM 0x0d21
+SAY_FROM_LEFT 0x0d22
+SAY_TO_RIGHT 0x0d23
+
diff --git a/Documentation/speakup/spkguide.txt b/Documentation/speakup/spkguide.txt
new file mode 100644
index 0000000000..ae8ad3cb6f
--- /dev/null
+++ b/Documentation/speakup/spkguide.txt
@@ -0,0 +1,1279 @@
+
+The Speakup User's Guide
+For Speakup 2.0 and Later
+By Gene Collins
+Last modified on Tue Mar 29 10:54:19 2005
+Document version 1.0
+
+Copyright (c) 2005  Gene Collins
+
+Permission is granted to copy, distribute and/or modify this document
+under the terms of the GNU Free Documentation License, Version 1.2 or
+any later version published by the Free Software Foundation; with no
+Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
+copy of the license is included in the section entitled "GNU Free
+Documentation License".
+
+Preface
+
+The purpose of this document is to familiarize users with the user
+interface to Speakup, a Linux Screen Reader.  If you need instructions
+for installing or obtaining Speakup, visit the web site at
+http://linux-speakup.org/.  Speakup is a set of patches to the standard
+Linux kernel source tree.  It can be built as a series of modules, or as
+a part of a monolithic kernel.  These details are beyond the scope of
+this manual, but the user may need to be aware of the module
+capabilities, depending on how your system administrator has installed
+Speakup.  If Speakup is built as a part of a monolithic kernel, and the
+user is using a hardware synthesizer, then Speakup will be able to
+provide speech access from the time the kernel is loaded, until the time
+the system is shutdown.  This means that if you have obtained Linux
+installation media for a distribution which includes Speakup as a part
+of its kernel, you will be able, as a blind person, to install Linux
+with speech access unaided by a sighted person.  Again, these details
+are beyond the scope of this manual, but the user should be aware of
+them.  See the web site mentioned above for further details.
+
+1.  Starting Speakup
+
+If your system administrator has installed Speakup to work with your
+specific synthesizer by default, then all you need to do to use Speakup
+is to boot your system, and Speakup should come up talking.  This
+assumes of course  that your synthesizer is a supported hardware
+synthesizer, and that it is either installed in or connected to your
+system, and is if necessary powered on.
+
+It is possible, however, that Speakup may have been compiled into the
+kernel with no default synthesizer.  It is even possible that your
+kernel has been compiled with support for some of the supported
+synthesizers and not others.  If you find that this is the case, and
+your synthesizer is supported but not available, complain to the person
+who compiled and installed your kernel.  Or better yet, go to the web
+site, and learn how to patch Speakup into your own kernel source, and
+build and install your own kernel.
+
+If your kernel has been compiled with Speakup, and has no default
+synthesizer set, or you would like to use a different synthesizer than
+the default one, then you may issue the following command at the boot
+prompt of your boot loader.
+
+linux speakup_synth=ltlk
+
+This command would tell Speakup to look for and use a LiteTalk or
+DoubleTalk LT at boot up.  You may replace the ltlk synthesizer keyword
+with the keyword for whatever synthesizer you wish to use.  The
+speakup_synth parameter will accept the following keywords, provided
+that support for the related synthesizers has been built into the
+kernel.
+
+acntsa -- Accent SA
+acntpc -- Accent PC
+apolo -- Apolo
+audptr -- Audapter
+bns -- Braille 'n Speak
+dectlk -- DecTalk Express (old and new, db9 serial only)
+decext -- DecTalk (old) External
+dtlk -- DoubleTalk PC
+keypc -- Keynote Gold PC
+ltlk -- DoubleTalk LT, LiteTalk, or external Tripletalk (db9 serial only)
+spkout -- Speak Out
+txprt -- Transport
+
+Note: Speakup does * NOT * support usb connections!  Speakup also does *
+NOT * support the internal Tripletalk!
+
+Speakup does support two other synthesizers, but because they work in
+conjunction with other software, they must be loaded as modules after
+their related software is loaded, and so are not available at boot up.
+These are as follows:
+
+decpc -- DecTalk PC (not available at boot up)
+sftsyn -- One of several software synthesizers (not available at boot up)
+
+See the sections on loading modules and software synthesizers later in
+this manual for further details.  It should be noted here that the
+speakup_synth boot parameter will have no effect if Speakup has been
+compiled as modules.  In order for Speakup modules to be loaded during
+the boot process, such action must be configured by your system
+administrator.  This will mean that you will hear some, but not all,  of
+the bootup messages.
+
+2.  Basic operation
+
+Once you have booted the system, and if necessary, have supplied the
+proper bootup parameter for your synthesizer, Speakup will begin
+talking as soon as the kernel is loaded.  In fact, it will talk a lot!
+It will speak all the boot up messages that the kernel prints on the
+screen during the boot process.  This is because Speakup is not a
+separate screen reader, but is actually built into the operating
+system.  Since almost all console applications must print text on the
+screen using the kernel, and must get their keyboard input through the
+kernel, they are automatically handled properly by Speakup.  There are a
+few exceptions, but we'll come to those later.
+
+Note:  In this guide I will refer to the numeric keypad as the keypad.
+This is done because the speakupmap.map file referred to later in this
+manual uses the term keypad instead of numeric keypad.  Also I'm lazy
+and would rather only type one word.  So keypad it is.  Got it?  Good.
+
+Most of the Speakup review keys are located on the keypad at the far
+right of the keyboard.  The numlock key should be off, in order for these
+to work.  If you toggle the numlock on, the keypad will produce numbers,
+which is exactly what you want for spreadsheets and such.  For the
+purposes of this guide, you should have the numlock turned off, which is
+its default state at bootup.
+
+You probably won't want to listen to all the bootup messages every time
+you start your system, though it's a good idea to listen to them at
+least once, just so you'll know what kind of information is available to
+you during the boot process.  You can always review these messages after
+bootup with the command:
+
+dmesg | more
+
+In order to speed the boot process, and to silence the speaking of the
+bootup messages, just press the keypad enter key.  This key is located
+in the bottom right corner of the keypad.  Speakup will shut up and stay
+that way, until you press another key.
+
+You can check to see if the boot process has completed by pressing the 8
+key on the keypad, which reads the current line.  This also has the
+effect of starting Speakup talking again, so you can press keypad enter
+to silence it again if the boot process has not completed.
+
+When the boot process is complete, you will arrive at a "login" prompt.
+At this point, you'll need to type in your user id and password, as
+provided by your system administrator.  You will hear Speakup speak the
+letters of your user id as you type it, but not the password.  This is
+because the password is not displayed on the screen for security
+reasons.  This has nothing to do with Speakup, it's a Linux security
+feature.
+
+Once you've logged in, you can run any Linux command or program which is
+allowed by your user id.  Normal users will not be able to run programs
+which require root privileges.
+
+When you are running a program or command, Speakup will automatically
+speak new text as it arrives on the screen.  You can at any time silence
+the speech with keypad enter, or use any of the Speakup review keys.
+
+Here are some basic Speakup review keys, and a short description of what
+they do.
+
+keypad 1 -- read previous character
+keypad 2 -- read current character (pressing keypad 2 twice rapidly will speak
+	the current character phonetically)
+keypad 3 -- read next character
+keypad 4 -- read previous word
+keypad 5 -- read current word (press twice rapidly to spell the current word)
+keypad 6 -- read next word
+keypad 7 -- read previous line
+keypad 8 -- read current line (press twice rapidly to hear how much the
+	text on the current line is indented)
+keypad 9 -- read next line
+keypad period -- speak current cursor position and announce current
+	virtual console
+
+It's also worth noting that the insert key on the keypad is mapped
+as the speakup key.  Instead of pressing and releasing this key, as you
+do under DOS or Windows, you hold it like a shift key, and press other
+keys in combination with it.  For example, repeatedly holding keypad
+insert, from now on called speakup, and keypad enter will toggle the
+speaking of new text on the screen on and off.  This is not the same as
+just pressing keypad enter by itself, which just silences the speech
+until you hit another key.  When you hit speakup plus keypad enter,
+Speakup will say, "You turned me off.", or "Hey, that's better."  When
+Speakup is turned off, no new text on the screen will be spoken.  You
+can still use the reading controls to review the screen however.
+
+3.  Using the Speakup Help System
+
+Speakup has a help system, which is compiled as a module.  It is loaded
+automatically whenever the Speakup help system is invoked for the first
+time, and remains loaded after that, until speakup is unloaded.  Note
+that if speakup was compiled into a monolithic kernel on your system,
+you will not be able to unload Speakup from your kernel.  If you try to
+use the help system, and find that it is unavailable, then your system
+administrator has not installed the Speakup help module, which is called
+speakup_help.  Complain to your system administrator about this.
+
+In order to enter the Speakup help system, press and hold the speakup
+key (remember that this is the keypad insert key), and press the f1 key.
+You will hear the message:
+
+"Press space to leave help, cursor up or down to scroll, or a letter to
+go to commands in list."
+
+When you press the spacebar to leave the help system, you will hear:
+
+"Leaving help."
+
+While you are in the Speakup help system, you can scroll up or down
+through the list of available commands using the cursor keys.  The list
+of commands is arranged in alphabetical order.  If you wish to jump to
+commands in a specific part of the alphabet, you may press the letter of
+the alphabet you wish to jump to.
+
+You can also just explore by typing keyboard keys.  Pressing keys will
+cause Speakup to speak the command associated with that key.  For
+example, if you press the keypad 8 key, you will hear:
+
+"Keypad 8 is line, say current."
+
+You'll notice that some commands do not have keys assigned to them.
+This is because they are very infrequently used commands, and are also
+accessible through the proc system.  We'll discuss the proc system later
+in this manual.
+
+You'll also notice that some commands have two keys assigned to them.
+This is because Speakup has a built in set of alternative key bindings
+for laptop users.  The alternate speakup key is the caps lock key.  You
+can press and hold the caps lock key, while pressing an alternate
+speakup command key to activate the command.  On most laptops, the
+numeric keypad is defined as the keys in the j k l area of the keyboard.
+
+There is usually a function key which turns this keypad function on and
+off, and some other key which controls the numlock state.  Toggling the
+keypad functionality on and off can become a royal pain.  So, Speakup
+gives you a simple way to get at an alternative set of key mappings for
+your laptop.  These are also available by default on desktop systems,
+because Speakup does not know whether it is running on a desktop or
+laptop.  So you may choose which set of Speakup keys to use.  Some
+system administrators may have chosen to compile Speakup for a desktop
+system without this set of alternate key bindings, but these details are
+beyond the scope of this manual.  To use the caps lock for its normal
+purpose, hold the shift key while toggling the caps lock on and off.  We
+should note here, that holding the caps lock key and pressing the z key
+will toggle the alternate j k l keypad on and off.
+
+4.  Keys and Their Assigned Commands
+
+In this section, we'll go through a list of all the speakup keys and
+commands.  You can also get a list of commands and assigned keys from
+the help system.
+
+The following list was taken from the speakupmap.map file.  Key
+assignments are on the left of the equal sign, and the associated
+Speakup commands are on the right.  The designation "spk" means to press
+and hold the speakup key, a.k.a. keypad insert, a.k.a. caps lock, while
+pressing the other specified key.
+
+spk key_f9 = punc_level_dec
+spk key_f10 = punc_level_inc
+spk key_f11 = reading_punc_dec
+spk key_f12 = reading_punc_inc
+spk key_1 = vol_dec
+spk key_2 =  vol_inc
+spk key_3 = pitch_dec
+spk key_4 = pitch_inc
+spk key_5 = rate_dec
+spk key_6 = rate_inc
+key_kpasterisk = toggle_cursoring
+spk key_kpasterisk = speakup_goto
+spk key_f1 = speakup_help
+spk key_f2 = set_win
+spk key_f3 = clear_win
+spk key_f4 = enable_win
+spk key_f5 = edit_some
+spk key_f6 = edit_most
+spk key_f7 = edit_delim
+spk key_f8 = edit_repeat
+shift spk key_f9 = edit_exnum
+ key_kp7 = say_prev_line
+spk key_kp7 = left_edge
+ key_kp8 = say_line
+double  key_kp8 = say_line_indent
+spk key_kp8 = say_from_top
+ key_kp9 = say_next_line
+spk  key_kp9 = top_edge
+ key_kpminus = speakup_parked
+spk key_kpminus = say_char_num
+ key_kp4 = say_prev_word
+spk key_kp4 = say_from_left
+ key_kp5 = say_word
+double key_kp5 = spell_word
+spk key_kp5 = spell_phonetic
+ key_kp6 = say_next_word
+spk key_kp6 = say_to_right
+ key_kpplus = say_screen
+spk key_kpplus = say_win
+ key_kp1 = say_prev_char
+spk key_kp1 = right_edge
+ key_kp2 = say_char
+spk key_kp2 = say_to_bottom
+double key_kp2 = say_phonetic_char
+ key_kp3 = say_next_char
+spk  key_kp3 = bottom_edge
+ key_kp0 = spk_key
+ key_kpdot = say_position
+spk key_kpdot = say_attributes
+key_kpenter = speakup_quiet
+spk key_kpenter = speakup_off
+key_sysrq = speech_kill
+ key_kpslash = speakup_cut
+spk key_kpslash = speakup_paste
+spk key_pageup = say_first_char
+spk key_pagedown = say_last_char
+key_capslock = spk_key
+ spk key_z = spk_lock
+key_leftmeta = spk_key
+ctrl spk key_0 = speakup_goto
+spk key_u = say_prev_line
+spk key_i = say_line
+double spk key_i = say_line_indent
+spk key_o = say_next_line
+spk key_minus = speakup_parked
+shift spk key_minus = say_char_num
+spk key_j = say_prev_word
+spk key_k = say_word
+double spk key_k = spell_word
+spk key_l = say_next_word
+spk key_m = say_prev_char
+spk key_comma = say_char
+double spk key_comma = say_phonetic_char
+spk key_dot = say_next_char
+spk key_n = say_position
+ ctrl spk key_m = left_edge
+ ctrl spk key_y = top_edge
+ ctrl spk key_dot = right_edge
+ctrl spk key_p = bottom_edge
+spk key_apostrophe = say_screen
+spk key_h = say_from_left
+spk key_y = say_from_top
+spk key_semicolon = say_to_right
+spk key_p = say_to_bottom
+spk key_slash = say_attributes
+ spk key_enter = speakup_quiet
+ ctrl  spk key_enter = speakup_off
+ spk key_9 = speakup_cut
+spk key_8 = speakup_paste
+shift spk key_m = say_first_char
+ ctrl spk key_semicolon = say_last_char
+
+5.  The Speakup Proc System
+
+The Speakup screen reader also creates a speakup subdirectory as a part
+of the proc system.  You can see these entries by typing the command:
+
+ls -1 /proc/speakup/*
+
+If you issue the above ls command, you will get back something like
+this:
+
+/proc/speakup/attrib_bleep
+/proc/speakup/bell_pos
+/proc/speakup/bleep_time
+/proc/speakup/bleeps
+/proc/speakup/caps_start
+/proc/speakup/caps_stop
+/proc/speakup/characters
+/proc/speakup/cursor_time
+/proc/speakup/delay_time
+/proc/speakup/delimiters
+/proc/speakup/ex_num
+/proc/speakup/freq
+/proc/speakup/full_time
+/proc/speakup/jiffy_delta
+/proc/speakup/key_echo
+/proc/speakup/keymap
+/proc/speakup/no_interrupt
+/proc/speakup/pitch
+/proc/speakup/punc_all
+/proc/speakup/punc_level
+/proc/speakup/punc_most
+/proc/speakup/punc_some
+/proc/speakup/punct
+/proc/speakup/rate
+/proc/speakup/reading_punc
+/proc/speakup/repeats
+/proc/speakup/say_control
+/proc/speakup/say_word_ctl
+/proc/speakup/silent
+/proc/speakup/spell_delay
+/proc/speakup/synth_direct
+/proc/speakup/synth_name
+/proc/speakup/tone
+/proc/speakup/trigger_time
+/proc/speakup/version
+/proc/speakup/voice
+/proc/speakup/vol
+
+In addition to using the Speakup hot keys to change such things as
+volume, pitch, and rate, you can also echo values to the appropriate
+entry in the /proc/speakup directory.  This is very useful, since it
+lets you control Speakup parameters from within a script.  How you
+would write such scripts is somewhat beyond the scope of this manual,
+but I will include a couple of simple examples here to give you a
+general idea of what such scripts can do.
+
+Suppose for example, that you wanted to control both the punctuation
+level and the reading punctuation level at the same time.  For
+simplicity, we'll call them punc0, punc1, punc2, and punc3.  The scripts
+might look something like this:
+
+#!/bin/bash
+# punc0
+# set punc and reading punc levels to 0
+echo 0 >/proc/speakup/punc_level
+echo 0 >/proc/speakup/reading_punc
+echo Punctuation level set to 0.
+
+#!/bin/bash
+# punc1
+# set punc and reading punc levels to 1
+echo 1 >/proc/speakup/punc_level
+echo 1 >/proc/speakup/reading_punc
+echo Punctuation level set to 1.
+
+#!/bin/bash
+# punc2
+# set punc and reading punc levels to 2
+echo 2 >/proc/speakup/punc_level
+echo 2 >/proc/speakup/reading_punc
+echo Punctuation level set to 2.
+
+#!/bin/bash
+# punc3
+# set punc and reading punc levels to 3
+echo 3 >/proc/speakup/punc_level
+echo 3 >/proc/speakup/reading_punc
+echo Punctuation level set to 3.
+
+If you were to store these four small scripts in a directory in your
+path, perhaps /usr/local/bin, and set the permissions to 755 with the
+chmod command, then you could change the default reading punc and
+punctuation levels at the same time by issuing just one command.  For
+example, if you were to execute the punc3 command at your shell prompt,
+then the reading punc and punc level would both get set to 3.
+
+I should note that the above scripts were written to work with bash, but
+regardless of which shell you use, you should be able to do something
+similar.
+
+The Speakup proc system also has another interesting use.  You can echo
+Speakup parameters into the proc system in a script during system
+startup, and speakup will return to your preferred parameters every time
+the system is rebooted.
+
+Most of the Speakup proc parameters can be manipulated by a regular user
+on the system.  However, there are a few parameters that are dangerous
+enough that they should only be manipulated by the root user on your
+system.  There are even some parameters that are read only, and cannot
+be written to at all.  For example, the version entry in the Speakup
+proc system is read only.  This is because there is no reason for a user
+to tamper with the version number which is reported by Speakup.  Doing
+an ls -l on /proc/speakup/version will return this:
+
+-r--r--r--    1 root     root            0 Mar 21 13:46 /proc/speakup/version
+
+As you can see, the version entry in the Speakup proc system is read
+only, is owned by root, and belongs to the root group.  Doing a cat of
+/proc/speakup/version will display the Speakup version number, like
+this:
+
+cat /proc/speakup/version
+Speakup v-2.00 CVS: Thu Oct 21 10:38:21 EDT 2004
+synth dtlk version 1.1
+
+The display shows the Speakup version number, along with the version
+number of the driver for the current synthesizer.
+
+Looking at entries in the Speakup proc system can be useful in many
+ways.  For example, you might wish to know what level your volume is set
+at.  You could type:
+
+cat /proc/speakup/vol
+5
+
+The number five which comes back is the level at which the synthesizer
+volume is set at.
+
+All the entries in the Speakup proc system are readable, some are
+writable by root only, and some are writable by everyone.  Unless you
+know what you are doing, you should probably leave the ones that are
+writable by root only alone.  Most of the names are self explanatory.
+Vol for controlling volume, pitch for pitch, rate for controlling speaking
+rate, etc.  If you find one you aren't sure about, you can post a query
+on the Speakup list.
+
+6.  Changing Synthesizers
+
+It is possible to change to a different synthesizer while speakup is
+running.  In other words, it is not necessary to reboot the system
+in order to use a different synthesizer.  You can simply echo the
+synthesizer keyword to the /proc/speakup/synth_name proc entry.
+Depending on your situation, you may wish to echo none to the synth_name
+proc entry, to disable speech while one synthesizer is disconnected and
+a second one is connected in its place.  Then echo the keyword for the
+new synthesizer into the synth_name proc entry in order to start speech
+with the newly connected synthesizer.  See the list of synthesizer
+keywords in section 1 to find the keyword which matches your synth.
+
+7.  Loading modules
+
+As mentioned earlier, Speakup can either be completely compiled into the
+kernel, with the exception of the help module, or it can be compiled as
+a series of modules.   When compiled as modules, Speakup will only be
+able to speak some of the bootup messages if your system administrator
+has configured the system to load the modules at boo time. The modules
+can  be loaded after the file systems have been checked and mounted, or
+from an initrd.  There is a third possibility.  Speakup can be compiled
+with some components built into the kernel, and others as modules.  As
+we'll see in the next section, this is particularly useful when you are
+working with software synthesizers.
+
+If Speakup is completely compiled as modules, then you must use the
+modprobe command to load Speakup.  You do this by loading the module for
+the synthesizer driver you wish to use.  The driver modules are all
+named speakup_<keyword>, where <keyword> is the keyword for the
+synthesizer you want.  So, in order to load the driver for the DecTalk
+Express, you would type the following command:
+
+modprobe speakup_dectlk
+
+Issuing this command would load the DecTalk Express driver and all other
+related Speakup modules necessary to get Speakup up and running.
+
+To completely unload Speakup, again presuming that it is entirely built
+as modules, you would give the command:
+
+modprobe -r speakup_dectlk
+
+The above command assumes you were running a DecTalk Express.  If you
+were using a different synth, then you would substitute its keyword in
+place of dectlk.
+
+But now, suppose we have a situation where the main Speakup component
+is built into the kernel, and some or all of the drivers are built as
+modules.  Since the main part of Speakup is compiled into the kernel, a
+partial Speakup proc system has been created which we can take advantage
+of by simply echoing the synthesizer keyword into the
+/proc/speakup/synth_name proc entry.  This will cause the kernel to
+automatically load the appropriate driver module, and start Speakup
+talking.  To switch to another synth, just echo a new keyword to the
+synth_name proc entry.  For example, to load the DoubleTalk LT driver,
+you would type:
+
+echo ltlk >/proc/speakup/synth_name
+
+You can use the modprobe -r command to unload driver modules, regardless
+of whether the main part of Speakup has been built into the kernel or
+not.
+
+8.  Using Software Synthesizers
+
+Using a software synthesizer requires that some other software be
+installed and running on your system.  For this reason, software
+synthesizers are not available for use at bootup, or during a system
+installation process.
+
+In order to use a software synthesizer, you must have a package called
+Speech Dispatcher running on your system, and it must be configured to
+work with one of its supported software synthesizers.
+
+Two open source synthesizers you might use are Flite and Festival.  You
+might also choose to purchase the Software DecTalk from Fonix Sales Inc.
+If you run a google search for Fonix, you'll find their web site.
+
+You can obtain a copy of Speech Dispatcher from free(b)soft at
+http://www.freebsoft.org/.  Follow the installation instructions that
+come with Speech Dispatcher in order to install and configure Speech
+Dispatcher.  You can check out the web site for your Linux distribution
+in order to get a copy of either Flite or Festival.  Your Linux
+distribution may also have a precompiled Speech Dispatcher package.
+
+Once you've installed, configured, and tested Speech Dispatcher with your
+chosen software synthesizer, you still need one more piece of software
+in order to make things work.  You need a package called speechd-up.
+You get it from the free(b)soft web site mentioned above.  After you've
+compiled and installed speechd-up, you are almost ready to begin using
+your software synthesizer.
+
+Before you can use a software synthesizer, you must have created the
+/dev/softsynth device.  If you have not already done so, issue the
+following commands as root:
+
+cd /dev
+mknod softsynth c 10 26
+
+While we are at it, we might just as well create the /dev/synth device,
+which can be used to let user space programs send information to your
+synthesizer.  To create /dev/synth, change to the /dev directory, and
+issue the following command as root:
+
+mknod synth c 10 25
+
+Now you can begin using your software synthesizer.  In order to do so,
+echo the sftsyn keyword to the synth_name proc entry like this:
+
+echo sftsyn >/proc/speakup/synth_name
+
+Next run the speechd_up command like this:
+
+speechd_up &
+
+Your synth should now start talking, and you should be able to adjust
+the pitch, rate, etc.
+
+In this section, we have assumed that your copy of Speakup was compiled
+with the speakup_sftsyn component either built into the kernel, or
+compiled as a module.
+
+9.  Using The DecTalk PC Card
+
+The DecTalk PC card is an ISA card that is inserted into one of the ISA
+slots in your computer.  It requires that the DecTalk PC software be
+installed on your computer, and that the software be loaded onto the
+Dectalk PC card before it can be used.
+
+You can get the dec_pc.tgz file from the linux-speakup.org site.  The
+dec_pc.tgz file is in the ~ftp/pub/linux/speakup directory.
+
+After you have downloaded the dec_pc.tgz file, untar it in your home
+directory, and read the Readme file in the newly created dec_pc
+directory.
+
+The easiest way to get the software working is to copy the entire dec_pc
+directory into /user/local/lib.  To do this, su to root in your home
+directory, and issue the command:
+
+cp dec_pc /usr/local/lib
+
+You will need to copy the dtload command from the dec_pc directory to a
+directory in your path.  Either /usr/bin or /usr/local/bin is a good
+choice.
+
+You can now run the dtload command in order to load the DecTalk PC
+software onto the card.  After you have done this, echo the decpc
+keyword to the synth_name entry in the proc system like this:
+
+echo decpc >/proc/speakup/synth_name
+
+Your DecTalk PC should start talking, and then you can adjust the pitch,
+rate, volume, voice, etc.  The voice entry in the Speakup proc system
+will accept a number from 0 through 7 for the DecTalk PC synthesizer,
+which will give you access to some of the DecTalk voices.
+
+10.  Using Cursor Tracking
+
+In Speakup version 2.0 and later, cursor tracking is turned on by
+default.  This means that when you are using an editor, Speakup will
+automatically speak characters as you move left and right with the
+cursor keys, and lines as you move up and down with the cursor keys.
+
+This is extremely useful, and makes editing files a snap.  But there are
+times when cursor tracking can get in your way.  So Speakup provides a
+toggle to turn cursor tracking on and off.  You do this with the keypad
+asterisk key.  Pressing this key repeatedly will toggle the cursor
+tracking on and off, and you will hear Speakup say, "cursoring off", and
+"cursoring on".
+
+Some folks like to turn cursor tracking off while they are using the
+lynx web browser.  You definitely want to turn cursor tracking off when
+you are using the alsamixer application.  Otherwise, you won't be able
+to hear your mixer settings while you are using the arrow keys.
+
+11.  Cut and Paste
+
+One of Speakup's more useful features is the ability to cut and paste
+text on the screen.  This means that you can capture information from a
+program, and paste that captured text into a different place in the
+program, or into an entirely different program, which may even be
+running on a different console.
+
+For example, in this manual, we have made references to several web
+sites.  It would be nice if you could cut and paste these urls into your
+web browser.  Speakup does this quite nicely.  Suppose you wanted to
+past the following url into your browser:
+
+http://linux-speakup.org/
+
+Use the speakup review keys to position the reading cursor on the first
+character of the above url.  When the reading cursor is in position,
+press the keypad slash key once.  Speakup will say, "mark".  Next,
+position the reading cursor on the rightmost character of the above
+url. Press the keypad slash key once again to actually cut the text
+from the screen.  Speakup will say, "cut".  Although we call this
+cutting, Speakup does not actually delete the cut text from the screen.
+It makes a copy of the text in a special buffer for later pasting.
+
+Now that you have the url cut from the screen, you can paste it into
+your browser, or even paste the url on a command line as an argument to
+your browser.
+
+Suppose you want to start lynx and go to the Speakup site.
+
+You can switch to a different console with the alt left and right
+arrows, or you can switch to a specific console by typing alt and a
+function key.  These are not Speakup commands, just standard Linux
+console capabilities.
+
+Once you've changed to an appropriate console, and are at a shell prompt,
+type the word lynx, followed by a space.  Now press and hold the speakup
+key, while you type the keypad slash character.  The url will be pasted
+onto the command line, just as though you had typed it in.  Press the
+enter key to execute the command.
+
+The paste buffer will continue to hold the cut information, until a new
+mark and cut operation is carried out.  This means you can paste the cut
+information as many times as you like before doing another cut
+operation.
+
+You are not limited to cutting and pasting only one line on the screen.
+You can also cut and paste rectangular regions of the screen.  Just
+position the reading cursor at the top left corner of the text to be
+cut, mark it with the keypad slash key, then position the reading cursor
+at the bottom right corner of the region to be cut, and cut it with the
+keypad slash key.
+
+12.  Changing the Pronunciation of Characters
+
+Through the /proc/speakup/chars proc entry, Speakup gives you the
+ability to change how Speakup pronounces a given character.  You could,
+for example, change how some punctuation characters are spoken.  You can
+even change how Speakup will pronounce certain letters.
+
+You may, for example, wish to change how Speakup pronounces the z
+character.  The author of Speakup, Kirk Reiser, is Canadian, and thus
+believes that the z should be pronounced zed.  If you are an American,
+you might wish to use the zee pronunciation instead of zed.  You can
+change the pronunciation of both the upper and lower case z with the
+following two commands:
+
+echo 90 zee >/proc/speakup/characters
+echo 122 zee >/proc/speakup/characters
+
+Let's examine the parts of the two previous commands.  They are issued
+at the shell prompt, and could be placed in a startup script.
+
+The word echo tells the shell that you want to have it display the
+string of characters that follow the word echo.  If you were to just
+type:
+
+echo hello.
+
+You would get the word hello printed on your screen as soon as you
+pressed the enter key.  In this case, we are echoing strings that we
+want to be redirected into the proc system.
+
+The numbers 90 and 122 in the above echo commands are the ascii numeric
+values for the upper and lower case z, the characters we wish to change.
+
+The string zee is the pronunciation that we want Speakup to use for the
+upper and lower case z.
+
+The > symbol redirects the output of the echo command to a file, just
+like in DOS, or at the Windows command prompt.
+
+And finally, /proc/speakup/chars is the file entry in the proc system
+where we want the output to be directed.  Speakup looks at the numeric
+value of the character we want to change, and inserts the pronunciation
+string into an internal table.
+
+You can look at the whole table with the following command:
+
+cat /proc/speakup/chars
+
+Speakup will then print out the entire character pronunciation table.  I
+won't display it here, but leave you to look at it at your convenience.
+
+13.  Mapping Keys
+
+Speakup has the capability of allowing you to assign or "map" keys to
+internal Speakup commands.  This section necessarily assumes you have a
+Linux kernel source tree installed, and that it has been patched and
+configured with Speakup.  How you do this is beyond the scope of this
+manual.  For this information, visit the Speakup web site at
+http://linux-speakup.org/.  The reason you'll need the kernel source
+tree patched with Speakup is that the genmap utility you'll need for
+processing keymaps is in the
+/usr/src/linux-<version_number>/drivers/char/speakup directory.  The
+<version_number> in the above directory path is the version number of
+the Linux source tree you are working with.
+
+So ok, you've gone off and gotten your kernel source tree, and patched
+and configured it.  Now you can start manipulating keymaps.
+
+You can either use the
+/usr/src/linux-<version_number>/drivers/char/speakup/speakupmap.map file
+included with the Speakup source, or you can cut and paste the copy in
+section 4 into a separate file.  If you use the one in the Speakup
+source tree, make sure you make a backup of it before you start making
+changes.  You have been warned!
+
+Suppose that you want to swap the key assignments for the Speakup
+say_last_char and the Speakup say_first_char commands.  The
+speakupmap.map lists the key mappings for these two commands as follows:
+
+spk key_pageup = say_first_char
+spk key_pagedown = say_last_char
+
+You can edit your copy of the speakupmap.map file and swap the command
+names on the right side of the = (equals) sign.  You did make a backup,
+right?  The new keymap lines would look like this:
+
+spk key_pageup = say_last_char
+spk key_pagedown = say_first_char
+
+After you edit your copy of the speakupmap.map file, save it under a new
+file name, perhaps newmap.map.  Then exit your editor and return to the
+shell prompt.
+
+You are now ready to load your keymap with your swapped key assignments.
+ Assuming that you saved your new keymap as the file newmap.map, you
+would load your keymap into the proc system like this:
+
+/usr/src/linux-<version_number>/drivers/char/speakup/genmap newmap.map
+>/proc/speakup/keymap
+
+Remember to substitute your kernel version number for the
+<version_number> in the above command.  Also note that although the
+above command wrapped onto two lines in this document, you should type
+it all on one line.
+
+Your say first and say last characters should now be swapped.  Pressing
+speakup pagedown should read you the first non-whitespace character on
+the line your reading cursor is in, and pressing speakup pageup should
+read you the last character on the line your reading cursor is in.
+
+You should note that these new mappings will only stay in effect until
+you reboot, or until you load another keymap.
+
+One final warning.  If you try to load a partial map, you will quickly
+find that all the mappings you didn't include in your file got deleted
+from the working map.  Be extremely careful, and always make a backup!
+You have been warned!
+
+14.  Using Speakup's Windowing Capability
+
+Speakup has the capability of defining and manipulating windows on the
+screen.  Speakup uses the term "Window", to mean a user defined area of
+the screen.  The key strokes for defining and manipulating Speakup
+windows are as follows:
+
+speakup + f2 -- Set the bounds of the window.
+Speakup + f3 -- clear the current window definition.
+speakup + f4 -- Toggle window silence on and off.
+speakup + keypad plus -- Say the currently defined window.
+
+These capabilities are useful for tracking a certain part of the screen
+without rereading the whole screen, or for silencing a part of the
+screen that is constantly changing, such as a clock or status line.
+
+There is no way to save these window settings, and you can only have one
+window defined for each virtual console.  There is also no way to have
+windows automaticly defined for specific applications.
+
+In order to define a window, use the review keys to move your reading
+cursor to the beginning of the area you want to define.  Then press
+speakup + f2.  Speakup will tell you that the window starts at the
+indicated row and column position.  Then move the reading cursor to the
+end of the area to be defined as a window, and press speakup + f2 again.
+ If there is more than one line in the window, Speakup will tell you
+that the window ends at the indicated row and column position.  If there
+is only one line in the window, then Speakup will tell you that the
+window is the specified line on the screen.  If you are only defining a
+one line window, you can just press speakup + f2 twice after placing the
+reading cursor on the line you want to define as a window.  It is not
+necessary to position the reading cursor at the end of the line in order
+to define the whole line as a window.
+
+                GNU Free Documentation License
+                  Version 1.2, November 2002
+
+
+ Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+
+0. PREAMBLE
+
+The purpose of this License is to make a manual, textbook, or other
+functional and useful document "free" in the sense of freedom: to
+assure everyone the effective freedom to copy and redistribute it,
+with or without modifying it, either commercially or noncommercially.
+Secondarily, this License preserves for the author and publisher a way
+to get credit for their work, while not being considered responsible
+for modifications made by others.
+
+This License is a kind of "copyleft", which means that derivative
+works of the document must themselves be free in the same sense.  It
+complements the GNU General Public License, which is a copyleft
+license designed for free software.
+
+We have designed this License in order to use it for manuals for free
+software, because free software needs free documentation: a free
+program should come with manuals providing the same freedoms that the
+software does.  But this License is not limited to software manuals;
+it can be used for any textual work, regardless of subject matter or
+whether it is published as a printed book.  We recommend this License
+principally for works whose purpose is instruction or reference.
+
+
+1. APPLICABILITY AND DEFINITIONS
+
+This License applies to any manual or other work, in any medium, that
+contains a notice placed by the copyright holder saying it can be
+distributed under the terms of this License.  Such a notice grants a
+world-wide, royalty-free license, unlimited in duration, to use that
+work under the conditions stated herein.  The "Document", below,
+refers to any such manual or work.  Any member of the public is a
+licensee, and is addressed as "you".  You accept the license if you
+copy, modify or distribute the work in a way requiring permission
+under copyright law.
+
+A "Modified Version" of the Document means any work containing the
+Document or a portion of it, either copied verbatim, or with
+modifications and/or translated into another language.
+
+A "Secondary Section" is a named appendix or a front-matter section of
+the Document that deals exclusively with the relationship of the
+publishers or authors of the Document to the Document's overall subject
+(or to related matters) and contains nothing that could fall directly
+within that overall subject.  (Thus, if the Document is in part a
+textbook of mathematics, a Secondary Section may not explain any
+mathematics.)  The relationship could be a matter of historical
+connection with the subject or with related matters, or of legal,
+commercial, philosophical, ethical or political position regarding
+them.
+
+The "Invariant Sections" are certain Secondary Sections whose titles
+are designated, as being those of Invariant Sections, in the notice
+that says that the Document is released under this License.  If a
+section does not fit the above definition of Secondary then it is not
+allowed to be designated as Invariant.  The Document may contain zero
+Invariant Sections.  If the Document does not identify any Invariant
+Sections then there are none.
+
+The "Cover Texts" are certain short passages of text that are listed,
+as Front-Cover Texts or Back-Cover Texts, in the notice that says that
+the Document is released under this License.  A Front-Cover Text may
+be at most 5 words, and a Back-Cover Text may be at most 25 words.
+
+A "Transparent" copy of the Document means a machine-readable copy,
+represented in a format whose specification is available to the
+general public, that is suitable for revising the document
+straightforwardly with generic text editors or (for images composed of
+pixels) generic paint programs or (for drawings) some widely available
+drawing editor, and that is suitable for input to text formatters or
+for automatic translation to a variety of formats suitable for input
+to text formatters.  A copy made in an otherwise Transparent file
+format whose markup, or absence of markup, has been arranged to thwart
+or discourage subsequent modification by readers is not Transparent.
+An image format is not Transparent if used for any substantial amount
+of text.  A copy that is not "Transparent" is called "Opaque".
+
+Examples of suitable formats for Transparent copies include plain
+ASCII without markup, Texinfo input format, LaTeX input format, SGML
+or XML using a publicly available DTD, and standard-conforming simple
+HTML, PostScript or PDF designed for human modification.  Examples of
+transparent image formats include PNG, XCF and JPG.  Opaque formats
+include proprietary formats that can be read and edited only by
+proprietary word processors, SGML or XML for which the DTD and/or
+processing tools are not generally available, and the
+machine-generated HTML, PostScript or PDF produced by some word
+processors for output purposes only.
+
+The "Title Page" means, for a printed book, the title page itself,
+plus such following pages as are needed to hold, legibly, the material
+this License requires to appear in the title page.  For works in
+formats which do not have any title page as such, "Title Page" means
+the text near the most prominent appearance of the work's title,
+preceding the beginning of the body of the text.
+
+A section "Entitled XYZ" means a named subunit of the Document whose
+title either is precisely XYZ or contains XYZ in parentheses following
+text that translates XYZ in another language.  (Here XYZ stands for a
+specific section name mentioned below, such as "Acknowledgements",
+"Dedications", "Endorsements", or "History".)  To "Preserve the Title"
+of such a section when you modify the Document means that it remains a
+section "Entitled XYZ" according to this definition.
+
+The Document may include Warranty Disclaimers next to the notice which
+states that this License applies to the Document.  These Warranty
+Disclaimers are considered to be included by reference in this
+License, but only as regards disclaiming warranties: any other
+implication that these Warranty Disclaimers may have is void and has
+no effect on the meaning of this License.
+
+
+2. VERBATIM COPYING
+
+You may copy and distribute the Document in any medium, either
+commercially or noncommercially, provided that this License, the
+copyright notices, and the license notice saying this License applies
+to the Document are reproduced in all copies, and that you add no other
+conditions whatsoever to those of this License.  You may not use
+technical measures to obstruct or control the reading or further
+copying of the copies you make or distribute.  However, you may accept
+compensation in exchange for copies.  If you distribute a large enough
+number of copies you must also follow the conditions in section 3.
+
+You may also lend copies, under the same conditions stated above, and
+you may publicly display copies.
+
+
+3. COPYING IN QUANTITY
+
+If you publish printed copies (or copies in media that commonly have
+printed covers) of the Document, numbering more than 100, and the
+Document's license notice requires Cover Texts, you must enclose the
+copies in covers that carry, clearly and legibly, all these Cover
+Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
+the back cover.  Both covers must also clearly and legibly identify
+you as the publisher of these copies.  The front cover must present
+the full title with all words of the title equally prominent and
+visible.  You may add other material on the covers in addition.
+Copying with changes limited to the covers, as long as they preserve
+the title of the Document and satisfy these conditions, can be treated
+as verbatim copying in other respects.
+
+If the required texts for either cover are too voluminous to fit
+legibly, you should put the first ones listed (as many as fit
+reasonably) on the actual cover, and continue the rest onto adjacent
+pages.
+
+If you publish or distribute Opaque copies of the Document numbering
+more than 100, you must either include a machine-readable Transparent
+copy along with each Opaque copy, or state in or with each Opaque copy
+a computer-network location from which the general network-using
+public has access to download using public-standard network protocols
+a complete Transparent copy of the Document, free of added material.
+If you use the latter option, you must take reasonably prudent steps,
+when you begin distribution of Opaque copies in quantity, to ensure
+that this Transparent copy will remain thus accessible at the stated
+location until at least one year after the last time you distribute an
+Opaque copy (directly or through your agents or retailers) of that
+edition to the public.
+
+It is requested, but not required, that you contact the authors of the
+Document well before redistributing any large number of copies, to give
+them a chance to provide you with an updated version of the Document.
+
+
+4. MODIFICATIONS
+
+You may copy and distribute a Modified Version of the Document under
+the conditions of sections 2 and 3 above, provided that you release
+the Modified Version under precisely this License, with the Modified
+Version filling the role of the Document, thus licensing distribution
+and modification of the Modified Version to whoever possesses a copy
+of it.  In addition, you must do these things in the Modified Version:
+
+A. Use in the Title Page (and on the covers, if any) a title distinct
+   from that of the Document, and from those of previous versions
+   (which should, if there were any, be listed in the History section
+   of the Document).  You may use the same title as a previous version
+   if the original publisher of that version gives permission.
+B. List on the Title Page, as authors, one or more persons or entities
+   responsible for authorship of the modifications in the Modified
+   Version, together with at least five of the principal authors of the
+   Document (all of its principal authors, if it has fewer than five),
+   unless they release you from this requirement.
+C. State on the Title page the name of the publisher of the
+   Modified Version, as the publisher.
+D. Preserve all the copyright notices of the Document.
+E. Add an appropriate copyright notice for your modifications
+   adjacent to the other copyright notices.
+F. Include, immediately after the copyright notices, a license notice
+   giving the public permission to use the Modified Version under the
+   terms of this License, in the form shown in the Addendum below.
+G. Preserve in that license notice the full lists of Invariant Sections
+   and required Cover Texts given in the Document's license notice.
+H. Include an unaltered copy of this License.
+I. Preserve the section Entitled "History", Preserve its Title, and add
+   to it an item stating at least the title, year, new authors, and
+   publisher of the Modified Version as given on the Title Page.  If
+   there is no section Entitled "History" in the Document, create one
+   stating the title, year, authors, and publisher of the Document as
+   given on its Title Page, then add an item describing the Modified
+   Version as stated in the previous sentence.
+J. Preserve the network location, if any, given in the Document for
+   public access to a Transparent copy of the Document, and likewise
+   the network locations given in the Document for previous versions
+   it was based on.  These may be placed in the "History" section.
+   You may omit a network location for a work that was published at
+   least four years before the Document itself, or if the original
+   publisher of the version it refers to gives permission.
+K. For any section Entitled "Acknowledgements" or "Dedications",
+   Preserve the Title of the section, and preserve in the section all
+   the substance and tone of each of the contributor acknowledgements
+   and/or dedications given therein.
+L. Preserve all the Invariant Sections of the Document,
+   unaltered in their text and in their titles.  Section numbers
+   or the equivalent are not considered part of the section titles.
+M. Delete any section Entitled "Endorsements".  Such a section
+   may not be included in the Modified Version.
+N. Do not retitle any existing section to be Entitled "Endorsements"
+   or to conflict in title with any Invariant Section.
+O. Preserve any Warranty Disclaimers.
+
+If the Modified Version includes new front-matter sections or
+appendices that qualify as Secondary Sections and contain no material
+copied from the Document, you may at your option designate some or all
+of these sections as invariant.  To do this, add their titles to the
+list of Invariant Sections in the Modified Version's license notice.
+These titles must be distinct from any other section titles.
+
+You may add a section Entitled "Endorsements", provided it contains
+nothing but endorsements of your Modified Version by various
+parties--for example, statements of peer review or that the text has
+been approved by an organization as the authoritative definition of a
+standard.
+
+You may add a passage of up to five words as a Front-Cover Text, and a
+passage of up to 25 words as a Back-Cover Text, to the end of the list
+of Cover Texts in the Modified Version.  Only one passage of
+Front-Cover Text and one of Back-Cover Text may be added by (or
+through arrangements made by) any one entity.  If the Document already
+includes a cover text for the same cover, previously added by you or
+by arrangement made by the same entity you are acting on behalf of,
+you may not add another; but you may replace the old one, on explicit
+permission from the previous publisher that added the old one.
+
+The author(s) and publisher(s) of the Document do not by this License
+give permission to use their names for publicity for or to assert or
+imply endorsement of any Modified Version.
+
+
+5. COMBINING DOCUMENTS
+
+You may combine the Document with other documents released under this
+License, under the terms defined in section 4 above for modified
+versions, provided that you include in the combination all of the
+Invariant Sections of all of the original documents, unmodified, and
+list them all as Invariant Sections of your combined work in its
+license notice, and that you preserve all their Warranty Disclaimers.
+
+The combined work need only contain one copy of this License, and
+multiple identical Invariant Sections may be replaced with a single
+copy.  If there are multiple Invariant Sections with the same name but
+different contents, make the title of each such section unique by
+adding at the end of it, in parentheses, the name of the original
+author or publisher of that section if known, or else a unique number.
+Make the same adjustment to the section titles in the list of
+Invariant Sections in the license notice of the combined work.
+
+In the combination, you must combine any sections Entitled "History"
+in the various original documents, forming one section Entitled
+"History"; likewise combine any sections Entitled "Acknowledgements",
+and any sections Entitled "Dedications".  You must delete all sections
+Entitled "Endorsements".
+
+
+6. COLLECTIONS OF DOCUMENTS
+
+You may make a collection consisting of the Document and other documents
+released under this License, and replace the individual copies of this
+License in the various documents with a single copy that is included in
+the collection, provided that you follow the rules of this License for
+verbatim copying of each of the documents in all other respects.
+
+You may extract a single document from such a collection, and distribute
+it individually under this License, provided you insert a copy of this
+License into the extracted document, and follow this License in all
+other respects regarding verbatim copying of that document.
+
+
+7. AGGREGATION WITH INDEPENDENT WORKS
+
+A compilation of the Document or its derivatives with other separate
+and independent documents or works, in or on a volume of a storage or
+distribution medium, is called an "aggregate" if the copyright
+resulting from the compilation is not used to limit the legal rights
+of the compilation's users beyond what the individual works permit.
+When the Document is included in an aggregate, this License does not
+apply to the other works in the aggregate which are not themselves
+derivative works of the Document.
+
+If the Cover Text requirement of section 3 is applicable to these
+copies of the Document, then if the Document is less than one half of
+the entire aggregate, the Document's Cover Texts may be placed on
+covers that bracket the Document within the aggregate, or the
+electronic equivalent of covers if the Document is in electronic form.
+Otherwise they must appear on printed covers that bracket the whole
+aggregate.
+
+
+8. TRANSLATION
+
+Translation is considered a kind of modification, so you may
+distribute translations of the Document under the terms of section 4.
+Replacing Invariant Sections with translations requires special
+permission from their copyright holders, but you may include
+translations of some or all Invariant Sections in addition to the
+original versions of these Invariant Sections.  You may include a
+translation of this License, and all the license notices in the
+Document, and any Warranty Disclaimers, provided that you also include
+the original English version of this License and the original versions
+of those notices and disclaimers.  In case of a disagreement between
+the translation and the original version of this License or a notice
+or disclaimer, the original version will prevail.
+
+If a section in the Document is Entitled "Acknowledgements",
+"Dedications", or "History", the requirement (section 4) to Preserve
+its Title (section 1) will typically require changing the actual
+title.
+
+
+9. TERMINATION
+
+You may not copy, modify, sublicense, or distribute the Document except
+as expressly provided for under this License.  Any other attempt to
+copy, modify, sublicense or distribute the Document is void, and will
+automatically terminate your rights under this License.  However,
+parties who have received copies, or rights, from you under this
+License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+
+10. FUTURE REVISIONS OF THIS LICENSE
+
+The Free Software Foundation may publish new, revised versions
+of the GNU Free Documentation License from time to time.  Such new
+versions will be similar in spirit to the present version, but may
+differ in detail to address new problems or concerns.  See
+http://www.gnu.org/copyleft/.
+
+Each version of the License is given a distinguishing version number.
+If the Document specifies that a particular numbered version of this
+License "or any later version" applies to it, you have the option of
+following the terms and conditions either of that specified version or
+of any later version that has been published (not as a draft) by the
+Free Software Foundation.  If the Document does not specify a version
+number of this License, you may choose any version ever published (not
+as a draft) by the Free Software Foundation.
+
+
+ADDENDUM: How to use this License for your documents
+
+To use this License in a document you have written, include a copy of
+the License in the document and put the following copyright and
+license notices just after the title page:
+
+    Copyright (c)  YEAR  YOUR NAME.
+    Permission is granted to copy, distribute and/or modify this document
+    under the terms of the GNU Free Documentation License, Version 1.2
+    or any later version published by the Free Software Foundation;
+    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
+    A copy of the license is included in the section entitled "GNU
+    Free Documentation License".
+
+If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
+replace the "with...Texts." line with this:
+
+    with the Invariant Sections being LIST THEIR TITLES, with the
+    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
+
+If you have Invariant Sections without Cover Texts, or some other
+combination of the three, merge those two alternatives to suit the
+situation.
+
+If your document contains nontrivial examples of program code, we
+recommend releasing these examples in parallel under your choice of
+free software license, such as the GNU General Public License,
+to permit their use in free software.
+
+The End.
diff --git a/MAINTAINERS b/MAINTAINERS
index 3d2b118833..0654f65403 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2514,6 +2514,13 @@ M:	wli@holomorphy.com
 L:	sparclinux@vger.kernel.org
 S:	Maintained
 
+SPEAKUP Console speech output
+P: Kirk Reiser
+M: kirk@braille.uwo.ca
+L: speakup@braille.uwo.ca
+W: http://www.linux-speakup.org
+S: Maintained
+
 SPECIALIX IO8+ MULTIPORT SERIAL CARD DRIVER
 P:	Roger Wolff
 M:	R.E.Wolff@BitWizard.nl
diff --git a/Makefile b/Makefile
index 595ff45168..3dc635700d 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 16
-EXTRAVERSION = .62
+EXTRAVERSION = .62-gentoo
 NAME=Stable Penguin
 
 # *DOCUMENTATION*
diff --git a/arch/alpha/Kconfig b/arch/alpha/Kconfig
index 6044018357..5af6859247 100644
--- a/arch/alpha/Kconfig
+++ b/arch/alpha/Kconfig
@@ -577,6 +577,32 @@ config VERBOSE_MCHECK_ON
 
 	  Take the default (1) unless you want more control or more info.
 
+config ALPHA_UAC_SYSCTL
+	bool "Configure UAC policy via sysctl"
+	depends on SYSCTL
+	default y
+	---help---
+	  Configuring the UAC (unaligned access control) policy on a Linux
+	  system usually involves setting a compile time define. If you say
+	  Y here, you will be able to modify the UAC policy at runtime using
+	  the /proc interface.
+
+	  The UAC policy defines the action Linux should take when an
+	  unaligned memory access occurs. The action can include printing a
+	  warning message (NOPRINT), sending a signal to the offending
+	  program to help developers debug their applications (SIGBUS), or
+	  disabling the transparent fixing (NOFIX).
+
+	  The sysctls will be initialized to the compile-time defined UAC
+	  policy. You can change these manually, or with the sysctl(8)
+	  userspace utility.
+
+	  To disable the warning messages at runtime, you would use
+
+	    echo 1 > /proc/sys/kernel/uac/noprint
+
+	  This is pretty harmless. Say Y if you're not sure.
+
 source "drivers/pci/Kconfig"
 source "drivers/eisa/Kconfig"
 
diff --git a/arch/alpha/kernel/traps.c b/arch/alpha/kernel/traps.c
index f9d12319e0..8e6f79ca1d 100644
--- a/arch/alpha/kernel/traps.c
+++ b/arch/alpha/kernel/traps.c
@@ -15,6 +15,7 @@
 #include <linux/delay.h>
 #include <linux/smp_lock.h>
 #include <linux/module.h>
+#include <linux/sysctl.h>
 #include <linux/init.h>
 #include <linux/kallsyms.h>
 
@@ -103,6 +104,38 @@ static char * ireg_name[] = {"v0", "t0", "t1", "t2", "t3", "t4", "t5", "t6",
 			   "t10", "t11", "ra", "pv", "at", "gp", "sp", "zero"};
 #endif
 
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+static struct ctl_table_header *uac_sysctl_header;
+
+static int enabled_noprint = 0;
+static int enabled_sigbus = 0;
+static int enabled_nofix = 0;
+
+ctl_table uac_table[] = {
+	{KERN_UAC_NOPRINT, "noprint", &enabled_noprint, sizeof (int), 0644, NULL, &proc_dointvec},
+	{KERN_UAC_SIGBUS, "sigbus", &enabled_sigbus, sizeof (int), 0644, NULL, &proc_dointvec},
+	{KERN_UAC_NOFIX, "nofix", &enabled_nofix, sizeof (int), 0644, NULL, &proc_dointvec},
+        {0}
+};
+
+static int __init init_uac_sysctl(void)
+{
+	/* Initialize sysctls with the #defined UAC policy */
+	enabled_noprint = (test_thread_flag (TIF_UAC_NOPRINT)) ? 1 : 0;
+	enabled_sigbus = (test_thread_flag (TIF_UAC_SIGBUS)) ? 1 : 0;
+	enabled_nofix = (test_thread_flag (TIF_UAC_NOFIX)) ? 1 : 0;
+
+	/* save this for later so we can clean up */
+	uac_sysctl_header = register_sysctl_table(uac_table, 0);
+	return 0;
+}
+
+static void __exit exit_uac_sysctl(void)
+{
+	unregister_sysctl_table(uac_sysctl_header);
+}
+#endif
+
 static void
 dik_show_code(unsigned int *pc)
 {
@@ -780,7 +813,11 @@ do_entUnaUser(void __user * va, unsigned long opcode,
 	/* Check the UAC bits to decide what the user wants us to do
 	   with the unaliged access.  */
 
+#ifndef CONFIG_ALPHA_UAC_SYSCTL
 	if (!test_thread_flag (TIF_UAC_NOPRINT)) {
+#else  /* CONFIG_ALPHA_UAC_SYSCTL */
+	if (!(enabled_noprint)) {
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 		if (cnt >= 5 && jiffies - last_time > 5*HZ) {
 			cnt = 0;
 		}
@@ -791,10 +828,18 @@ do_entUnaUser(void __user * va, unsigned long opcode,
 		}
 		last_time = jiffies;
 	}
+#ifndef CONFIG_ALPHA_UAC_SYSCTL
 	if (test_thread_flag (TIF_UAC_SIGBUS))
+#else  /* CONFIG_ALPHA_UAC_SYSCTL */
+	if (enabled_sigbus)
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 		goto give_sigbus;
 	/* Not sure why you'd want to use this, but... */
+#ifndef CONFIG_ALPHA_UAC_SYSCTL
 	if (test_thread_flag (TIF_UAC_NOFIX))
+#else  /* CONFIG_ALPHA_UAC_SYSCTL */
+	if (enabled_nofix)
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 		return;
 
 	/* Don't bother reading ds in the access check since we already
@@ -1089,3 +1134,5 @@ trap_init(void)
 	wrent(entSys, 5);
 	wrent(entDbg, 6);
 }
+
+__initcall(init_uac_sysctl);
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 32ba00bd0a..e96932231b 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -812,6 +812,7 @@ source "drivers/mfd/Kconfig"
 source "drivers/media/Kconfig"
 
 source "drivers/video/Kconfig"
+source "drivers/char/speakup/Kconfig"
 
 source "sound/Kconfig"
 
diff --git a/arch/i386/boot/video.S b/arch/i386/boot/video.S
index 2ac40c8244..51f14dc61a 100644
--- a/arch/i386/boot/video.S
+++ b/arch/i386/boot/video.S
@@ -164,9 +164,11 @@ basret:	ret
 # parameters in the default 80x25 mode -- these are set directly,
 # because some very obscure BIOSes supply insane values.
 mode_params:
+#ifdef CONFIG_FB_VESA_STD
 #ifdef CONFIG_VIDEO_SELECT
 	cmpb	$0, graphic_mode
 	jnz	mopar_gr
+#endif
 #endif
 	movb	$0x03, %ah			# Read cursor position
 	xorb	%bh, %bh
@@ -200,6 +202,7 @@ mopar2: movb	%al, %fs:(PARAM_VIDEO_LINES)
 	ret
 
 #ifdef CONFIG_VIDEO_SELECT
+#ifdef CONFIG_FB_VESA_STD
 # Fetching of VESA frame buffer parameters
 mopar_gr:
 	leaw	modelist+1024, %di
@@ -278,6 +281,7 @@ dac_done:
 	movw	%es, %fs:(PARAM_VESAPM_SEG)
 	movw	%di, %fs:(PARAM_VESAPM_OFF)
 no_pm:	ret
+#endif
 
 # The video mode menu
 mode_menu:
@@ -492,10 +496,12 @@ mode_set:
 	
 	cmpb	$VIDEO_FIRST_V7>>8, %ah
 	jz	setv7
-	
+
+#ifdef CONFIG_FB_VESA_STD
 	cmpb	$VIDEO_FIRST_VESA>>8, %ah
 	jnc	check_vesa
-	
+#endif
+
 	orb	%ah, %ah
 	jz	setmenu
 	
@@ -567,6 +573,7 @@ setr1:	lodsw
 	movw	-4(%si), %ax			# Fetch mode ID
 	jmp	_m_s
 
+#ifdef CONFIG_FB_VESA_STD
 check_vesa:
 	leaw	modelist+1024, %di
 	subb	$VIDEO_FIRST_VESA>>8, %bh
@@ -600,6 +607,7 @@ check_vesa:
 	ret
 
 _setbad:	jmp	setbad          	# Ugly...
+#endif
 
 # Recalculate vertical display end registers -- this fixes various
 # inconsistencies of extended modes on many adapters. Called when
diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile
index 840ae595a6..024c3f9000 100644
--- a/arch/powerpc/boot/Makefile
+++ b/arch/powerpc/boot/Makefile
@@ -20,10 +20,19 @@
 #	CROSS32_COMPILE is setup as a prefix just like CROSS_COMPILE
 #	in the toplevel makefile.
 
+# cc-option-crosscc
+# We can't rely on the host compiler in this situation, so we define
+# a modified cc-option macro for this task.
+# Usage: cflags-y += $(call cc-option-crosscc, -march=winchip-c6, -march=i586)
+
+cc-option-crosscc = $(shell if $(CROSS32CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
+                     > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi ;)
 
 HOSTCC		:= gcc
 BOOTCFLAGS	:= $(HOSTCFLAGS) -fno-builtin -nostdinc -isystem \
-		   $(shell $(CROSS32CC) -print-file-name=include) -fPIC
+		   $(shell $(CROSS32CC) -print-file-name=include) -fPIC \
+		   $(call cc-option-crosscc, -fno-stack-protector) \
+		   $(call cc-option-crosscc, -fno-stack-protector-all)
 BOOTAFLAGS	:= -D__ASSEMBLY__ $(BOOTCFLAGS) -traditional -nostdinc
 OBJCOPYFLAGS    := contents,alloc,load,readonly,data
 OBJCOPY_COFF_ARGS := -O aixcoff-rs6000 --set-start 0x500000
diff --git a/arch/sparc64/Kconfig b/arch/sparc64/Kconfig
index 4c0a50a765..a253a39c3f 100644
--- a/arch/sparc64/Kconfig
+++ b/arch/sparc64/Kconfig
@@ -186,6 +186,12 @@ endchoice
 
 endmenu
 
+config ARCH_SPARSEMEM_ENABLE
+	def_bool y
+
+config ARCH_SPARSEMEM_DEFAULT
+	def_bool y
+
 source "mm/Kconfig"
 
 config GENERIC_ISA_DMA
diff --git a/arch/sparc64/kernel/sparc64_ksyms.c b/arch/sparc64/kernel/sparc64_ksyms.c
index a6fe4f34aa..ef7384fb37 100644
--- a/arch/sparc64/kernel/sparc64_ksyms.c
+++ b/arch/sparc64/kernel/sparc64_ksyms.c
@@ -95,9 +95,6 @@ extern int __ashrdi3(int, int);
 
 extern int dump_fpu (struct pt_regs * regs, elf_fpregset_t * fpregs);
 
-extern unsigned long phys_base;
-extern unsigned long pfn_base;
-
 extern unsigned int sys_call_table[];
 
 extern void xor_vis_2(unsigned long, unsigned long *, unsigned long *);
@@ -342,11 +339,7 @@ EXPORT_SYMBOL(__strncpy_from_user);
 EXPORT_SYMBOL(__bzero_noasi);
 
 /* Various address conversion macros use this. */
-EXPORT_SYMBOL(phys_base);
-EXPORT_SYMBOL(pfn_base);
 EXPORT_SYMBOL(sparc64_valid_addr_bitmap);
-EXPORT_SYMBOL(page_to_pfn);
-EXPORT_SYMBOL(pfn_to_page);
 
 /* No version information on this, heavily used in inline asm,
  * and will always be 'void __ret_efault(void)'.
diff --git a/arch/sparc64/mm/init.c b/arch/sparc64/mm/init.c
index 7d8d7621e1..1a686481be 100644
--- a/arch/sparc64/mm/init.c
+++ b/arch/sparc64/mm/init.c
@@ -111,11 +111,9 @@ static void __init read_obp_memory(const char *property,
 
 unsigned long *sparc64_valid_addr_bitmap __read_mostly;
 
-/* Ugly, but necessary... -DaveM */
-unsigned long phys_base __read_mostly;
+/* Kernel physical address base and size in bytes.  */
 unsigned long kern_base __read_mostly;
 unsigned long kern_size __read_mostly;
-unsigned long pfn_base __read_mostly;
 
 /* get_new_mmu_context() uses "cache + 1".  */
 DEFINE_SPINLOCK(ctx_alloc_lock);
@@ -186,8 +184,8 @@ __inline__ void flush_dcache_page_impl(struct page *page)
 }
 
 #define PG_dcache_dirty		PG_arch_1
-#define PG_dcache_cpu_shift	24
-#define PG_dcache_cpu_mask	(256 - 1)
+#define PG_dcache_cpu_shift	24UL
+#define PG_dcache_cpu_mask	(256UL - 1UL)
 
 #if NR_CPUS > 256
 #error D-cache dirty tracking and thread_info->cpu need fixing for > 256 cpus
@@ -320,16 +318,6 @@ void __kprobes flush_icache_range(unsigned long start, unsigned long end)
 	}
 }
 
-unsigned long page_to_pfn(struct page *page)
-{
-	return (unsigned long) ((page - mem_map) + pfn_base);
-}
-
-struct page *pfn_to_page(unsigned long pfn)
-{
-	return (mem_map + (pfn - pfn_base));
-}
-
 void show_mem(void)
 {
 	printk("Mem-info:\n");
@@ -1196,9 +1184,78 @@ void sparc_ultra_dump_dtlb(void)
 
 extern unsigned long cmdline_memory_size;
 
-unsigned long __init bootmem_init(unsigned long *pages_avail)
+/* Find a free area for the bootmem map, avoiding the kernel image
+ * and the initial ramdisk.
+ */
+static unsigned long __init choose_bootmap_pfn(unsigned long start_pfn,
+					       unsigned long end_pfn)
 {
-	unsigned long bootmap_size, start_pfn, end_pfn;
+	unsigned long avoid_start, avoid_end, bootmap_size;
+	int i;
+
+	bootmap_size = ((end_pfn - start_pfn) + 7) / 8;
+	bootmap_size = ALIGN(bootmap_size, sizeof(long));
+
+	avoid_start = avoid_end = 0;
+#ifdef CONFIG_BLK_DEV_INITRD
+	avoid_start = initrd_start;
+	avoid_end = PAGE_ALIGN(initrd_end);
+#endif
+
+#ifdef CONFIG_DEBUG_BOOTMEM
+	prom_printf("choose_bootmap_pfn: kern[%lx:%lx] avoid[%lx:%lx]\n",
+		    kern_base, PAGE_ALIGN(kern_base + kern_size),
+		    avoid_start, avoid_end);
+#endif
+	for (i = 0; i < pavail_ents; i++) {
+		unsigned long start, end;
+
+		start = pavail[i].phys_addr;
+		end = start + pavail[i].reg_size;
+
+		while (start < end) {
+			if (start >= kern_base &&
+			    start < PAGE_ALIGN(kern_base + kern_size)) {
+				start = PAGE_ALIGN(kern_base + kern_size);
+				continue;
+			}
+			if (start >= avoid_start && start < avoid_end) {
+				start = avoid_end;
+				continue;
+			}
+
+			if ((end - start) < bootmap_size)
+				break;
+
+			if (start < kern_base &&
+			    (start + bootmap_size) > kern_base) {
+				start = PAGE_ALIGN(kern_base + kern_size);
+				continue;
+			}
+
+			if (start < avoid_start &&
+			    (start + bootmap_size) > avoid_start) {
+				start = avoid_end;
+				continue;
+			}
+
+			/* OK, it doesn't overlap anything, use it.  */
+#ifdef CONFIG_DEBUG_BOOTMEM
+			prom_printf("choose_bootmap_pfn: Using %lx [%lx]\n",
+				    start >> PAGE_SHIFT, start);
+#endif
+			return start >> PAGE_SHIFT;
+		}
+	}
+
+	prom_printf("Cannot find free area for bootmap, aborting.\n");
+	prom_halt();
+}
+
+static unsigned long __init bootmem_init(unsigned long *pages_avail,
+					 unsigned long phys_base)
+{
+	unsigned long bootmap_size, end_pfn;
 	unsigned long end_of_phys_memory = 0UL;
 	unsigned long bootmap_pfn, bytes_avail, size;
 	int i;
@@ -1236,14 +1293,6 @@ unsigned long __init bootmem_init(unsigned long *pages_avail)
 
 	*pages_avail = bytes_avail >> PAGE_SHIFT;
 
-	/* Start with page aligned address of last symbol in kernel
-	 * image.  The kernel is hard mapped below PAGE_OFFSET in a
-	 * 4MB locked TLB translation.
-	 */
-	start_pfn = PAGE_ALIGN(kern_base + kern_size) >> PAGE_SHIFT;
-
-	bootmap_pfn = start_pfn;
-
 	end_pfn = end_of_phys_memory >> PAGE_SHIFT;
 
 #ifdef CONFIG_BLK_DEV_INITRD
@@ -1259,23 +1308,22 @@ unsigned long __init bootmem_init(unsigned long *pages_avail)
 		                 	 "(0x%016lx > 0x%016lx)\ndisabling initrd\n",
 			       initrd_end, end_of_phys_memory);
 			initrd_start = 0;
-		}
-		if (initrd_start) {
-			if (initrd_start >= (start_pfn << PAGE_SHIFT) &&
-			    initrd_start < (start_pfn << PAGE_SHIFT) + 2 * PAGE_SIZE)
-				bootmap_pfn = PAGE_ALIGN (initrd_end) >> PAGE_SHIFT;
+			initrd_end = 0;
 		}
 	}
 #endif	
 	/* Initialize the boot-time allocator. */
 	max_pfn = max_low_pfn = end_pfn;
-	min_low_pfn = pfn_base;
+	min_low_pfn = (phys_base >> PAGE_SHIFT);
+
+	bootmap_pfn = choose_bootmap_pfn(min_low_pfn, end_pfn);
 
 #ifdef CONFIG_DEBUG_BOOTMEM
 	prom_printf("init_bootmem(min[%lx], bootmap[%lx], max[%lx])\n",
 		    min_low_pfn, bootmap_pfn, max_low_pfn);
 #endif
-	bootmap_size = init_bootmem_node(NODE_DATA(0), bootmap_pfn, pfn_base, end_pfn);
+	bootmap_size = init_bootmem_node(NODE_DATA(0), bootmap_pfn,
+					 min_low_pfn, end_pfn);
 
 	/* Now register the available physical memory with the
 	 * allocator.
@@ -1323,6 +1371,20 @@ unsigned long __init bootmem_init(unsigned long *pages_avail)
 	reserve_bootmem((bootmap_pfn << PAGE_SHIFT), size);
 	*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;
 
+	for (i = 0; i < pavail_ents; i++) {
+		unsigned long start_pfn, end_pfn;
+
+		start_pfn = pavail[i].phys_addr >> PAGE_SHIFT;
+		end_pfn = (start_pfn + (pavail[i].reg_size >> PAGE_SHIFT));
+#ifdef CONFIG_DEBUG_BOOTMEM
+		prom_printf("memory_present(0, %lx, %lx)\n",
+			    start_pfn, end_pfn);
+#endif
+		memory_present(0, start_pfn, end_pfn);
+	}
+
+	sparse_init();
+
 	return end_pfn;
 }
 
@@ -1447,7 +1509,7 @@ pgd_t swapper_pg_dir[2048];
 
 void __init paging_init(void)
 {
-	unsigned long end_pfn, pages_avail, shift;
+	unsigned long end_pfn, pages_avail, shift, phys_base;
 	unsigned long real_end, i;
 
 	/* Find available physical memory... */
@@ -1457,8 +1519,6 @@ void __init paging_init(void)
 	for (i = 0; i < pavail_ents; i++)
 		phys_base = min(phys_base, pavail[i].phys_addr);
 
-	pfn_base = phys_base >> PAGE_SHIFT;
-
 	kern_base = (prom_boot_mapping_phys_low >> 22UL) << 22UL;
 	kern_size = (unsigned long)&_end - (unsigned long)KERNBASE;
 
@@ -1505,7 +1565,9 @@ void __init paging_init(void)
 
 	/* Setup bootmem... */
 	pages_avail = 0;
-	last_valid_pfn = end_pfn = bootmem_init(&pages_avail);
+	last_valid_pfn = end_pfn = bootmem_init(&pages_avail, phys_base);
+
+	max_mapnr = last_valid_pfn;
 
 #ifdef CONFIG_DEBUG_PAGEALLOC
 	kernel_physical_mapping_init();
@@ -1514,18 +1576,17 @@ void __init paging_init(void)
 	{
 		unsigned long zones_size[MAX_NR_ZONES];
 		unsigned long zholes_size[MAX_NR_ZONES];
-		unsigned long npages;
 		int znum;
 
 		for (znum = 0; znum < MAX_NR_ZONES; znum++)
 			zones_size[znum] = zholes_size[znum] = 0;
 
-		npages = end_pfn - pfn_base;
-		zones_size[ZONE_DMA] = npages;
-		zholes_size[ZONE_DMA] = npages - pages_avail;
+		zones_size[ZONE_DMA] = end_pfn;
+		zholes_size[ZONE_DMA] = end_pfn - pages_avail;
 
 		free_area_init_node(0, &contig_page_data, zones_size,
-				    phys_base >> PAGE_SHIFT, zholes_size);
+				    __pa(PAGE_OFFSET) >> PAGE_SHIFT,
+				    zholes_size);
 	}
 
 	device_scan();
@@ -1595,7 +1656,6 @@ void __init mem_init(void)
 
 	taint_real_pages();
 
-	max_mapnr = last_valid_pfn - pfn_base;
 	high_memory = __va(last_valid_pfn << PAGE_SHIFT);
 
 #ifdef CONFIG_DEBUG_BOOTMEM
diff --git a/arch/sparc64/prom/tree.c b/arch/sparc64/prom/tree.c
index b1ff9e87dc..122c5b81f4 100644
--- a/arch/sparc64/prom/tree.c
+++ b/arch/sparc64/prom/tree.c
@@ -196,6 +196,7 @@ prom_getname (int node, char *buffer, int len)
 {
 	int i, sbus = 0;
 	int pci = 0, ebus = 0, ide = 0;
+	char *name;
 	struct linux_prom_registers *reg;
 	struct linux_prom64_registers reg64[PROMREG_MAX];
 	
@@ -241,6 +242,7 @@ getit:
 		return -1;
 	}
 	buffer [i] = 0;
+	name = buffer;
 	len -= i;
 	i = prom_getproperty (node, "reg", (char *)reg64, sizeof (reg64));
 	if (i <= 0) return 0;
@@ -267,9 +269,15 @@ getit:
 	} else if (i == 4) {	/* Happens on 8042's children on Ultra/PCI. */
 		reg = (struct linux_prom_registers *)reg64;
 		sprintf (buffer, "@%x", reg[0].which_io);
+	} else if (!strcmp(name, "fhc") || !strcmp(name, "counter-timer")) {
+		sprintf(buffer, "@%x,%x",
+			(unsigned int)((reg64[0].phys_addr >> 33) & 0x1f),
+			(unsigned int)(reg64[0].phys_addr));
 	} else {
-		sprintf (buffer, "@%x,%x",
-			 (unsigned int)(reg64[0].phys_addr >> 36),
+		int upaid = prom_getint(node, "upa-portid");
+		if (upaid < 0)
+			upaid = (unsigned int)(reg64[0].phys_addr >> 36);
+		sprintf (buffer, "@%x,%x", upaid,
 			 (unsigned int)(reg64[0].phys_addr));
 	}
 	return 0;
diff --git a/drivers/Kconfig b/drivers/Kconfig
index bddf431bbb..7886e8cd2f 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -58,6 +58,8 @@ source "drivers/media/Kconfig"
 
 source "drivers/video/Kconfig"
 
+source "drivers/char/speakup/Kconfig"
+
 source "sound/Kconfig"
 
 source "drivers/usb/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 5c69b86db6..074a208b61 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -8,6 +8,9 @@
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
+# char/ comes before serial/ etc so that the VT console is the boot-time
+# default.
+obj-y				+= char/
 obj-y				+= video/
 obj-$(CONFIG_ACPI)		+= acpi/
 # PnP must come after ACPI since it will eventually need to check if acpi
@@ -15,10 +18,6 @@ obj-$(CONFIG_ACPI)		+= acpi/
 obj-$(CONFIG_PNP)		+= pnp/
 obj-$(CONFIG_ARM_AMBA)		+= amba/
 
-# char/ comes before serial/ etc so that the VT console is the boot-time
-# default.
-obj-y				+= char/
-
 obj-$(CONFIG_CONNECTOR)		+= connector/
 
 # i810fb and intelfb depend on char/agp/
@@ -30,6 +29,9 @@ obj-$(CONFIG_FB_INTEL)          += video/intelfb/
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-y				+= serial/
 obj-$(CONFIG_PARPORT)		+= parport/
+obj-$(CONFIG_GAMEPORT)		+= input/gameport/
+# load keyboard early so speakup can be quieted
+obj-$(CONFIG_INPUT)		+= input/
 obj-y				+= base/ block/ misc/ mfd/ net/ media/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
@@ -53,8 +55,6 @@ obj-$(CONFIG_TC)		+= tc/
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_PCI)		+= usb/
 obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
-obj-$(CONFIG_GAMEPORT)		+= input/gameport/
-obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_I2C)		+= i2c/
 obj-$(CONFIG_W1)		+= w1/
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 503dd901d4..44838e4034 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_GPIO_VR41XX) += vr41xx_giu.o
 obj-$(CONFIG_TANBAC_TB0219) += tb0219.o
 obj-$(CONFIG_TELCLOCK) += tlclk.o
 
+obj-$(CONFIG_SPEAKUP) += speakup/
 obj-$(CONFIG_WATCHDOG)	+= watchdog/
 obj-$(CONFIG_MWAVE) += mwave/
 obj-$(CONFIG_AGP) += agp/
diff --git a/drivers/char/consolemap.c b/drivers/char/consolemap.c
index c85a4fa60d..f30f7a97f7 100644
--- a/drivers/char/consolemap.c
+++ b/drivers/char/consolemap.c
@@ -668,3 +668,4 @@ console_map_init(void)
 }
 
 EXPORT_SYMBOL(con_copy_unimap);
+EXPORT_SYMBOL(inverse_translate);
diff --git a/drivers/char/keyboard.c b/drivers/char/keyboard.c
index 8b603b2d1c..c0f1a07090 100644
--- a/drivers/char/keyboard.c
+++ b/drivers/char/keyboard.c
@@ -40,6 +40,13 @@
 #include <linux/sysrq.h>
 #include <linux/input.h>
 
+
+#include <linux/speakup.h>
+
+#ifdef CONFIG_SPEAKUP_MODULE
+spk_key_func addr_spk_key = NULL;
+#endif
+
 static void kbd_disconnect(struct input_handle *handle);
 extern void ctrl_alt_del(void);
 
@@ -64,6 +71,10 @@ extern void ctrl_alt_del(void);
 
 #define KBD_DEFLOCK 0
 
+/* Key types processed even in raw modes */
+
+#define TYPES_ALLOWED_IN_RAW_MODE ((1 << KT_SPEC) | (1 << KT_SHIFT) | (1 << KT_SPKUP))
+
 void compute_shiftstate(void);
 
 /*
@@ -79,7 +90,7 @@ void compute_shiftstate(void);
 typedef void (k_handler_fn)(struct vc_data *vc, unsigned char value,
 			    char up_flag, struct pt_regs *regs);
 static k_handler_fn K_HANDLERS;
-static k_handler_fn *k_handler[16] = { K_HANDLERS };
+k_handler_fn *k_handler[16] = { K_HANDLERS };
 
 #define FN_HANDLERS\
 	fn_null,	fn_enter,	fn_show_ptregs,	fn_show_mem,\
@@ -100,15 +111,18 @@ static fn_handler_fn *fn_handler[] = { FN_HANDLERS };
 const int max_vals[] = {
 	255, ARRAY_SIZE(func_table) - 1, ARRAY_SIZE(fn_handler) - 1, NR_PAD - 1,
 	NR_DEAD - 1, 255, 3, NR_SHIFT - 1, 255, NR_ASCII - 1, NR_LOCK - 1,
-	255, NR_LOCK - 1, 255
+	255, NR_LOCK - 1, 255, 255
 };
 
 const int NR_TYPES = ARRAY_SIZE(max_vals);
 
 struct kbd_struct kbd_table[MAX_NR_CONSOLES];
-static struct kbd_struct *kbd = kbd_table;
+struct kbd_struct *kbd = kbd_table;
 static struct kbd_struct kbd0;
 
+EXPORT_SYMBOL(kbd);
+EXPORT_SYMBOL(k_handler);
+
 int spawnpid, spawnsig;
 
 /*
@@ -255,12 +269,14 @@ void kd_mksound(unsigned int hz, unsigned int ticks)
 				}
 			}
 		}
-		if (ticks)
-			mod_timer(&kd_mksound_timer, jiffies + ticks);
+                if (ticks)
+                        mod_timer(&kd_mksound_timer, jiffies + ticks);
 	} else
 		kd_nosound(0);
 }
 
+EXPORT_SYMBOL(kd_mksound);
+
 /*
  * Setting the keyboard rate.
  */
@@ -602,6 +618,7 @@ static void k_spec(struct vc_data *vc, unsigned char value, char up_flag, struct
 	if (up_flag)
 		return;
 	if (value >= ARRAY_SIZE(fn_handler))
+		if (up_flag || (value >= ARRAY_SIZE(fn_handler)))
 		return;
 	if ((kbd->kbdmode == VC_RAW ||
 	     kbd->kbdmode == VC_MEDIUMRAW) &&
@@ -1119,6 +1136,13 @@ static void kbd_keycode(unsigned int keycode, int down,
 	key_map = key_maps[shift_final];
 
 	if (!key_map) {
+#ifdef CONFIG_SPEAKUP
+		if (speakup_key(vc, shift_final, keycode, K(KT_SHIFT,0), !down, regs ))
+			return;
+#elif defined(CONFIG_SPEAKUP_MODULE)
+		if ( addr_spk_key && (*addr_spk_key)(vc, shift_final,
+			keycode, K(KT_SHIFT,0), !down, regs) ) return;
+#endif
 		compute_shiftstate();
 		kbd->slockstate = 0;
 		return;
@@ -1137,8 +1161,15 @@ static void kbd_keycode(unsigned int keycode, int down,
 	}
 
 	type -= 0xf0;
+#ifdef CONFIG_SPEAKUP
+	if (speakup_key(vc, shift_final, keycode, keysym, !down, regs ))
+		return;
+#elif defined(CONFIG_SPEAKUP_MODULE)
+	if ( addr_spk_key && (*addr_spk_key)(vc, shift_final,
+		keycode, keysym, !down, regs) ) return;
+#endif
 
-	if (raw_mode && type != KT_SPEC && type != KT_SHIFT)
+	if (raw_mode && type != KT_SPEC && type != KT_SHIFT )
 		return;
 
 	if (type == KT_LETTER) {
@@ -1149,13 +1180,29 @@ static void kbd_keycode(unsigned int keycode, int down,
 				keysym = key_map[keycode];
 		}
 	}
-
 	(*k_handler[type])(vc, keysym & 0xff, !down, regs);
 
 	if (type != KT_SLOCK)
 		kbd->slockstate = 0;
 }
 
+struct input_dev *fakekeydev=NULL;
+
+/*void kbd_fakekey(unsigned int keycode)
+{
+	if (fakekeydev==NULL)
+		return;
+	kbd_keycode(keycode, 0, HW_RAW(fakekeydev), fakekeydev->regs);
+	kbd_keycode(keycode, 1, HW_RAW(fakekeydev), fakekeydev->regs);
+
+	tasklet_schedule(&keyboard_tasklet);
+	do_poke_blanked_console = 1;
+	schedule_console_callback();
+}
+
+EXPORT_SYMBOL(kbd_fakekey);*/
+EXPORT_SYMBOL(fakekeydev);
+
 static void kbd_event(struct input_handle *handle, unsigned int event_type,
 		      unsigned int event_code, int value)
 {
@@ -1193,6 +1240,7 @@ static struct input_handle *kbd_connect(struct input_handler *handler,
 	memset(handle, 0, sizeof(struct input_handle));
 
 	handle->dev = dev;
+	fakekeydev=dev;
 	handle->handler = handler;
 	handle->name = "kbd";
 
diff --git a/drivers/char/n_tty.c b/drivers/char/n_tty.c
index ccad7ae945..04136117a0 100644
--- a/drivers/char/n_tty.c
+++ b/drivers/char/n_tty.c
@@ -1384,8 +1384,10 @@ do_it_again:
 		 * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,
 		 * we won't get any more characters.
 		 */
-		if (n_tty_chars_in_buffer(tty) <= TTY_THRESHOLD_UNTHROTTLE)
+		if (n_tty_chars_in_buffer(tty) <= TTY_THRESHOLD_UNTHROTTLE) {
+			n_tty_set_room(tty);
 			check_unthrottle(tty);
+		}
 
 		if (b - buf >= minimum)
 			break;
diff --git a/drivers/char/speakup/Config.in b/drivers/char/speakup/Config.in
new file mode 100644
index 0000000000..9b3aa68b47
--- /dev/null
+++ b/drivers/char/speakup/Config.in
@@ -0,0 +1,26 @@
+tristate 'Speakup console speech' CONFIG_SPEAKUP
+if [ "$CONFIG_SPEAKUP" != "n" ]; then
+	comment 'Type "y" for each synthesizer you want built into the kernel.'
+	dep_tristate "Accent SA, acntsa" CONFIG_SPEAKUP_ACNTSA $CONFIG_SPEAKUP
+	dep_tristate "Accent PC, acntpc" CONFIG_SPEAKUP_ACNTPC $CONFIG_SPEAKUP
+	dep_tristate "Apollo, apollo" CONFIG_SPEAKUP_APOLLO $CONFIG_SPEAKUP
+	dep_tristate "Audapter, audptr" CONFIG_SPEAKUP_AUDPTR $CONFIG_SPEAKUP
+	dep_tristate "Braille 'n' Speak, bns" CONFIG_SPEAKUP_BNS $CONFIG_SPEAKUP
+	dep_tristate "DECtalk Express, dectlk" CONFIG_SPEAKUP_DECTLK $CONFIG_SPEAKUP
+	dep_tristate "DECtalk External (old), decext" CONFIG_SPEAKUP_DECEXT $CONFIG_SPEAKUP
+	dep_tristate "DECtalk PC (big ISA card), decpc" CONFIG_SPEAKUP_DECPC $CONFIG_SPEAKUP
+	if [ "$CONFIG_SPEAKUP_DECPC" = "y" ] ;then
+	  comment 'warning: decpc can only be built as a module'
+	fi
+	comment 'In order to use this you will need'
+	comment 'the dtload program and DECPC software files '
+	  comment 'Read the accompanying DECPC documentation for more details'
+	dep_tristate "DoubleTalk PC, dtlk" CONFIG_SPEAKUP_DTLK $CONFIG_SPEAKUP
+	dep_tristate "Keynote Gold PC, keypc" CONFIG_SPEAKUP_KEYPC $CONFIG_SPEAKUP
+	dep_tristate "DoubleTalk LT or LiteTalk, ltlk" CONFIG_SPEAKUP_LTLK $CONFIG_SPEAKUP
+	dep_tristate "Software synthesizers /dev/sftsyn, sftsyn" CONFIG_SPEAKUP_SFTSYN $CONFIG_SPEAKUP
+	dep_tristate "Speak Out, spkout" CONFIG_SPEAKUP_SPKOUT $CONFIG_SPEAKUP
+	dep_tristate "Transport, txprt" CONFIG_SPEAKUP_TXPRT $CONFIG_SPEAKUP
+	comment 'Enter the three to six character synth string from above or none.'
+	string "Default synthesizer for Speakup" CONFIG_SPEAKUP_DEFAULT "none"
+fi
diff --git a/drivers/char/speakup/Kconfig b/drivers/char/speakup/Kconfig
new file mode 100644
index 0000000000..4f39969c18
--- /dev/null
+++ b/drivers/char/speakup/Kconfig
@@ -0,0 +1,210 @@
+menu "Speakup console speech"
+config SPEAKUP
+	tristate "Build speakup console speech"
+	---help---
+
+		This is the Speakup screen reader.  Think of it as a
+		video console for blind people.  If built in to the
+		kernel, it can speak evrything on the text console from
+		boot up to shutdown.  For more information on Speakup,
+		point your browser at http://www.linux-speakup.org/.
+		There is also a mailing list at the above url that you
+		can subscribe to.
+
+		Supported synthesizers are accent sa, accent pc, appollo
+		II., Auddapter, Braille 'n Speak, Dectalk external
+		(old), Dectalk PC (full length isa board), Dectalk
+		express, Doubletalk, Doubletalk LT or Litetalk,
+		Keynote
+		Gold internal PC, software synthesizers, Speakout, and transport.
+
+		Speakup can either be built in or compiled as a module
+		by answering y or m.  If you answer y here, then you
+		must answer either y or m to at least one of the
+		synthesizer drivers below.  If you answer m here, then
+		the synthesizer drivers below can only be built as
+		modules.
+
+		These drivers are not standalone drivers, but must be
+		used in conjunction with Speakup.  Think of them as
+		video cards for blind people.
+
+
+		The Dectalk pc driver can only be built as a module, and
+		requires software to be pre-loaded on to the card before
+		the module can be loaded.  See the decpc choice below
+		for more details.
+
+		If you are not a blind person, or don't have access to
+		one of the listed synthesizers, you should say n.
+
+config SPEAKUP_ACNTSA
+	depends on SPEAKUP
+	tristate "Accent SA, acntsa"
+	---help---
+
+		This is the Speakup driver for the accent sa
+		synthesizer.  You can say y to build it into the kernel,
+		or m to build it as a module.  See the configuration
+		help on the Speakup choice above for more info.
+
+config SPEAKUP_ACNTPC
+	depends on SPEAKUP
+	tristate "Accent PC, acntpc"
+	---help---
+
+		This is the Speakup driver for the accent pc
+		synthesizer.  You can say y to build it into the kernel,
+		or m to build it as a module.  See the configuration
+		help on the Speakup choice above for more info.
+
+config SPEAKUP_APOLLO
+	depends on SPEAKUP
+	tristate "Apollo, apollo"
+	---help---
+
+		This is the Speakup driver for the Apollo II
+		synthesizer.  You can say y to build it into the kernel,
+		or m to build it as a module.  See the configuration
+		help on the Speakup choice above for more info.
+
+config SPEAKUP_AUDPTR
+	depends on SPEAKUP
+	tristate "Audapter, audptr"
+	---help---
+
+		This is the Speakup driver for the Audapter synthesizer.
+		 You can say y to build it into the kernel, or m to
+		build it as a module.  See the configuration help on the
+		Speakup choice above for more info.
+
+config SPEAKUP_BNS
+	depends on SPEAKUP
+	tristate "Braille 'n' Speak, bns"
+	---help---
+
+		This is the Speakup driver for the Braille 'n' Speak
+		synthesizer.  You can say y to build it into the kernel,
+		or m to build it as a module.  See the configuration
+		help on the Speakup choice above for more info.
+
+config SPEAKUP_DECTLK
+	depends on SPEAKUP
+	tristate "DECtalk Express, dectlk"
+	---help---
+
+		This is the Speakup driver for the DecTalk Express
+		synthesizer.  You can say y to build it into the kernel,
+		or m to build it as a module.  See the configuration
+		help on the Speakup choice above for more info.
+
+config SPEAKUP_DECEXT
+	depends on SPEAKUP
+	tristate "DECtalk External (old), decext"
+	---help---
+
+		This is the Speakup driver for the DecTalk External
+		(old) synthesizer.  You can say y to build it into the
+		kernel, or m to build it as a module.  See the
+		configuration help on the Speakup choice above for more
+		info.
+
+config SPEAKUP_DECPC
+	depends on SPEAKUP
+	tristate "DECtalk PC (big ISA card), decpc"
+	---help---
+
+		This is the Speakup driver for the DecTalk PC (full
+		length ISA) synthesizer.  You can say  m to build it as
+		a module.  See the configuration help on the Speakup
+		choice above for more info.
+
+		In order to use the DecTalk PC driver, you must download
+		the dec_pc.tgz file from linux-speakup.org.  It is in
+		the pub/linux/goodies directory.  The dec_pc.tgz file
+		contains the software which must be pre-loaded on to the
+		DecTalk PC board in order to use it with this driver.
+		This driver must be built as a module, and can not be
+		loaded until the file system is mounted and the DecTalk
+		PC software has been pre-loaded on to the board.
+
+		See the README file in the dec_pc.tgz file for more
+		details.
+
+config SPEAKUP_DTLK
+	depends on SPEAKUP
+	tristate "DoubleTalk PC, dtlk"
+	---help---
+
+		This is the Speakup driver for the internal DoubleTalk
+		PC synthesizer.  You can say y to build it into the
+		kernel, or m to build it as a module.  See the
+		configuration help on the Speakup choice above for more
+		info.
+
+config SPEAKUP_KEYPC
+	depends on SPEAKUP
+	tristate "Keynote Gold PC, keypc"
+	---help---
+
+		This is the Speakup driver for the Keynote Gold
+		PC synthesizer.  You can say y to build it into the
+		kernel, or m to build it as a module.  See the
+		configuration help on the Speakup choice above for more
+		info.
+
+config SPEAKUP_LTLK
+	depends on SPEAKUP
+	tristate "DoubleTalk LT or LiteTalk, ltlk"
+---help---
+
+		This is the Speakup driver for the LiteTalk/DoubleTalk
+		LT synthesizer.  You can say y to build it into the
+		kernel, or m to build it as a module.  See the
+		configuration help on the Speakup choice above for more
+		info.
+
+config SPEAKUP_SFTSYN
+	depends on SPEAKUP
+	tristate "Software synthesizers, sftsyn"
+---help---
+
+		This is the software synthesizer device node.  It will
+		register a device /dev/sftsyn which midware programs
+		and speech
+		daemons may open and read to provide kernel output to
+		software synths
+		such as festival, flite, tuxtalk and so forth.  You
+		can select 'y' or
+		'm' to have it built-in to the kernel or loaded as a module.
+
+config SPEAKUP_SPKOUT
+	depends on SPEAKUP
+	tristate "Speak Out, spkout"
+	---help---
+
+		This is the Speakup driver for the Speakout synthesizer.
+		 You can say y to build it into the kernel, or m to
+		build it as a module.  See the configuration help on the
+		Speakup choice above for more info.
+
+config SPEAKUP_TXPRT
+	depends on SPEAKUP
+	tristate "Transport, txprt"
+	---help---
+
+		This is the Speakup driver for the Transport
+		synthesizer.  You can say y to build it into the kernel,
+		or m to build it as a module.  See the configuration
+		help on the Speakup choice above for more info.
+
+if SPEAKUP != n
+	comment 'Enter the 3 to 6 character keyword from the list above, or none for no default synthesizer on boot up.'
+	depends on SPEAKUP
+endif
+
+config SPEAKUP_DEFAULT
+	string "Choose Default synthesizer for Speakup"
+	default "none"
+
+endmenu
diff --git a/drivers/char/speakup/Makefile b/drivers/char/speakup/Makefile
new file mode 100644
index 0000000000..5e89ad6b5b
--- /dev/null
+++ b/drivers/char/speakup/Makefile
@@ -0,0 +1,61 @@
+#
+# Makefile for the speakup speech output system.
+#
+
+V := $(shell awk '/UTS_RELEASE/ {print substr($$3,2,3)}' $(TOPDIR)/include/linux/version.h)
+ifeq ($V,2.4)
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now inherited from the
+# parent makes..
+#
+O_TARGET       := spk.o
+export-objs    := speakup_drvcommon.o speakup.o
+endif
+obj-m = speakup_keyhelp.o
+speakupmain-objs := speakup.o speakup_drvcommon.o
+obj-$(CONFIG_SPEAKUP)	+= speakupmain.o
+obj-$(CONFIG_SPEAKUP_ACNTPC)	+= speakup_acntpc.o
+obj-$(CONFIG_SPEAKUP_ACNTSA)	+= speakup_acntsa.o
+obj-$(CONFIG_SPEAKUP_APOLLO)	+= speakup_apollo.o
+obj-$(CONFIG_SPEAKUP_AUDPTR)	+= speakup_audptr.o
+obj-$(CONFIG_SPEAKUP_BNS)	+= speakup_bns.o
+obj-$(CONFIG_SPEAKUP_DECEXT)	+= speakup_decext.o
+obj-$(CONFIG_SPEAKUP_DECPC)	+= speakup_decpc.o
+obj-$(CONFIG_SPEAKUP_DECTLK)	+= speakup_dectlk.o
+obj-$(CONFIG_SPEAKUP_DTLK)	+= speakup_dtlk.o
+obj-$(CONFIG_SPEAKUP_KEYPC)	+= speakup_keypc.o
+obj-$(CONFIG_SPEAKUP_LTLK)	+= speakup_ltlk.o
+obj-$(CONFIG_SPEAKUP_SFTSYN)	+= speakup_sftsyn.o
+obj-$(CONFIG_SPEAKUP_SPKOUT)	+= speakup_spkout.o
+obj-$(CONFIG_SPEAKUP_TXPRT)	+= speakup_txprt.o
+
+ifeq ($V,2.4)
+	include $(TOPDIR)/Rules.make
+
+speakupmap.h: speakupmap.map genmap
+	./genmap speakupmap.map >$@
+
+genmap: genmap.c mapdata.h
+	cc -o genmap genmap.c
+
+mapdata.h: makemapdata.c keyinfo.h
+	cc -o makemapdata makemapdata.c
+	./makemapdata >mapdata.h
+
+endif
+speakupmain.o:speakup.o speakup_drvcommon.o
+	ld -r -o speakupmain.o speakup.o speakup_drvcommon.o
+
+$(obj)/speakupmap.h: $(src)/speakupmap.map $(src)/genmap
+	$(src)/genmap $(src)/speakupmap.map >$@
+
+$(obj)/mapdata.h: $(src)/keyinfo.h $(src)/makemapdata
+	$(src)/makemapdata >$@
+
+$(obj)/genmap: $(obj)/mapdata.h
+
+HOSTCFLAGS := -Iinclude -I/usr/include
+hostprogs-y := makemapdata genmap
diff --git a/drivers/char/speakup/cvsversion.h b/drivers/char/speakup/cvsversion.h
new file mode 100644
index 0000000000..ab46dc1513
--- /dev/null
+++ b/drivers/char/speakup/cvsversion.h
@@ -0,0 +1 @@
+#define CVSVERSION " CVS: Wed Dec 21 14:36:03 EST 2005 "
diff --git a/drivers/char/speakup/dtload.c b/drivers/char/speakup/dtload.c
new file mode 100644
index 0000000000..37fd9166d7
--- /dev/null
+++ b/drivers/char/speakup/dtload.c
@@ -0,0 +1,554 @@
+/*
+ * This is the DECtalk PC firmware loader for the Linux kernel, version 1.0
+ *
+ * Original 386BSD source:
+ *      Copyright ( c ) 1996 Brian Buhrow <buhrow@lothlorien.nfbcal.org>
+ *
+ * Adapted for Linux:
+ *      Copyright ( c ) 1997 Nicolas Pitre <nico@cam.org>
+ *
+ * Adapted for speakup:
+ *      Copyright ( c ) 2003 David Borowski <david575@golden.net>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * ( at your option ) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <malloc.h>
+#include <sys/errno.h>
+#include <asm/io.h>
+#include "dtload.h"
+#include "dtpc_reg.h"
+
+#define dt_delay(x) usleep(x)
+int verbose = 0, intest = 0,infd = -1;
+int image_len, total_paras;
+int dt_stat, dma_state = 0, has_kernel = 0;
+struct dos_reloc fixups[512];
+char *read_buff = NULL;
+struct dos_exe_header header;
+u_short iobase = 0x350;
+
+static inline int dt_getstatus( )
+{
+  dt_stat =  inb_p( iobase )|(inb_p( iobase+1 )<<8);
+  return dt_stat;
+}
+
+static void dt_sendcmd( u_int cmd )
+{
+  outb_p( cmd & 0xFF, iobase );
+  outb_p( (cmd>>8) & 0xFF, iobase+1 );
+}
+
+static int dt_waitbit( int bit )
+{
+  int timeout = 100;
+  while ( --timeout > 0 ) {
+    if( (dt_getstatus( ) & bit ) == bit ) return 1;
+    usleep( 1000 );
+  }
+  return 0;
+}
+
+static int dt_sendcmd_wait( u_int cmd, int bit )
+{
+  int timeout = 1000;
+  outb_p( cmd & 0xFF, iobase );
+  outb_p( (cmd>>8) & 0xFF, iobase+1 );
+  while ( --timeout > 0 ) {
+    if( (dt_getstatus( ) & bit ) == bit ) return 1;
+    usleep( 1000 );
+  }
+  return 0;
+}
+
+static int dt_waitmode( int pattern )
+{
+  int timeout = 1000;
+  while ( --timeout > 0 ) {
+    if( dt_getstatus( ) == pattern ) return 1;
+    usleep( 1000 );
+  }
+  fprintf( stderr, "waitmode p=%x s = %x\n", pattern, dt_stat );
+  return 0;
+}
+
+static int dt_wait_dma( )
+{
+  int timeout = 1000, state = dma_state;
+  if( !has_kernel ){
+    dt_delay( 500 );
+    return( dt_waitbit( STAT_dma_ready ) );
+  }
+  if( ! dt_waitbit( STAT_dma_ready ) ) return 0;
+  while ( --timeout > 0 ) {
+    if( (dt_getstatus()&STAT_dma_state) == state ) return 1;
+    usleep( 1000 );
+  }
+  dma_state = dt_getstatus( ) & STAT_dma_state;
+  return 1;
+}
+
+dt_ctrl( u_int cmd )
+{
+  while ( ! dt_waitbit( STAT_cmd_ready ) ) dt_delay( 100 );
+  outb_p( 0, iobase+2 );
+  outb_p( 0, iobase+3 );
+  dt_getstatus( );
+  dt_sendcmd( CMD_control|cmd );
+  outb_p( 0, iobase+6 );
+  dt_delay( 100 );
+  dt_sendcmd( CMD_null );
+  while ( ! dt_waitbit( STAT_cmd_ready ) ) dt_delay( 100 );
+}
+
+int dt_flush( void )
+{
+  dt_ctrl( CTRL_flush );
+  dt_waitbit( STAT_dma_ready );
+  outb_p( DMA_sync, iobase+4 );
+  outb_p( 0, iobase+4 );
+  dma_state ^= STAT_dma_state;
+  while( dt_getstatus( ) & STAT_flushing ) dt_delay( 100 );
+  return 0;
+}
+
+static int dt_sendbuff( char *src, int len )
+{
+  while( len-- ){
+    if( ! dt_wait_dma( ) ) return -1;
+    if( ! (dt_getstatus( ) & STAT_rr_char) ) break;
+    outb_p( DMA_single_in, iobase+4 );
+    outb_p( *src++, iobase+4 );
+    dma_state ^= STAT_dma_state;
+  }
+  return 0;
+}
+
+unsigned long dt_allocmem( unsigned long paras )
+{
+	unsigned long addr;
+	if( ! dt_wait_dma( ) ) return 0;
+	outb_p( DMA_control, iobase+4 );
+	outb_p( DT_MEM_ALLOC, iobase+4 );
+	dma_state ^= STAT_dma_state;
+	if( ! dt_wait_dma( ) ) return 0;
+	outb_p( paras & 0xFF, iobase+4 );
+	outb_p( (paras>>8) & 0xFF, iobase+4 );
+	dma_state ^= STAT_dma_state;
+	if( ! dt_wait_dma( ) ) return 0;
+	addr = inb_p( iobase+4 );
+	addr |= (inb_p( iobase+4 )<<8);
+	addr += (inb_p( iobase+4 )<<4);
+	addr += (inb_p( iobase+4 )<<12);
+	dma_state ^= STAT_dma_state;
+  return addr;
+}
+
+static int testkernel( void )
+{
+  dt_sendcmd( CMD_sync );
+  if( ! dt_waitbit( STAT_cmd_ready ) ) return -10;
+  has_kernel = ( dt_stat&0x8000 ) ? 1 : 0;
+  if ( verbose ) printf( "testkernel got %x\n", dt_stat );
+  if ( has_kernel ) return 0;
+	dt_delay( 100 );
+  return 1;
+}
+
+static int dt_loadmem( int addr, int len, char *src )
+{
+  char c;
+  int l;
+  if ( verbose ) printf( "dt_loadmem: addr = %08X size = %d\n", addr, len );
+  do {
+    l = len;
+    if ( l >= 0xc000 ) l = 0xc000;
+    len -= l;
+    if( ! dt_wait_dma( ) ) return -1;
+    outb_p( DMA_control, iobase+4 );
+    outb_p( DT_LOAD_MEM, iobase+4 );
+    dma_state ^= STAT_dma_state;
+    if( ! dt_wait_dma( ) ) return -2;
+    outb_p( addr & 0xFF, iobase+4 );
+    outb_p( (addr>>8) & 0xFF, iobase+4 );
+    outb_p( (addr>>16) & 0xFF, iobase+4 );
+    outb_p( (addr>>24) & 0xFF, iobase+4 );
+    outb_p( l & 0xFF, iobase+4 );
+    outb_p( (l>>8) & 0xFF, iobase+4 );
+    dma_state ^= STAT_dma_state;
+    if( ! dt_wait_dma( ) ) return -3;
+    addr += l;
+    while( l-- ){
+      c = *src++;
+      outb_p( c, iobase+4 );
+    }
+    dma_state ^= STAT_dma_state;
+  } while ( len > 0 );
+  return 0;
+}
+
+unsigned int loadfile ( char *filename )
+{
+  int i, header_size;
+  unsigned int total_paras;
+  long fix;
+  infd = open ( filename, O_RDONLY );
+  if ( infd == -1 ) {
+      perror ( "Opening file: " );
+      return 0;
+    }
+  read ( infd, &header, sizeof ( struct dos_exe_header ) );
+  if ( header.id != 0x5a4d ) {
+      fprintf ( stderr, "Invalid header file format\n" );
+      fprintf ( stderr, "Want 0x5a4d, got 0x%x\n", header.id );
+      return 0;
+    }
+  if ( header.relen > MAX_FIXUPS ) {
+      fprintf ( stderr, "Too many fixups\n" );
+      return 0;
+    }
+  lseek ( infd, ( long ) header.reloc, SEEK_SET );
+  read ( infd, fixups, sizeof ( struct dos_reloc ) * header.relen );
+  header_size = header.hsize * 16;
+  lseek ( infd, ( long )header_size, SEEK_SET );
+  image_len = ( ( header.pages-1 )*512 ) + ( header.rem- header_size );
+  total_paras =  ( image_len >> 4 ) + header.hmin + 16;
+  read ( infd, read_buff, image_len );
+  close( infd );
+  return total_paras;
+}
+
+static int loadkernel( char *filename )
+{
+  int segfix = 0x40, fix, i;
+  int ipval, csval;
+  if ( has_kernel ) return 0;
+  if ( !loadfile( filename ) ) return -1;
+  header.csval += segfix;
+  header.ssval += segfix;
+  if ( verbose ) {
+      printf ( "Loading kernel of %ld bytes ( %d relocs )\n",
+	      image_len, header.relen );
+      printf ( "    cs:ip == %04x:%04x   ss:sp == %04x:%04x\n",
+	      header.csval, header.ipval, header.ssval, header.spval );
+    }
+  for ( i = 0; i < header.relen; i++ ) {
+      fix = ( fixups[i].segment << 4 ) + fixups[i].offset;
+      ( *( unsigned int * ) &read_buff[fix] ) += segfix;
+    }
+  csval = header.csval;
+  ipval = header.ipval;
+  dt_sendcmd_wait( MODULE_reset, MODULE_init );
+  dt_sendcmd( CMD_reset );
+  if( dt_getstatus( ) == MODULE_self_test ){
+    if( ! dt_waitmode( MODULE_init ) ) return -1;
+  }
+  if ( !dt_sendcmd_wait( CMD_reset, MODE_status ) ) return -2;
+  if ( !dt_sendcmd_wait( CMD_sync, MODE_error ) ) return -3;
+  if ( !dt_sendcmd_wait( CMD_reset, MODE_status ) ) return -4;
+  if ( verbose ) printf( "card is ready\n" );
+  dt_sendcmd( CMD_dma );
+  if( ! dt_waitbit( STAT_dma_ready ) ) return -5;
+  if( ( i = dt_loadmem( 0x00000400, image_len, read_buff ) ) ) {
+   fprintf( stderr, "kernel load failed, status %d\n", i );
+    return -6;
+  }
+  dt_delay( 100 );
+  /* the kernel is loaded, start it */
+  if ( !dt_sendcmd_wait( CMD_reset, MODE_status ) ) return -7;
+  dt_sendcmd( CMD_dma+1 );   /**xxx**/
+	dt_delay( 100 );
+  if( ! dt_waitbit( STAT_dma_ready ) ) return-8;
+  outb_p( DMA_control, iobase+4 );
+  outb_p( DT_START_TASK, iobase+4 );
+	dt_delay( 100 );
+  outb_p( ipval & 0xFF, iobase+4 );
+  outb_p( (ipval>>8) & 0xFF, iobase+4 );
+  outb_p( csval & 0xFF, iobase+4 );
+  outb_p( (csval>>8) & 0xFF, iobase+4 );
+	if( ! dt_waitmode( 0xc001 ) ) return -9;
+  if ( verbose ) {
+    printf( "done loading kernel\n" );
+  }
+  return testkernel( );
+}
+
+int loaddict ( char *filename, char *name, int type )
+{
+  int i, read_index, read_size, act_size;
+  unsigned short *index_fix, seg_fix;
+  unsigned long entries, index, dic_bytes, dic_addr;
+  unsigned int total_paras;
+  unsigned long param, l;
+  infd = open ( filename, O_RDONLY );
+  if ( infd == -1 ) {
+      perror ( filename );
+      return -1;
+    }
+/* read in the entry count and the actual entry size excluding the
+ * index table ( which is entries * 4 ) ...  */
+  read ( infd, &entries, 4 );
+  read ( infd, &dic_bytes, 4 );
+  if ( verbose )
+    printf ( "Loading %s dictionary of %lu entries, %lu bytes.\n",
+	    name, entries, dic_bytes );
+  total_paras = ( ( ( entries * 4 ) + dic_bytes ) >> 4 ) + 2;
+  if ( verbose )
+    printf ( "Allocating %d paragraphs of free ram ...\n", total_paras );
+  l = dt_allocmem( total_paras );
+  if ( l == 0 ) {
+      perror ( "Error requesting memory from speech device" );
+      return -1;
+    }
+  seg_fix = ( l >> 4 ) & 0xffff;
+  dic_addr = l;
+  index = entries;
+  index_fix = ( unsigned short * ) &read_buff[0];
+  if ( verbose )
+    printf ( "Index table starts at %lx\n", l );
+  read_index = index*4;
+  act_size = read ( infd, read_buff, read_index );
+  if ( act_size != read_index ) {
+    fprintf ( stderr, "\nError reading indexes\n" );
+    fprintf ( stderr, "    exp : %d  act : %d\n", read_index * 4, act_size );
+    return -1;
+  }
+  for ( i = 1; i < index * 2; i += 2 )
+    index_fix[i] += seg_fix;
+  if( ( i = dt_loadmem( l, read_index, read_buff ) ) ) {
+    fprintf ( stderr, "\nError loading indexes at 0x%lX: i %d\n",
+      l, i );
+    return -1;
+  }
+  l += read_index;
+/* now, load up the dictionary bytes ...  */
+  if ( verbose )
+    printf ( "Dictionary text starts at %lx\n", l );
+  read_size = dic_bytes;
+  if ( ( act_size = read ( infd, read_buff, read_size ) ) != read_size ) {
+    fprintf ( stderr, "\nError reading dictionary text!\n" );
+    fprintf ( stderr, "asked : %d  actual : %d\n", act_size, read_size );
+    return -1;
+  }
+  if( ( i = dt_loadmem( l, read_size, read_buff ) ) ) {
+    fprintf ( stderr, "\nError loading dictionary at 0x%lX: status %d\n",
+      l, i );
+    return -1;
+  }
+  if( ! dt_wait_dma( ) ) return -1;
+  outb_p( DMA_control, iobase+4 );
+  outb_p( DT_SET_DIC, iobase+4 );
+	dma_state ^= STAT_dma_state;
+  if( ! dt_wait_dma( ) ) return -1;
+  l  = dic_addr;
+	l = ((l << 12) & 0xFFFF0000) + (l & 0x0000000F);
+  outb_p( l & 0xFF, iobase+4 );
+  outb_p( (l>>8) & 0xFF, iobase+4 );
+  outb_p( (l>>16) & 0xFF, iobase+4 );
+  outb_p( (l>>24) & 0xFF, iobase+4 );
+  l = entries;
+  outb_p( l & 0xFF, iobase+4 );
+  outb_p( (l>>8) & 0xFF, iobase+4 );
+  outb_p( (l>>16) & 0xFF, iobase+4 );
+  outb_p( (l>>24) & 0xFF, iobase+4 );
+	l = type;
+  outb_p( l & 0xFF, iobase+4 );
+  outb_p( (l>>8) & 0xFF, iobase+4 );
+	dma_state ^= STAT_dma_state;
+  close ( infd );
+  if ( verbose ) printf( "dictionary load complete\n" );
+  return 0;
+}
+
+int loadexe ( char *filename )
+{
+  unsigned int load_addr = 0, seg_fix;
+  int i, read_size;
+  int ipval, csval;
+  long fix;
+  unsigned long total_paras;
+  total_paras = loadfile ( filename );
+  if ( total_paras == 0 ) return -1;
+  load_addr = dt_allocmem( total_paras );
+  if ( load_addr == 0 ) {
+    fprintf ( stderr, "Error allocating memory on card: " );
+    return -1;
+  }
+  seg_fix = ( load_addr >> 4 ) & 0xffff;
+  if ( verbose ) {
+      printf ( "Loading %s %ld bytes ( %d relocs )\n",
+	      filename, image_len, header.relen );
+      printf ( "Allocating %ld bytes of free ram at %05x\n",
+	      ( long ) header.hmin * 16, load_addr );
+      printf ( "Total memory taken is %ld bytes\n", ( long ) total_paras * 16 );
+      printf ( "    cs:ip == %04x:%04x   ss:sp == %04x:%04x\n",
+	      header.csval + seg_fix, header.ipval, header.ssval + seg_fix, header.spval );
+    }
+    for ( i = 0; i < header.relen; i++ ) {
+	fix = ( ( long ) fixups[i].segment << 4 ) + ( long ) fixups[i].offset;
+	( *( unsigned int * ) &read_buff[fix] ) += seg_fix;
+    	 }
+  if( ( i = dt_loadmem( load_addr, image_len, read_buff ) ) ) {
+    fprintf ( stderr, "Error loading speech device at 0x%lX: status %d\n",
+      load_addr, i );
+    return -1;
+  }
+  csval = header.csval + seg_fix;
+  ipval = header.ipval;
+  if( ! dt_wait_dma( ) ) return -1;
+  outb_p( DMA_control, iobase+4 );
+  outb_p( DT_START_TASK, iobase+4 );
+	dma_state ^= STAT_dma_state;
+  if( ! dt_wait_dma( ) ) return -1;
+  outb_p( ipval & 0xFF, iobase+4 );
+  outb_p( (ipval>>8) & 0xFF, iobase+4 );
+  outb_p( csval & 0xFF, iobase+4 );
+  outb_p( (csval>>8) & 0xFF, iobase+4 );
+	dma_state ^= STAT_dma_state;
+  return 0;
+}
+
+void release_io( void )
+{
+  ioperm( (long)iobase, 8, 0 );
+  ioperm( (long)0x0080, 1, 0 );
+  if ( read_buff ) free( read_buff );
+}
+
+parseparm( char *parm, char *value )
+{
+  char *cp = parm+strlen( parm );
+  while ( --cp > parm ) if ( *cp > ' ' ) break;
+  cp[1] = '\0';
+  if ( !strcmp( parm, "io" ) ) {
+    long io = strtol( value, 0, 0 );
+    if ( io >= 0x100 && io <= 0x350 ) {
+      iobase = (u_short)io;
+      return;
+    }
+    fprintf( stderr, "invalid io value %s\n", value );
+    exit( 1 );
+  } else if ( !strcmp( parm,"verbose" ) ) {
+    verbose = atoi( value );
+  }
+}
+
+do_test( void )
+{
+  char buffer[512];
+  int len;
+  dma_state = dt_getstatus( ) & STAT_dma_state;
+  while ( fgets( buffer, 510, stdin ) ) {
+    len = strlen( buffer );
+    if ( len == 1 ) dt_flush( );
+    else {
+      if ( buffer[len-1] == '\n' ) buffer[len-1] = '\013';
+      dt_sendbuff( buffer, len );
+    }
+  }
+  *buffer = '\013';
+  dt_sendbuff( buffer, 1 );
+}
+
+int main ( int argc, char **argv )
+{
+  char name[80], *cp;
+  char *dirname = 0, *confname = "dec_pc.conf";
+  char *init_msg = "[:ra 360] dec pc initialized\011";
+  FILE *confile;
+  struct stat statbuf;
+  int maxsize = 0, status = 0;
+  while ( --argc > 0 ) {
+    argv++;
+    if ( !strcmp( *argv, "-v" ) ) verbose = 1;
+    else if ( !strcmp( *argv, "-t" ) ) intest = 1;
+    else dirname = *argv;
+  }
+  if ( !dirname ) dirname = "/usr/local/lib/dec_pc";
+  if ( chdir( dirname ) != 0 ) {
+    fprintf( stderr, "cannot chdir to %s\n", dirname );
+    exit( 1 );
+  }
+  if ( !( confile = fopen( confname, "r" ) ) ) {
+    fprintf( stderr, "could not open %s", confname );
+    exit( 1 );
+  }
+  while ( fgets( name, 80, confile ) ) {
+    cp = strchr( name, '\n' );
+    if ( cp ) *cp = '\0';
+    if ( ( cp = strchr( name, '=' ) ) ) {
+      *cp++ = '\0';
+      parseparm( name, cp );
+      continue;
+    }
+    if ( stat( name, &statbuf ) != 0 ) {
+      fprintf( stderr, "cannot stat %s\n", name );
+      exit( 1 );
+    }
+    if ( statbuf.st_size > maxsize ) maxsize = statbuf.st_size;
+  }
+  rewind( confile );
+  if ( ioperm( (long)0x0080, 1, 1 ) || ioperm( (long)iobase, 8, 1 ) ) {
+    fprintf( stderr, "could not get ioperm\n" );
+    exit( 1 );
+  }
+  atexit( release_io );
+  if ( testkernel( ) == 0 ) {
+    if ( intest ) do_test( );
+    else fprintf( stderr, "kernel already loaded\n" );
+    exit( 0 );
+  }
+  read_buff = malloc(  maxsize );
+  if ( !read_buff ) {
+    fprintf( stderr, "cannot malloc %d bytes\n", maxsize );
+    exit( 1 );
+  }
+  while ( fgets( name, 80, confile ) && !status ) {
+    cp = strchr( name, '\n' );
+    if ( cp ) *cp = '\0';
+    if ( strchr( name, '=' ) ) continue; /* a parameter */
+    if ( !( cp = strchr( name, '.' ) ) ) continue;
+    cp++;
+    if ( !strcmp ( cp, "dic" ) ) {
+      status = loaddict ( name, "primary", PRIMARY_DIC );
+    } else if ( !strcmp ( cp, "dtu" ) ) {
+      status = loaddict ( name, "user", USER_DIC );
+    } else if ( !strcmp ( cp, "dta" ) ) {
+      status = loaddict ( name, "abbreviation file", ABBREV_DIC );
+    } else if ( !strcmp ( cp, "exe" ) ) {
+      status = loadexe ( name );
+    } else if ( !strcmp ( cp, "sys" ) ) {
+      status = loadkernel ( name );
+    }
+  }
+  if ( status ) fprintf( stderr, "status %d\n", status );
+  fclose( confile );
+  if ( status ) exit( status );
+  dt_sendbuff( init_msg, strlen( init_msg ) );
+  sleep( 1 );
+  if ( intest ) do_test( );
+  exit( 0 );
+}
diff --git a/drivers/char/speakup/dtload.h b/drivers/char/speakup/dtload.h
new file mode 100644
index 0000000000..c03e741ff4
--- /dev/null
+++ b/drivers/char/speakup/dtload.h
@@ -0,0 +1,57 @@
+/*
+ * This is the DECtalk PC firmware loader for the Linux kernel, version 1.0
+ *
+ * Original 386BSD source:
+ *      Copyright (c) 1996 Brian Buhrow <buhrow@lothlorien.nfbcal.org>
+ *
+ * Adapted for Linux:
+ *      Copyright (c) 1997 Nicolas Pitre <nico@cam.org>
+ *
+ * Adapted for speakup:
+ *      Copyright (c) 2003 David Borowski <david575@golden.net>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#define	MAX_FIXUPS	512	  	/* maximum fixups per exe */
+/*
+ *  msdos .exe files will look like ...
+ */
+
+struct dos_exe_header {
+	unsigned short id;		/* Linker's signature, must be 0x5a4d */
+	unsigned short rem;		/* length of image mod 512 */
+	unsigned short pages;		/* length of image in pages of 512 bytes */
+	unsigned short relen;		/* number of relocation items */
+	unsigned short hsize;		/* header size in paragraphs of 16 bytes */
+	unsigned short hmin;		/* min # of paragraphs above prog end */
+	unsigned short hmax;
+	unsigned short ssval;
+	unsigned short spval;		/* to be loaded in sp */
+	unsigned short	checksum;
+	unsigned short	ipval;		/* to be loaded in ip */
+	unsigned short	csval;  	/* segment offset to code */
+	unsigned short	reloc;		/* location of relocation items	*/
+	unsigned short	ovrlay;		/* overlay number */
+};
+
+/*  a dos relocation element looks like */
+
+struct dos_reloc {
+	short int offset, segment;
+};
diff --git a/drivers/char/speakup/dtpc_reg.h b/drivers/char/speakup/dtpc_reg.h
new file mode 100644
index 0000000000..ebf867b319
--- /dev/null
+++ b/drivers/char/speakup/dtpc_reg.h
@@ -0,0 +1,132 @@
+/*
+ * This is the DECtalk PC register constants (from DEC's DOS driver)
+ *
+ * Original code:
+ *      Copyright (c) by Digital Equipment Corp.
+ *
+ * 386BSD DECtalk PC driver:
+ *      Copyright (c) 1996 Brian Buhrow <buhrow@lothlorien.nfbcal.org>
+ *
+ * Linux DECtalk PC driver:
+ *      Copyright (c) 1997 Nicolas Pitre <nico@cam.org>
+ *
+ * speakup DECtalk PC driver:
+ *      Copyright (c) 2003 David Borowski <david575@golden.net>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+ *  port interface defs ... used by dtpc.c
+ */
+
+#define	MODULE_init		0x0dec		/* module in boot code */
+#define	MODULE_self_test	0x8800		/* module in self-test */
+#define	MODULE_reset		0xffff		/* reinit the whole module */
+
+#define	MODE_mask		0xf000		/* mode bits in high nibble */
+#define	MODE_null		0x0000
+#define	MODE_test		0x2000		/* in testing mode */
+#define	MODE_status		0x8000
+#define	STAT_int		0x0001		/* running in interrupt mode */
+#define	STAT_tr_char	0x0002		/* character data to transmit */
+#define	STAT_rr_char	0x0004		/* ready to receive char data */
+#define	STAT_cmd_ready	0x0008		/* ready to accept commands */
+#define	STAT_dma_ready	0x0010		/* dma command ready */
+#define	STAT_digitized	0x0020		/* spc in digitized mode */
+#define	STAT_new_index	0x0040		/* new last index ready */
+#define	STAT_new_status	0x0080		/* new status posted */
+#define	STAT_dma_state	0x0100		/* dma state toggle */
+#define	STAT_index_valid	0x0200		/* indexs are valid */
+#define	STAT_flushing	0x0400		/* flush in progress */
+#define	STAT_self_test	0x0800		/* module in self test */
+#define	MODE_ready		0xc000		/* module ready for next phase */
+#define	READY_boot		0x0000
+#define	READY_kernel	0x0001
+#define	MODE_error		0xf000
+
+#define	CMD_mask			0xf000		/* mask for command nibble */
+#define	CMD_null			0x0000		/* post status */
+#define	CMD_control		0x1000		/* hard control command */
+#define	CTRL_mask		0x0F00	/*   mask off control nibble */
+#define	CTRL_data		0x00FF	/*   madk to get data byte */
+#define	CTRL_null		0x0000	/*   null control */
+#define	CTRL_vol_up		0x0100	/*   increase volume */
+#define	CTRL_vol_down		0x0200	/*   decrease volume */
+#define	CTRL_vol_set		0x0300	/*   set volume */
+#define	CTRL_pause		0x0400	/*   pause spc */
+#define	CTRL_resume		0x0500	/*   resume spc clock */
+#define	CTRL_resume_spc		0x0001	/*   resume spc soft pause */
+#define	CTRL_flush		0x0600	/*   flush all buffers */
+#define	CTRL_int_enable	0x0700	/*   enable status change ints */
+#define	CTRL_buff_free		0x0800	/*   buffer remain count */
+#define	CTRL_buff_used		0x0900	/*   buffer in use */
+#define	CTRL_speech		0x0a00	/*   immediate speech change */
+#define		CTRL_SP_voice		0x0001	/*      voice change */
+#define		CTRL_SP_rate		0x0002	/*      rate change */
+#define		CTRL_SP_comma		0x0003	/*      comma pause change */
+#define		CTRL_SP_period		0x0004	/*      period pause change */
+#define		CTRL_SP_rate_delta	0x0005	/*	  delta rate change */
+#define		CTRL_SP_get_param	0x0006	/*      return the desired parameter */
+#define	CTRL_last_index	0x0b00	/*   get last index spoken */
+#define	CTRL_io_priority	0x0c00	/*   change i/o priority */
+#define	CTRL_free_mem		0x0d00	/*   get free paragraphs on module */
+#define	CTRL_get_lang		0x0e00	/*   return bit mask of loaded languages */
+#define	CMD_test			0x2000		/* self-test request */
+#define	TEST_mask		0x0F00	/* isolate test field */
+#define	TEST_null		0x0000	/* no test requested */
+#define	TEST_isa_int		0x0100	/* assert isa irq */
+#define	TEST_echo		0x0200	/* make data in == data out */
+#define	TEST_seg			0x0300	/* set peek/poke segment */
+#define	TEST_off			0x0400	/* set peek/poke offset */
+#define	TEST_peek		0x0500	/* data out == *peek */
+#define	TEST_poke		0x0600	/* *peek == data in */
+#define	TEST_sub_code		0x00FF	/* user defined test sub codes */
+#define	CMD_id			0x3000		/* return software id */
+#define	ID_null			0x0000	/* null id */
+#define	ID_kernel		0x0100	/* kernel code executing */
+#define	ID_boot			0x0200	/* boot code executing */
+#define	CMD_dma			0x4000		/* force a dma start */
+#define	CMD_reset		0x5000		/* reset module status */
+#define	CMD_sync			0x6000		/* kernel sync command */
+#define	CMD_char_in		0x7000		/* single character send */
+#define	CMD_char_out		0x8000		/* single character get */
+#define	CHAR_count_1		0x0100	/*    one char in cmd_low */
+#define	CHAR_count_2		0x0200	/*	the second in data_low */
+#define	CHAR_count_3		0x0300	/*	the third in data_high */
+#define	CMD_spc_mode		0x9000		/* change spc mode */
+#define	CMD_spc_to_text	0x0100	/*   set to text mode */
+#define	CMD_spc_to_digit	0x0200	/*   set to digital mode */
+#define	CMD_spc_rate		0x0400	/*   change spc data rate */
+#define	CMD_error		0xf000		/* severe error */
+
+enum {	PRIMARY_DIC	= 0, USER_DIC, COMMAND_DIC, ABBREV_DIC };
+
+#define	DMA_single_in		0x01
+#define	DMA_single_out		0x02
+#define	DMA_buff_in		0x03
+#define	DMA_buff_out		0x04
+#define	DMA_control		0x05
+#define	DT_MEM_ALLOC		0x03
+#define	DT_SET_DIC		0x04
+#define	DT_START_TASK		0x05
+#define	DT_LOAD_MEM		0x06
+#define	DT_READ_MEM		0x07
+#define	DT_DIGITAL_IN		0x08
+#define	DMA_sync		0x06
+#define	DMA_sync_char		0x07
diff --git a/drivers/char/speakup/genmap.c b/drivers/char/speakup/genmap.c
new file mode 100644
index 0000000000..316a63913c
--- /dev/null
+++ b/drivers/char/speakup/genmap.c
@@ -0,0 +1,204 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <libgen.h>
+#include <string.h>
+#include <linux/version.h>
+#include <ctype.h>
+
+int get_define(void);
+
+#define MAXKEYS 512
+#define MAXKEYVAL 160
+#define HASHSIZE 101
+#define is_shift -3
+#define is_spk -2
+#define is_input -1
+typedef struct st_key_init t_key_init;
+struct st_key_init {
+	char *name;
+	int value, shift;
+};
+typedef struct st_key t_key;
+struct st_key {
+	char *name;
+	t_key *next;
+	int value, shift;
+};
+unsigned char key_data[MAXKEYVAL][16], *kp;
+
+#include "mapdata.h"
+t_key key_table[MAXKEYS];
+t_key *extra_keys = key_table+HASHSIZE;
+char buffer[256], filename[256];
+FILE *infile;
+char delims[] = "\t\n ";
+char *def_name, *def_val, *cp;
+int map_ver = 119; /* an arbitrary number so speakup can check */
+int lc, shift_table[17];
+int max_states = 1, flags = 0;
+/* flags reserved for later, maybe for individual console maps */
+
+void open_input( char *name )
+{
+	strcpy( filename, name );
+	if ( ( infile = fopen( filename, "r" ) ) == 0 ) {
+		fprintf( stderr, "can't open %s, version %d\n", filename, LINUX_VERSION_CODE );
+		exit( 1 );
+	}
+	lc = 0;
+}
+
+int
+oops( char *msg, char *info )
+{
+	if ( info == NULL ) info = " ";
+	fprintf( stderr, "error: file %s line %d\n", filename, lc );
+	fprintf( stderr, "%s %s\n", msg, info );
+	exit( 1 );
+}
+
+t_key *hash_name( char *name )
+{
+	u_char *pn = (u_char *)name;
+	int hash = 0;
+	while ( *pn ) {
+		hash = ( hash * 17 ) & 0xfffffff;
+	if ( isupper( *pn ) ) *pn = tolower( *pn );
+		hash += ( int )*pn;
+		pn++;
+	}
+	hash %= HASHSIZE;
+	return &key_table[hash];
+}
+
+t_key *find_key( char *name )
+{
+	t_key *this = hash_name( name );
+	while ( this ) {
+		if ( !strcmp( name, this->name ) ) return this;
+		this = this->next;
+	}
+	return this;
+}
+
+t_key *add_key( char *name, int value, int shift )
+{
+	t_key *this = hash_name( name );
+	if ( extra_keys-key_table >= MAXKEYS )
+		oops( "out of key table space, enlarge MAXKEYS", NULL );
+	if ( this->name != NULL ) {
+		while ( this->next ) {
+			if ( !strcmp( name, this->name ) )
+				oops( "attempt to add duplicate key", name );
+			this = this->next;
+		}
+		this->next = extra_keys++;
+		this = this->next;
+	}
+	this->name = strdup( name );
+	this->value = value;
+	this->shift = shift;
+	return this;
+}
+
+int get_shift_value( int state )
+{
+	int i;
+	for ( i = 0; shift_table[i] != state; i++ ) {
+		if ( shift_table[i] == -1 ) {
+			if ( i >= 16 )
+				oops( "too many shift states", NULL );
+			shift_table[i] = state;
+			max_states = i+1;
+		break;
+	}
+	}
+	return i;
+}
+
+int
+main( int argc, char *argv[] )
+{
+	int value, shift_state, i, spk_val = 0, lock_val = 0;
+	int max_key_used = 0, num_keys_used = 0;
+	t_key *this;
+	t_key_init *p_init;
+char *argpath, *argname, *argcopy;
+
+	bzero( key_table, sizeof( key_table ) );
+	bzero( key_data, sizeof( key_data ) );
+	shift_table[0] = 0;
+	for ( i = 1; i <= 16; i++ ) shift_table[i] = -1;
+	if ( argc < 2 ) {
+		fputs( "usage: genmap filename\n", stderr );
+		exit( 1 );
+	}
+  for ( p_init = init_key_data; p_init->name[0] != '.'; p_init++ )
+		add_key( p_init->name, p_init->value, p_init->shift );
+	open_input( argv[1] );
+	while ( fgets( buffer, 250, infile ) ) {
+		lc++;
+		value = shift_state = 0;
+		cp = strtok( buffer, delims );
+		if ( *cp == '#' ) continue;
+		while ( cp ) {
+			if ( *cp == '=' ) break;
+			this = find_key( cp );
+			if ( this == NULL )
+				oops( "unknown key/modifier", cp );
+			if ( this->shift == is_shift ) {
+				if ( value )
+					oops( "modifiers must come first", cp );
+				shift_state += this->value;
+			} else if ( this->shift == is_input )
+				value = this->value;
+			else oops( "bad modifier or key", cp );
+			cp = strtok( 0, delims );
+		}
+		if ( !cp ) oops( "no = found", NULL );
+		cp = strtok( 0, delims );
+		if ( !cp ) oops( "no speakup function after =", NULL );
+		this = find_key( cp );
+		if ( this == NULL || this->shift != is_spk )
+			oops( "invalid speakup function", cp );
+		i = get_shift_value( shift_state );
+		if ( key_data[value][i] ) {
+			while ( --cp > buffer )
+				if ( !*cp ) *cp = ' ';
+			oops( "two functions on same key combination", cp );
+		}
+		key_data[value][i] = (char)this->value;
+		if ( value > max_key_used ) max_key_used = value;
+	}
+	fclose( infile );
+	this = find_key( "spk_key" );
+	if ( this ) spk_val = this->value;
+	this = find_key( "spk_lock" );
+	if ( this ) lock_val = this->value;
+	for ( lc = 1; lc <= max_key_used; lc++ ) {
+		kp = key_data[lc];
+		if ( !memcmp( key_data[0], kp, 16 ) ) continue;
+		num_keys_used++;
+		for ( i = 0; i < max_states; i++ ) {
+			if ( kp[i] != spk_val&& kp[i] != lock_val ) continue;
+			shift_state = shift_table[i];
+			if ( ( shift_state&16 ) ) continue;
+			shift_state = get_shift_value( shift_state+16 );
+			kp[shift_state] = kp[i];
+/* fill in so we can process the key up, as spk bit will be set */
+		}
+	}
+	printf( "\t%d, %d, %d,\n\t", map_ver, num_keys_used, max_states );
+	for ( i = 0; i < max_states; i++ )
+		printf( "%d, ", shift_table[i] );
+	printf( "%d,", flags );
+	for ( lc = 1; lc <= max_key_used; lc++ ) {
+		kp = key_data[lc];
+		if ( !memcmp( key_data[0], kp, 16 ) ) continue;
+		printf( "\n\t%d,", lc );
+		for ( i = 0; i < max_states; i++ )
+			printf( " %d,", (unsigned int)kp[i] );
+	}
+	printf( "\n\t0, %d\n", map_ver );
+	exit( 0 );
+}
diff --git a/drivers/char/speakup/keyinfo.h b/drivers/char/speakup/keyinfo.h
new file mode 100644
index 0000000000..6fb3600b95
--- /dev/null
+++ b/drivers/char/speakup/keyinfo.h
@@ -0,0 +1,120 @@
+/* spk_priv.h
+   review functions for the speakup screen review package.
+   originally written by: Kirk Reiser and Andy Berdan.
+
+  extensively modified by David Borowski.
+
+    Copyright (C ) 1998  Kirk Reiser.
+    Copyright (C ) 2003  David Borowski.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option ) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+enum { /* var_ids */
+	VERSION = 0, SYNTH, SILENT, SYNTH_DIRECT,
+	KEYMAP, CHARS,
+	PUNC_SOME, PUNC_MOST, PUNC_ALL,
+	DELIM, REPEATS, EXNUMBER,
+	DELAY, TRIGGER, JIFFY, FULL, /* all timers must be together */
+	BLEEP_TIME, CURSOR_TIME, BELL_POS,
+SAY_CONTROL, SAY_WORD_CTL, NO_INTERRUPT, KEY_ECHO,
+	SPELL_DELAY, PUNC_LEVEL, READING_PUNC,
+	ATTRIB_BLEEP, BLEEPS,
+ RATE, PITCH, VOL, TONE, PUNCT, VOICE, FREQ, LANG,
+	CAPS_START, CAPS_STOP,
+	MAXVARS
+};
+
+#define FIRST_SYNTH_VAR RATE
+/* 0 is reserved for no remap */
+#define SPEAKUP_GOTO 0x01
+#define SPEECH_KILL 0x02
+#define SPEAKUP_QUIET 0x03
+#define SPEAKUP_CUT 0x04
+#define SPEAKUP_PASTE 0x05
+#define SAY_FIRST_CHAR 0x06
+#define SAY_LAST_CHAR 0x07
+#define SAY_CHAR 0x08
+#define SAY_PREV_CHAR 0x09
+#define SAY_NEXT_CHAR 0x0a
+#define SAY_WORD 0x0b
+#define SAY_PREV_WORD 0x0c
+#define SAY_NEXT_WORD 0x0d
+#define SAY_LINE 0x0e
+#define SAY_PREV_LINE 0x0f
+#define SAY_NEXT_LINE 0x10
+#define TOP_EDGE 0x11
+#define BOTTOM_EDGE 0x12
+#define LEFT_EDGE 0x13
+#define RIGHT_EDGE 0x14
+#define SPELL_PHONETIC 0x15
+#define SPELL_WORD 0x16
+#define SAY_SCREEN 0x17
+#define SAY_POSITION 0x18
+#define SAY_ATTRIBUTES 0x19
+#define SPEAKUP_OFF 0x1a
+#define SPEAKUP_PARKED 0x1b
+#define SAY_LINE_INDENT 0x1c
+#define SAY_FROM_TOP 0x1d
+#define SAY_TO_BOTTOM 0x1e
+#define SAY_FROM_LEFT 0x1f
+#define SAY_TO_RIGHT 0x20
+#define SAY_CHAR_NUM 0x21
+#define EDIT_SOME 0x22
+#define EDIT_MOST 0x23
+#define SAY_PHONETIC_CHAR 0x24
+#define EDIT_DELIM 0x25
+#define EDIT_REPEAT 0x26
+#define EDIT_EXNUM 0x27
+#define SET_WIN 0x28
+#define CLEAR_WIN 0x29
+#define ENABLE_WIN 0x2a
+#define SAY_WIN 0x2b
+#define SPK_LOCK 0x2c
+#define SPEAKUP_HELP 0x2d
+#define TOGGLE_CURSORING 0x2e
+#define READ_ALL_DOC 0x2f
+#define SPKUP_MAX_FUNC 0x30 /* one greater than the last func handler */
+
+#define SPK_KEY 0x80
+#define FIRST_EDIT_BITS 0x22
+
+#define FIRST_SET_VAR SPELL_DELAY
+#define VAR_START 0x40 /* increase if adding more than 0x3f functions */
+
+/* keys for setting variables, must be ordered same as the enum for var_ids */
+/* with dec being even and inc being 1 greater */
+#define SPELL_DELAY_DEC VAR_START+0
+#define SPELL_DELAY_INC SPELL_DELAY_DEC+1
+#define PUNC_LEVEL_DEC SPELL_DELAY_DEC+2
+#define PUNC_LEVEL_INC PUNC_LEVEL_DEC+1
+#define READING_PUNC_DEC PUNC_LEVEL_DEC+2
+#define READING_PUNC_INC READING_PUNC_DEC+1
+#define ATTRIB_BLEEP_DEC READING_PUNC_DEC+2
+#define ATTRIB_BLEEP_INC ATTRIB_BLEEP_DEC+1
+#define BLEEPS_DEC ATTRIB_BLEEP_DEC+2
+#define BLEEPS_INC BLEEPS_DEC+1
+#define RATE_DEC BLEEPS_DEC+2
+#define RATE_INC RATE_DEC+1
+#define PITCH_DEC RATE_DEC+2
+#define PITCH_INC PITCH_DEC+1
+#define VOL_DEC PITCH_DEC+2
+#define VOL_INC VOL_DEC+1
+#define TONE_DEC VOL_DEC+2
+#define TONE_INC TONE_DEC+1
+#define PUNCT_DEC TONE_DEC+2
+#define PUNCT_INC PUNCT_DEC+1
+#define VOICE_DEC PUNCT_DEC+2
+#define VOICE_INC VOICE_DEC+1
diff --git a/drivers/char/speakup/makemapdata.c b/drivers/char/speakup/makemapdata.c
new file mode 100644
index 0000000000..4c7a9794c9
--- /dev/null
+++ b/drivers/char/speakup/makemapdata.c
@@ -0,0 +1,156 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <libgen.h>
+#include <string.h>
+#include <linux/version.h>
+#include <ctype.h>
+
+int get_define(void);
+
+#define MAXKEYS 512
+#define MAXKEYVAL 160
+#define HASHSIZE 101
+#define is_shift -3
+#define is_spk -2
+#define is_input -1
+typedef struct st_key t_key;
+struct st_key {
+	char *name;
+	t_key *next;
+	int value, shift;
+};
+
+t_key key_table[MAXKEYS];
+t_key *extra_keys = key_table+HASHSIZE;
+char buffer[256], filename[256];
+FILE *infile;
+char delims[] = "\t\n ";
+char *dir_name, *def_name, *def_val, *cp;
+int lc;
+
+void open_input( char *name )
+{
+	sprintf( filename, "%s/%s", dir_name, name );
+	if ( ( infile = fopen( filename, "r" ) ) == 0 ) {
+		fprintf( stderr, "can't open %s\n", filename );
+		exit( 1 );
+	}
+	lc = 0;
+}
+
+int
+oops( char *msg, char *info )
+{
+	if ( info == NULL ) info = " ";
+	fprintf( stderr, "error: file %s line %d\n", filename, lc );
+	fprintf( stderr, "%s %s\n", msg, info );
+	exit( 1 );
+}
+
+int get_define( )
+{
+	while ( fgets( buffer, 250, infile ) ) {
+		lc++;
+		if ( strncmp( buffer, "#define", 7 ) ) continue;
+		strtok( buffer, delims );
+		def_name = strtok( 0, delims );
+		def_val = strtok( 0, delims );
+		if ( def_val != NULL ) return 1;
+	}
+	fclose( infile );
+	infile = 0;
+	return 0;
+}
+
+t_key *hash_name( char *name )
+{
+	u_char *pn = (u_char *)name;
+	int hash = 0;
+	while ( *pn ) {
+		hash = ( hash * 17 ) & 0xfffffff;
+	if ( isupper( *pn ) ) *pn = tolower( *pn );
+		hash += ( int )*pn;
+		pn++;
+	}
+	hash %= HASHSIZE;
+	return &key_table[hash];
+}
+
+t_key *find_key( char *name )
+{
+	t_key *this = hash_name( name );
+	while ( this ) {
+		if ( !strcmp( name, this->name ) ) return this;
+		this = this->next;
+	}
+	return this;
+}
+
+t_key *add_key( char *name, int value, int shift )
+{
+	t_key *this = hash_name( name );
+	if ( extra_keys-key_table >= MAXKEYS )
+		oops( "out of key table space, enlarge MAXKEYS", NULL );
+	if ( this->name != NULL ) {
+		while ( this->next ) {
+			if ( !strcmp( name, this->name ) )
+				oops( "attempt to add duplicate key", name );
+			this = this->next;
+		}
+		this->next = extra_keys++;
+		this = this->next;
+	}
+	this->name = strdup( name );
+	this->value = value;
+	this->shift = shift;
+	return this;
+}
+
+int
+main( int argc, char *argv[] )
+{
+	int value, i;
+	t_key *this;
+	dir_name = getenv( "TOPDIR" );
+	if ( !dir_name ) dir_name = "/usr/src/linux";
+	bzero( key_table, sizeof( key_table ) );
+	add_key( "shift",	1, is_shift );
+	add_key( "altgr",	2, is_shift );
+	add_key( "ctrl",	4, is_shift );
+	add_key( "alt",	8, is_shift );
+	add_key( "spk", 16, is_shift );
+	add_key( "double", 32, is_shift );
+	open_input( "include/linux/input.h" );
+	while ( get_define( ) ) {
+		if ( strncmp( def_name, "KEY_", 4 ) ) continue;
+		value = atoi( def_val );
+		if ( value > 0 && value < MAXKEYVAL )
+			add_key(  def_name, value, is_input );
+	}
+	open_input( "drivers/char/speakup/keyinfo.h" );
+	while ( get_define( ) ) {
+		if ( strlen( def_val ) > 5 ) {
+			if ( !( cp = strchr( def_val, '+' ) ) ) continue;
+			*cp++ = '\0';
+			this = find_key( def_val );
+			if ( !this || *cp < '0' || *cp > '9' ) continue;
+			value = this->value+atoi( cp );
+		} else if ( !strncmp( def_val, "0x", 2 ) )
+			sscanf( def_val+2, "%x", &value );
+		else if ( *def_val >= '0' && *def_val <= '9' )
+			value = atoi( def_val );
+		else continue;
+		add_key( def_name, value, is_spk );
+	}
+	printf( "t_key_init init_key_data[] = {\n" );
+	for ( i = 0; i < HASHSIZE; i++ ) {
+		this = &key_table[i];
+		if ( !this->name ) continue;
+		do {
+			printf( "\t\"%s\", %d, %d,\n", this->name, this->value, this->shift );
+			this = this->next;
+		} while ( this );
+	}
+	printf( "\t\".\", 0, 0\n};\n" );
+	exit( 0 );
+}
diff --git a/drivers/char/speakup/mod_code.c b/drivers/char/speakup/mod_code.c
new file mode 100644
index 0000000000..8687d1903b
--- /dev/null
+++ b/drivers/char/speakup/mod_code.c
@@ -0,0 +1,22 @@
+/* this code is to modularize a synth specific file, included at the end */
+
+static void __exit mod_synth_exit( void )
+{
+        if ( synth == &MY_SYNTH )
+	  synth_release( );
+	synth_remove( &MY_SYNTH );
+}
+
+static int __init mod_synth_init( void )
+{
+	int status = do_synth_init( &MY_SYNTH );
+	if ( status != 0 ) return status;
+	synth_add( &MY_SYNTH );
+	return 0;
+}
+
+module_init( mod_synth_init );
+module_exit( mod_synth_exit );
+MODULE_AUTHOR("Kirk Reiser <kirk@braille.uwo.ca>");
+MODULE_DESCRIPTION("Synthesizer driver module for speakup for the  synth->long_name");
+MODULE_LICENSE( "GPL" );
diff --git a/drivers/char/speakup/serialio.h b/drivers/char/speakup/serialio.h
new file mode 100644
index 0000000000..7981af99c4
--- /dev/null
+++ b/drivers/char/speakup/serialio.h
@@ -0,0 +1,18 @@
+#ifndef SSPK_SERIAL
+#define SSPK_SERIAL
+
+#include <linux/serial.h>	/* for rs_table, serial constants &
+				   serial_uart_config */
+#include <linux/serial_reg.h>	/* for more serial constants */
+#include <linux/serialP.h>	/* for struct serial_state */
+#include <asm/serial.h>
+
+#define SPK_SERIAL_TIMEOUT 1000000	/* countdown values for serial timeouts */
+#define SPK_XMITR_TIMEOUT 1000000	/* countdown values transmitter/dsr timeouts */
+#define SPK_LO_TTY 0		/* check ttyS0 ... ttyS3 */
+#define SPK_HI_TTY 3
+#define NUM_DISABLE_TIMEOUTS 3	/* # of timeouts permitted before disable */
+#define SPK_TIMEOUT 100			/* buffer timeout in ms */
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
+#endif
diff --git a/drivers/char/speakup/speakup.c b/drivers/char/speakup/speakup.c
new file mode 100644
index 0000000000..8a4aac1fd1
--- /dev/null
+++ b/drivers/char/speakup/speakup.c
@@ -0,0 +1,2722 @@
+/* speakup.c
+   review functions for the speakup screen review package.
+   originally written by: Kirk Reiser and Andy Berdan.
+
+  extensively modified by David Borowski.
+
+    Copyright (C ) 1998  Kirk Reiser.
+    Copyright (C ) 2003  David Borowski.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option ) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#define __KERNEL_SYSCALLS__
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/vt.h>
+#include <linux/tty.h>
+#include <linux/mm.h> /* __get_free_page( ) and friends */
+#include <linux/vt_kern.h>
+#include <linux/ctype.h>
+#include <linux/selection.h>
+#include <asm/uaccess.h> /* copy_from|to|user( ) and others */
+#include <linux/unistd.h>
+
+#include <linux/keyboard.h>	/* for KT_SHIFT */
+#include <linux/kbd_kern.h> /* for vc_kbd_* and friends */
+#include <linux/vt_kern.h>
+#include <linux/input.h>
+#include <linux/kmod.h>
+#include <linux/speakup.h>
+
+#include "cvsversion.h"
+#include "spk_priv.h"
+#include <linux/bootmem.h>	/* for alloc_bootmem */
+
+/* speakup_*_selection */
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <asm/uaccess.h>
+#include <linux/consolemap.h>
+
+#define SPEAKUP_VERSION "Speakup v-2.00" CVSVERSION
+#define MAX_DELAY ( (500 * HZ ) / 1000 )
+#define KEY_MAP_VER 119
+#define MINECHOCHAR SPACE
+
+/* these are globals from the kernel code */
+extern void *kmalloc (size_t, unsigned int );
+extern void kfree (const void * );
+extern struct kbd_struct * kbd;
+extern int fg_console;
+extern short punc_masks[];
+
+static special_func special_handler = NULL;
+special_func help_handler = NULL;
+
+int synth_file_inuse = 0;
+short pitch_shift = 0, synth_flags = 0;
+static char buf[256];
+short attrib_bleep = 0, bleeps = 0,  bleep_time = 1;
+short no_intr = 0, spell_delay = 0;
+short key_echo = 0, cursor_timeout = 120, say_word_ctl = 0;
+short say_ctrl = 0, bell_pos = 0;
+short punc_mask = 0, punc_level = 0, reading_punc = 0;
+char str_caps_start[MAXVARLEN+1] = "\0", str_caps_stop[MAXVARLEN+1] = "\0";
+bits_data punc_info[] = {
+	{ "none", "", 0 },
+	{ "some", "/$%&@", SOME },
+	{ "most", "$%&#()=+*/@^<>|\\", MOST },
+	{ "all", "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", PUNC },
+	{ "delimiters", "", B_WDLM },
+	{ "repeats", "()", CH_RPT },
+	{ "extended numeric", "", B_EXNUM },
+	{ "symbols", "", B_SYM },
+	{ 0, 0 }
+};
+char mark_cut_flag = 0;
+u_short mark_x = 0, mark_y = 0;
+char synth_name[10] = CONFIG_SPEAKUP_DEFAULT;
+#define MAX_KEY 160
+u_char *our_keys[MAX_KEY], *shift_table;
+static u_char key_buf[600];
+static u_char key_defaults[] = {
+#include "speakupmap.h"
+};
+
+// Speakup Cursor Track Variables
+#define MAXCURSORTRACK 2
+static int cursor_track = 1;
+static int prev_cursor_track=1;
+static int read_all_mode=MAXCURSORTRACK+1;
+
+struct tty_struct *tty;
+#define key_handler k_handler
+typedef void (*k_handler_fn)(struct vc_data *vc, unsigned char value,
+                            char up_flag, struct pt_regs *regs);
+#define KBD_PROTO struct vc_data *vc, u_char value, char up_flag, struct pt_regs *regs
+#define KBD_ARGS vc, value, up_flag, regs
+extern k_handler_fn key_handler[16];
+static k_handler_fn do_shift, do_spec, do_latin, do_cursor;
+EXPORT_SYMBOL( help_handler );
+EXPORT_SYMBOL( special_handler );
+EXPORT_SYMBOL( our_keys );
+EXPORT_SYMBOL(synth_name);
+
+static void speakup_date (struct vc_data *vc );
+static void spkup_write (const char *in_buf, int count );
+int set_mask_bits( const char *input, const int which, const int how );
+
+char str_ctl[] = "control-";
+char *colors[] = {
+	"black", "blue", "green", "cyan", "red", "magenta", "yellow", "white",
+	"grey"
+};
+
+char *phonetic[] = {
+	"alpha", "beta", "charley", "delta", "echo", "fox", "gamma", "hotel",
+	"india", "juleiet", "keelo", "leema", "mike", "november", "oscar",
+	"papa",
+	"quebec", "romeo", "seeara", "tango", "uniform", "victer", "wiskey",
+	"x ray", "yankee", "zooloo"
+};
+
+// array of 256 char pointers (one for each ASCII character description )
+// initialized to default_chars and user selectable via /proc/speakup/characters
+char *characters[256];
+
+char *default_chars[256] = {
+	"null", "^a", "^b", "^c", "^d", "^e", "^f", "^g",
+	"^h", "^i", "^j", "^k", "^l", "^m", "^n", "^o",
+	"^p", "^q", "^r", "^s", "^t", "^u", "^v", "^w",
+	"^x", "^y", "^z", NULL, NULL, NULL, NULL, NULL,
+	"space", "bang!", "quote", "number", "dollar", "percent", "and",
+	"tick",
+	"left paren", "right paren", "star", "plus", "comma", "dash", "dot",
+	"slash",
+	"zero", "one", "two", "three", "four", "five", "six", "seven",
+	"eight", "nine",
+	"colon", "semmy", "less", "equals", "greater", "question", "at",
+	"eigh", "b", "c", "d", "e", "f", "g",
+	"h", "i", "j", "k", "l", "m", "n", "o",
+	"p", "q", "r", "s", "t", "u", "v", "w", "x",
+	"y", "zehd", "left bracket", "backslash", "right bracket", "caret",
+	"line",
+	"accent", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, "left brace", "bar", "right brace", "tihlduh",
+	"delta", "see cedilla", "u oomlout", "e acute", /* 128 */
+	"eigh circumflex", "eigh oomlout", "eigh grave", "eigh ring", /* 132 */
+	"see cedilla", "e circumflex", "e oomlout", "e grave", /* 136 */
+	"i oomlout", "i circumflex", "i grave", "eigh oomlout", /* 140 */
+	"eigh ring", "e acute", "eigh e dipthong", "eigh e dipthong", /* 144 */
+	"o circumflex", "o oomlout", "o grave", "u circumflex", /* 148 */
+	"u grave", "y oomlout", "o oomlout", "u oomlout", /* 152 */
+	"cents", "pounds", "yen", "peseta", /* 156 */
+	"florin", "eigh acute", "i acute", "o acute", /* 160 */
+	"u acute", "n tilde", "n tilde", "feminine ordinal", /* 164 */
+	"masculin ordinal", "inverted question", "reversed not", "not", /* 168 */
+	"half", "quarter", "inverted bang", "much less than", /* 172 */
+	"much greater than", "dark shading", "medium shading", /* 176 */
+	"light shading", "verticle line", "left tee", /* 179 */
+	"double left tee", "left double tee", "double top right", /* 182 */
+	"top double right", "double left double tee", /* 185 */
+	"double vertical line", "double top double right", /* 187 */
+	"double bottom double right", "double bottom right", /* 189 */
+	"bottom double right", "top right", "left bottom", /* 191 */
+	"up tee", "tee down", "tee right", "horizontal line", /* 194 */
+	"cross bars", "tee double right", "double tee right", /* 198 */
+	"double left double bottom", "double left double top", /* 201 */
+	"double up double tee", "double tee double down", /* 203 */
+	"double tee double right", "double horizontal line", /* 205 */
+	"double cross bars", "up double tee", "double up tee", /* 207 */
+	"double tee down", "tee double down", /* 210 */
+	"double left bottom", "left double bottom", /* 212 */
+	"double left top", "left double top", /* 214 */
+	"double vertical cross", "double horizontal cross", /* 216 */
+	"bottom right", "left top", "solid square", /* 218 */
+	"solid lower half", "solid left half", "solid right half", /* 221 */
+	"solid upper half", "alpha", "beta", "gamma", /* 224 */
+	"pie", "sigma", "sigma", "mu", /* 228 */
+	"tou", "phigh", "thayta", "ohmega", /* 232 */
+	"delta", "infinity", "phigh", "epsilaun", /* 236 */
+"intersection", "identical to", "plus or minus", "equal grater than", /* 240 */
+	"less than equal", "upper integral", "lower integral", /* 244 */
+		"divided by", "almost equal", "degrees", /* 247 */
+	"centre dot", "bullet", "square root", /* 250 */
+	"power", "squared", "black square", "white space" /* 252 */
+};
+
+u_short spk_chartab[256] = {
+ B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 0-7 */
+ B_CTL, B_CTL, A_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 8-15 */
+ B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /*16-23 */
+ B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 24-31 */
+WDLM, A_PUNC, PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC, /*  !"#$%&' */
+PUNC, PUNC, PUNC, PUNC, A_PUNC, A_PUNC, A_PUNC, PUNC, /* ( )*+, -./ */
+NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM, /* 01234567 */
+NUM, NUM, A_PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC, /* 89:;<=>? */
+PUNC, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* @ABCDEFG */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* HIJKLMNO */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* PQRSTUVW */
+A_CAP, A_CAP, A_CAP, PUNC, PUNC, PUNC, PUNC, PUNC, /* XYZ[\]^_ */
+PUNC, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* `abcdefg */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* hijklmno */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* pqrstuvw */
+ALPHA, ALPHA, ALPHA, PUNC, PUNC, PUNC, PUNC, 0, /* xyz{|}~ */
+B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 128-135 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, /* 136-143 */
+B_CAPSYM, B_CAPSYM, B_SYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 144-151 */
+B_SYM, B_SYM, B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 152-159 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, B_SYM, /* 160-167 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 168-175 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 176-183 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 184-191 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 192-199 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 200-207 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 208-215 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 216-223 */
+B_SYM, B_SYM, B_SYM, B_CAPSYM, B_SYM, B_CAPSYM, B_SYM, B_SYM, /* 224-231 */
+B_SYM, B_CAPSYM, B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 232-239 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 240-247 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM /* 248-255 */
+};
+
+int spk_keydown = 0;
+static u_char spk_lastkey = 0, spk_close_press = 0, keymap_flags = 0;
+static u_char last_keycode = 0, this_speakup_key = 0;
+static u_long last_spk_jiffy = 0;
+
+spk_t *speakup_console[MAX_NR_CONSOLES];
+
+int spk_setup (char *str )
+{
+	int ints[4];
+	str = get_options (str, ARRAY_SIZE (ints ), ints );
+	if (ints[0] > 0 && ints[1] >= 0 )
+		synth_port_forced = ints[1];
+	return 1;
+}
+
+int spk_ser_setup (char *str )
+{
+	int lookup[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
+	int ints[4];
+	str = get_options (str, ARRAY_SIZE (ints ), ints );
+	if (ints[0] > 0 && ints[1] >= 0 )
+		synth_port_forced = lookup[ints[1]];
+	return 1;
+}
+
+int spk_synth_setup (char *str )
+{
+	size_t len = MIN (strlen (str ), 9 );
+	memcpy (synth_name, str, len );
+	synth_name[len] = '\0';
+	return 1;
+}
+
+__setup ("speakup_port=", spk_setup );
+__setup ("speakup_ser=", spk_ser_setup );
+__setup ("speakup_synth=", spk_synth_setup );
+
+char *
+strlwr (char *s )
+{
+	char *p;
+	for (p = s; *p; p++ ) {
+		if (*p >= CAP_A && *p <= CAP_Z ) *p |= 32;
+	}
+	return s;
+}
+
+static void
+bleep (u_short val )
+{
+	static short vals[] = { 350, 370, 392, 414, 440, 466, 491, 523,
+554, 587, 619, 659 };
+	short freq;
+	int time = bleep_time;
+	freq = vals[val%12];
+	if (val > 11 )
+		freq *= (1<<(val/12 ) );
+	kd_mksound (freq, time );
+}
+
+void
+speakup_shut_up (struct vc_data *vc )
+{
+	if (spk_killed ) return;
+	spk_shut_up |= 0x01;
+	spk_parked &= 0xfe;
+	speakup_date (vc );
+	if (synth == NULL ) return;
+	do_flush( );
+}
+
+void
+speech_kill (struct vc_data *vc )
+{
+	char val = synth->is_alive ( );
+	if (val == 0 ) return;
+	/* re-enables synth, if disabled */
+	if (val == 2 || spk_killed ) {	/* dead */
+		spk_shut_up &= ~0x40;
+		synth_write_msg ("Eyem a Lighve!" );
+	} else {
+		synth_write_msg ("You killed speak up!" );
+		spk_shut_up |= 0x40;
+	}
+}
+
+static void
+speakup_off (struct vc_data *vc )
+{
+	if (spk_shut_up & 0x80 ) {
+		spk_shut_up &= 0x7f;
+		synth_write_msg ("hey. That's better!" );
+	} else {
+		spk_shut_up |= 0x80;
+		synth_write_msg ("You turned me off!" );
+	}
+	speakup_date (vc );
+}
+
+static void
+speakup_parked (struct vc_data *vc )
+{
+	if (spk_parked & 0x80 ) {
+		spk_parked = 0;
+		synth_write_msg ("unparked!" );
+	} else {
+		spk_parked |= 0x80;
+		synth_write_msg ("parked!" );
+	}
+}
+
+/* ------ cut and paste ----- */
+/* Don't take this from <ctype.h>: 011-015 on the screen aren't spaces */
+#undef isspace
+#define isspace(c)      ((c) == ' ')
+/* Variables for selection control. */
+struct vc_data *spk_sel_cons;      /* defined in selection.c must not be disallocated */
+static volatile int sel_start = -1;     /* cleared by clear_selection */
+static int sel_end;
+static int sel_buffer_lth;
+static char *sel_buffer;
+
+static unsigned char
+sel_pos(int n)
+{
+	return inverse_translate(spk_sel_cons, screen_glyph(spk_sel_cons, n));
+}
+
+static void
+speakup_clear_selection(void)
+{
+	sel_start = -1;
+}
+
+/* does screen address p correspond to character at LH/RH edge of screen? */
+static inline int atedge(const int p, int size_row)
+{
+	return (!(p % size_row) || !((p + 2) % size_row));
+}
+
+/* constrain v such that v <= u */
+static inline unsigned short limit(const unsigned short v, const unsigned short u)
+{
+        return (v > u) ? u : v;
+}
+
+unsigned short xs, ys, xe, ye; /* our region points */
+
+static int
+speakup_set_selection( struct tty_struct *tty)
+{
+        int new_sel_start, new_sel_end;
+	char *bp, *obp;
+	int i, ps, pe;
+	struct vc_data *vc = vc_cons[fg_console].d;
+
+	xs = limit(xs, vc->vc_cols - 1);
+	ys = limit(ys, vc->vc_rows - 1);
+	xe = limit(xe, vc->vc_cols - 1);
+	ye = limit(ye, vc->vc_rows - 1);
+	ps = ys * vc->vc_size_row + (xs << 1);
+	pe = ye * vc->vc_size_row + (xe << 1);
+
+        if (ps > pe) {   /* make sel_start <= sel_end */
+		int tmp = ps;
+		ps = pe;
+		pe = tmp;
+	}
+
+        if (spk_sel_cons != vc_cons[fg_console].d) {
+	  speakup_clear_selection();
+	  spk_sel_cons = vc_cons[fg_console].d;
+	  printk(KERN_WARNING "Selection: mark console not the same as cut\n");
+	  return -EINVAL;
+        }
+
+	new_sel_start = ps;
+	new_sel_end = pe;
+
+        /* select to end of line if on trailing space */
+        if (new_sel_end > new_sel_start &&
+	    !atedge(new_sel_end, vc->vc_size_row) &&
+	    isspace(sel_pos(new_sel_end))) {
+		for (pe = new_sel_end + 2; ; pe += 2)
+			if (!isspace(sel_pos(pe)) ||
+			    atedge(pe, vc->vc_size_row))
+				break;
+		if (isspace(sel_pos(pe)))
+			new_sel_end = pe;
+        }
+	if ((new_sel_start == sel_start)
+	    && (new_sel_end == sel_end))     /* no action required */
+	      return 0;
+
+        sel_start = new_sel_start;
+        sel_end = new_sel_end;
+        /* Allocate a new buffer before freeing the old one ... */
+        bp = kmalloc((sel_end-sel_start)/2+1, GFP_ATOMIC);
+        if (!bp) {
+		printk(KERN_WARNING "selection: kmalloc() failed\n");
+		speakup_clear_selection();
+		return -ENOMEM;
+        }
+        if (sel_buffer)
+		kfree(sel_buffer);
+        sel_buffer = bp;
+
+        obp = bp;
+        for (i = sel_start; i <= sel_end; i += 2) {
+		*bp = sel_pos(i);
+		if (!isspace(*bp++))
+			obp = bp;
+		if (! ((i + 2) % vc->vc_size_row)) {
+			/* strip trailing blanks from line and add newline,
+			   unless non-space at end of line. */
+			if (obp != bp) {
+				bp = obp;
+				*bp++ = '\r';
+			}
+			obp = bp;
+		}
+        }
+        sel_buffer_lth = bp - sel_buffer;
+        return 0;
+}
+
+static int
+speakup_paste_selection(struct tty_struct *tty)
+{
+  struct vc_data *vc = (struct vc_data *) tty->driver_data;
+  int     pasted = 0, count;
+  DECLARE_WAITQUEUE(wait, current);
+  add_wait_queue(&vc->paste_wait, &wait);
+  while (sel_buffer && sel_buffer_lth > pasted) {
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (test_bit(TTY_THROTTLED, &tty->flags)) {
+      schedule();
+      continue;
+    }
+    count = sel_buffer_lth - pasted;
+    count = MIN(count, tty->receive_room);
+    tty->ldisc.receive_buf(tty, sel_buffer + pasted, 0, count);
+    pasted += count;
+  }
+  remove_wait_queue(&vc->paste_wait, &wait);
+  current->state = TASK_RUNNING;
+  return 0;
+}
+
+static void
+speakup_cut (struct vc_data *vc )
+{
+	static const char err_buf[] = "set selection failed";
+	int ret;
+
+	if (!mark_cut_flag ) {
+		mark_cut_flag = 1;
+		xs = spk_x;
+		ys = spk_y;
+		spk_sel_cons = vc;
+		synth_write_msg ("mark" );
+		return;
+	}
+	xe = (u_short ) spk_x;
+	ye = (u_short )spk_y;
+	mark_cut_flag = 0;
+	synth_write_msg ("cut" );
+
+	speakup_clear_selection( );
+	ret = speakup_set_selection ( tty );
+
+	switch (ret ) {
+	case 0:
+		break; /* no error */
+	case -EFAULT :
+		pr_warn( "%sEFAULT\n", err_buf );
+		break;
+	case -EINVAL :
+		pr_warn( "%sEINVAL\n", err_buf );
+		break;
+	case -ENOMEM :
+		pr_warn( "%sENOMEM\n", err_buf );
+		break;
+	}
+}
+
+static void
+speakup_paste (struct vc_data *vc )
+{
+	if (mark_cut_flag ) {
+		mark_cut_flag = 0;
+		synth_write_msg ("mark, cleared" );
+	} else {
+		synth_write_msg ("paste" );
+		speakup_paste_selection (tty );
+	}
+}
+
+static void
+say_attributes (struct vc_data *vc )
+{
+	int fg= spk_attr&0x0f, bg = spk_attr>>4;
+	if (fg > 8 ) {
+		synth_write_string("bright " );
+		fg -= 8;
+	}
+	synth_write_string(colors[fg] );
+	if (bg > 7 ) {
+		synth_write_string(" on blinking " );
+		bg -= 8;
+	} else
+		synth_write_string(" on " );
+	synth_write_msg(colors[bg] );
+}
+
+static char *blank_msg = "blank";
+static char *edges[] = { "top, ", "bottom, ", "left, ", "right, ", "" };
+enum { edge_top = 1, edge_bottom, edge_left, edge_right, edge_quiet };
+
+static void
+announce_edge (struct vc_data *vc, int msg_id )
+{
+	if (bleeps&1 )
+	bleep (spk_y );
+	if (bleeps&2 )
+		synth_write_msg (edges[msg_id-1] );
+}
+
+static void
+speak_char( u_char ch )
+{
+	char *cp = characters[ ch];
+	synth_buffer_add( SPACE );
+	if (IS_CHAR(ch, B_CAP ) ) {
+		pitch_shift++;
+		synth_write_string(str_caps_start );
+		synth_write_string(cp );
+		synth_write_string(str_caps_stop );
+	} else {
+		if (*cp == '^' ) {
+			synth_write_string(str_ctl );
+			cp++;
+		}
+		synth_write_string(cp );
+	}
+	synth_buffer_add( SPACE );
+}
+
+static void
+say_char (struct vc_data *vc )
+{
+	u_short ch;
+	spk_old_attr = spk_attr;
+	ch = scr_readw ((u_short * ) spk_pos );
+	spk_attr = ((ch & 0xff00 ) >> 8 );
+	if (spk_attr != spk_old_attr ) {
+		if (  attrib_bleep&1 ) bleep (spk_y );
+		if (  attrib_bleep&2 ) say_attributes( vc );
+	}
+	speak_char( ch&0xff );
+}
+
+static void
+say_phonetic_char (struct vc_data *vc )
+{
+	u_short ch;
+	spk_old_attr = spk_attr;
+	ch = scr_readw ((u_short * ) spk_pos );
+	spk_attr = ((ch & 0xff00 ) >> 8 );
+		if ( IS_CHAR(ch, B_ALPHA ) ) {
+		ch &= 0x1f;
+		synth_write_msg(phonetic[--ch] );
+	} else {
+		if ( IS_CHAR(ch, B_NUM ) )
+		synth_write_string( "number " );
+		speak_char( ch );
+	}
+}
+
+static void
+say_prev_char (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	if (spk_x == 0 ) {
+		announce_edge(vc, edge_left );
+		return;
+	}
+	spk_x--;
+	spk_pos -= 2;
+	say_char (vc );
+}
+
+static void
+say_next_char (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	if (spk_x == vc->vc_cols - 1 ) {
+		announce_edge(vc, edge_right );
+		return;
+	}
+	spk_x++;
+	spk_pos += 2;
+	say_char (vc );
+}
+
+/* get_word - will first check to see if the character under the
+   reading cursor is a space and if say_word_ctl is true it will
+   return the word space.  If say_word_ctl is not set it will check to
+   see if there is a word starting on the next position to the right
+   and return that word if it exists.  If it does not exist it will
+   move left to the beginning of any previous word on the line or the
+   beginning off the line whichever comes first.. */
+
+static u_long
+get_word (struct vc_data *vc )
+{
+	u_long cnt = 0, tmpx = spk_x, tmp_pos = spk_pos;
+	char ch;
+	u_short attr_ch;
+	spk_old_attr = spk_attr;
+	ch = (char ) scr_readw ((u_short * ) tmp_pos );
+
+/* decided to take out the sayword if on a space (mis-information */
+	if ( say_word_ctl && ch == SPACE ) {
+		*buf = '\0';
+		synth_write_msg( "space" );
+		return 0;
+	} else if ((tmpx < vc->vc_cols-2 )
+		   && (ch == SPACE || IS_WDLM(ch ))
+		   && ((char) scr_readw ((u_short * ) tmp_pos+1 ) > SPACE)) {
+	  tmp_pos += 2;
+	  tmpx++;
+	} else
+	while (tmpx > 0 ) {
+	  if (((ch = (char ) scr_readw ((u_short * ) tmp_pos-1 )) == SPACE
+	       || IS_WDLM(ch ))
+	      && ((char) scr_readw ((u_short * ) tmp_pos ) > SPACE))
+	    break;
+	  tmp_pos -= 2;
+	  tmpx--;
+	}
+	attr_ch = scr_readw ((u_short * ) tmp_pos );
+	spk_attr = attr_ch >> 8;
+	buf[cnt++] = attr_ch&0xff;
+	while (tmpx < vc->vc_cols-1 ) {
+	  tmp_pos += 2;
+	  tmpx++;
+	  ch = (char ) scr_readw ((u_short * ) tmp_pos );
+	  if ((ch == SPACE )
+	      || (IS_WDLM(buf[cnt-1] ) && ( ch > SPACE )))
+	    break;
+	  buf[cnt++] = ch;
+	}
+	buf[cnt] = '\0';
+	return cnt;
+}
+
+static void
+say_word (struct vc_data *vc )
+{
+	u_long cnt = get_word(vc );
+	u_short saved_punc_mask = punc_mask;
+	if ( cnt == 0 ) return;
+	punc_mask = PUNC;
+	buf[cnt++] = SPACE;
+	spkup_write (buf, cnt );
+	punc_mask = saved_punc_mask;
+}
+
+static void
+say_prev_word (struct vc_data *vc )
+{
+	char ch;
+	u_short edge_said = 0, last_state = 0, state = 0;
+	spk_parked |= 0x01;
+	if (spk_x == 0 ) {
+		if ( spk_y == 0 ) {
+			announce_edge(vc, edge_top );
+			return;
+		}
+		spk_y--;
+		spk_x = vc->vc_cols;
+		edge_said = edge_quiet;
+	}
+	while ( 1 ) {
+		if (spk_x == 0 ) {
+			if (spk_y == 0 ) {
+				edge_said = edge_top;
+				break;
+			}
+			if ( edge_said != edge_quiet ) edge_said = edge_left;
+			if ( state > 0 ) break;
+			spk_y--;
+			spk_x = vc->vc_cols-1;
+		} else spk_x--;
+			spk_pos -= 2;
+		ch = (char ) scr_readw ((u_short * ) spk_pos );
+		if ( ch == SPACE ) state = 0;
+		else if (IS_WDLM(ch ) ) state = 1;
+		else state = 2;
+		if (state < last_state ) {
+			spk_pos += 2;
+			spk_x++;
+			break;
+		}
+		last_state = state;
+	}
+	if ( spk_x == 0 && edge_said == edge_quiet )
+		edge_said = edge_left;
+	if ( edge_said > 0 && edge_said < edge_quiet )
+		announce_edge( vc, edge_said );
+	say_word (vc );
+}
+
+static void
+say_next_word (struct vc_data *vc )
+{
+	char ch;
+	u_short edge_said = 0, last_state = 2, state = 0;
+	spk_parked |= 0x01;
+	if ( spk_x == vc->vc_cols - 1 && spk_y == vc->vc_rows-1 ) {
+		announce_edge(vc, edge_bottom );
+		return;
+	}
+	while ( 1 ) {
+		ch = (char ) scr_readw ((u_short * ) spk_pos );
+		if ( ch == SPACE ) state = 0;
+		else if (IS_WDLM(ch ) ) state = 1;
+		else state = 2;
+		if ( state > last_state ) break;
+		if (spk_x >= vc->vc_cols-1 ) {
+			if (spk_y == vc->vc_rows-1 ) {
+				edge_said = edge_bottom;
+				break;
+			}
+			state = 0;
+			spk_y++;
+			spk_x = 0;
+			edge_said = edge_right;
+		} else spk_x++;
+			spk_pos += 2;
+		last_state = state;
+	}
+	if ( edge_said > 0 )
+		announce_edge( vc, edge_said );
+	say_word (vc );
+}
+
+static void
+spell_word (struct vc_data *vc )
+{
+	static char *delay_str[] = { " ", ", ", ". ", ". . ", ". . . " };
+	char *cp = buf, *str_cap= str_caps_stop;
+	char *cp1, *last_cap = str_caps_stop;
+	u_char ch;
+	if ( !get_word(vc ) ) return;
+	while ((ch = (u_char )*cp ) ) {
+		if ( cp != buf )
+			synth_write_string (delay_str[spell_delay] );
+		if (IS_CHAR(ch, B_CAP ) ) {
+			str_cap = str_caps_start;
+			if ( *str_caps_stop ) pitch_shift++;
+		else last_cap = str_caps_stop; /* synth has no pitch */
+		} else str_cap = str_caps_stop;
+		if ( str_cap !=last_cap ) {
+			synth_write_string( str_cap );
+			last_cap = str_cap;
+		}
+		if ( this_speakup_key == SPELL_PHONETIC && ( IS_CHAR( ch, B_ALPHA ) ) ) {
+			ch &= 31;
+			cp1 = phonetic[--ch];
+		} else {
+			cp1 = characters[ch];
+			if (*cp1 == '^' ) {
+				synth_write_string(str_ctl );
+				cp1++;
+			}
+		}
+		synth_write_string(cp1 );
+	cp++;
+	}
+	if ( str_cap != str_caps_stop )
+		synth_write_string( str_caps_stop );
+}
+
+static int
+get_line (struct vc_data *vc )
+{
+	u_long tmp = spk_pos - (spk_x * 2 );
+	int i = 0;
+	spk_old_attr = spk_attr;
+	spk_attr = (u_char ) (scr_readw ((u_short * ) spk_pos ) >> 8 );
+	for (i = 0; i < vc->vc_cols; i++ ) {
+		buf[i] = (u_char ) scr_readw ((u_short * ) tmp );
+		tmp += 2;
+	}
+	for (--i; i >= 0; i-- )
+		if (buf[i] != SPACE ) break;
+	return ++i;
+}
+
+static void
+say_line (struct vc_data *vc )
+{
+	int i = get_line( vc );
+	char *cp;
+	char num_buf[8];
+	u_short saved_punc_mask = punc_mask;
+	if (i == 0 ) {
+		synth_write_msg (blank_msg );
+		return;
+	}
+	buf[i++] = '\n';
+	if ( this_speakup_key == SAY_LINE_INDENT ) {
+		for ( cp = buf; *cp == SPACE; cp++ );
+		sprintf( num_buf, "%d, ", ( cp-buf )+1 );
+		synth_write_string( num_buf );
+	}
+	punc_mask = punc_masks[reading_punc];
+	spkup_write (buf, i );
+	punc_mask = saved_punc_mask;
+}
+
+static void
+say_prev_line (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	if (spk_y == 0 ) {
+		announce_edge (vc, edge_top );
+		return;
+	}
+	spk_y--;
+	spk_pos -= vc->vc_size_row;
+	say_line (vc );
+}
+
+static void
+say_next_line (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	if (spk_y == vc->vc_rows - 1 ) {
+		announce_edge (vc, edge_bottom );
+		return;
+	}
+	spk_y++;
+	spk_pos += vc->vc_size_row;
+	say_line (vc );
+}
+
+static int
+say_from_to (struct vc_data *vc, u_long from, u_long to, int read_punc )
+{
+	int i = 0;
+	u_short saved_punc_mask = punc_mask;
+	spk_old_attr = spk_attr;
+	spk_attr = (u_char ) (scr_readw ((u_short * ) from ) >> 8 );
+	while (from < to ) {
+		buf[i++] = (char ) scr_readw ((u_short * ) from );
+		from += 2;
+		if ( i >= vc->vc_size_row ) break;
+	}
+	for (--i; i >= 0; i-- )
+		if (buf[i] != SPACE ) break;
+	buf[++i] = SPACE;
+	buf[++i] = '\0';
+	if ( i < 1 ) return i;
+	if ( read_punc ) punc_mask = punc_info[reading_punc].mask;
+	spkup_write (buf, i );
+	if ( read_punc ) punc_mask = saved_punc_mask;
+	return i-1;
+}
+
+static void
+say_line_from_to (struct vc_data *vc, u_long from, u_long to, int read_punc )
+{
+	u_long start = vc->vc_origin+(spk_y*vc->vc_size_row );
+	u_long end = start+( to * 2 );
+	start += from*2;
+	if ( say_from_to( vc, start, end, read_punc ) <= 0 )
+		if ( cursor_track != read_all_mode )
+			synth_write_msg (blank_msg );
+}
+
+// Sentence Reading Commands
+
+void synth_insert_next_index( int );
+
+int currsentence;
+int numsentences[2];
+char *sentbufend[2];
+char *sentmarks[2][10];
+int currbuf=0;
+int bn;
+static char sentbuf[2][256];
+
+static int
+say_sentence_num ( int num , int prev )
+{
+	bn=currbuf;
+	currsentence=num+1;
+	if (prev)
+	{
+		bn--;
+		if (bn == -1)
+			bn=1;
+	}
+
+	if (num>numsentences[bn])
+		return 0;
+	spkup_write (sentmarks[bn][num], sentbufend[bn]-sentmarks[bn][num]);
+
+	return 1;
+}
+
+static int
+get_sentence_buf (struct vc_data *vc, int read_punc )
+{
+	u_long start,end;
+	int i,bn;
+	currbuf++;
+	if ( currbuf == 2 )
+		currbuf=0;
+	bn=currbuf;
+	start = vc->vc_origin+((spk_y)*vc->vc_size_row );
+	end = vc->vc_origin+((spk_y)*vc->vc_size_row ) +  vc->vc_cols*2;
+
+	numsentences[bn]=0;
+	sentmarks[bn][0]=&sentbuf[bn][0];
+	i = 0;
+	spk_old_attr = spk_attr;
+	spk_attr = (u_char ) (scr_readw ((u_short * ) start ) >> 8 );
+
+	while (start < end ) {
+		sentbuf[bn][i] = (char ) scr_readw ((u_short * ) start );
+		if (i>0)
+		{
+			if ((sentbuf[bn][i]==SPACE)&&(sentbuf[bn][i-1]=='.')&&(numsentences[bn]<9))
+			{
+				// Sentence Marker
+				numsentences[bn]++;
+				sentmarks[bn][numsentences[bn]]=&sentbuf[bn][i];
+			}
+		}
+		i++;
+		start += 2;
+		if ( i >= vc->vc_size_row )
+			break;
+	}
+
+	for (--i; i >= 0; i-- )
+		if (sentbuf[bn][i] != SPACE )
+			break;
+
+	if ( i < 1 )
+		return -1;
+
+	sentbuf[bn][++i] = SPACE;
+	sentbuf[bn][++i] = '\0';
+
+	sentbufend[bn]=&sentbuf[bn][i];
+	return numsentences[bn];
+}
+
+//
+
+static void
+say_screen_from_to (struct vc_data *vc, u_long from, u_long to )
+{
+	u_long start = vc->vc_origin, end;
+	if ( from > 0 ) start += from * vc->vc_size_row;
+	if ( to > vc->vc_rows ) to = vc->vc_rows;
+	end = vc->vc_origin + ( to * vc->vc_size_row);
+	for ( from = start; from < end; from = to ) {
+		to = from + vc->vc_size_row;
+		say_from_to( vc, from, to, 1 );
+	}
+}
+
+static void
+say_screen (struct vc_data *vc )
+{
+	say_screen_from_to( vc, 0, vc->vc_rows );
+}
+
+static void
+speakup_win_say (struct vc_data *vc )
+{
+	u_long start, end, from, to;
+	if ( win_start < 2 ) {
+		synth_write_msg( "no window" );
+		return;
+	}
+	start = vc->vc_origin + ( win_top * vc->vc_size_row );
+	end = vc->vc_origin + ( win_bottom * vc->vc_size_row );
+	while ( start <= end ) {
+		from = start + ( win_left * 2 );
+	to = start + ( win_right * 2 );
+	say_from_to( vc, from, to, 1 );
+		start += vc->vc_size_row;
+	}
+}
+
+static void
+top_edge (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	spk_pos = vc->vc_origin + 2 * spk_x;
+	spk_y = 0;
+	say_line (vc );
+}
+
+static void
+bottom_edge (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	spk_pos += (vc->vc_rows - spk_y - 1 ) * vc->vc_size_row;
+	spk_y = vc->vc_rows - 1;
+	say_line (vc );
+}
+
+static void
+left_edge (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	spk_pos -= spk_x * 2;
+	spk_x = 0;
+	say_char (vc );
+}
+
+static void
+right_edge (struct vc_data *vc )
+{
+	spk_parked |= 0x01;
+	spk_pos += (vc->vc_cols - spk_x - 1 ) * 2;
+	spk_x = vc->vc_cols - 1;
+	say_char (vc );
+}
+
+static void
+say_first_char (struct vc_data *vc )
+{
+	int i, len = get_line( vc );
+	u_char ch;
+	spk_parked |= 0x01;
+	if ( len == 0 ) {
+		synth_write_msg( blank_msg );
+		return;
+	}
+	for ( i = 0; i < len; i++ ) if ( buf[i] != SPACE ) break;
+	ch = buf[i];
+	spk_pos -= ( spk_x-i ) * 2;
+	spk_x = i;
+	sprintf (buf, "%d, ", ++i );
+	synth_write_string (buf );
+	speak_char( ch );
+}
+
+static void
+say_last_char (struct vc_data *vc )
+{
+	int len = get_line( vc );
+	u_char ch;
+	spk_parked |= 0x01;
+	if ( len == 0 ) {
+		synth_write_msg( blank_msg );
+		return;
+	}
+	ch = buf[--len];
+	spk_pos -= ( spk_x-len ) * 2;
+	spk_x = len;
+	sprintf (buf, "%d, ", ++len );
+	synth_write_string (buf );
+	speak_char( ch );
+}
+
+static void
+say_position (struct vc_data *vc )
+{
+	sprintf (buf, "line %ld, col %ld, t t y %d\n", spk_y + 1,
+		     spk_x + 1, vc->vc_num + 1 );
+	synth_write_string (buf );
+}
+
+// Added by brianb
+static void
+say_char_num (struct vc_data *vc )
+{
+	u_short ch = scr_readw ((u_short * ) spk_pos );
+	ch &= 0x0ff;
+	sprintf (buf, "hex %02x, decimal %d", ch, ch );
+	synth_write_msg (buf );
+}
+
+/* these are stub functions to keep keyboard.c happy. */
+
+static void
+say_from_top (struct vc_data *vc )
+{
+	say_screen_from_to (vc, 0, spk_y );
+}
+
+static void
+say_to_bottom (struct vc_data *vc )
+{
+	say_screen_from_to (vc, spk_y, vc->vc_rows );
+}
+
+static void
+say_from_left (struct vc_data *vc )
+{
+	say_line_from_to (vc, 0, spk_x, 1 );
+}
+
+static void
+say_to_right (struct vc_data *vc )
+{
+	say_line_from_to (vc, spk_x, vc->vc_cols, 1 );
+}
+
+/* end of stub functions. */
+
+static void
+spkup_write (const char *in_buf, int count )
+{
+	static int rep_count = 0;
+	static u_char ch = '\0', old_ch = '\0';
+	static u_short char_type = 0, last_type = 0;
+	static u_char *exn_ptr = NULL;
+	int in_count = count;
+	char rpt_buf[32];
+	spk_keydown = 0;
+	while ( count-- ) {
+		if ( cursor_track == read_all_mode )
+		{
+			// Insert Sentence Index
+			if (( in_buf == sentmarks[bn][currsentence] ) &&
+			   ( currsentence <= numsentences[bn] ))
+			{
+				synth_insert_next_index(currsentence);
+				currsentence++;
+			}
+		}
+		ch = (u_char )*in_buf++;
+		char_type = spk_chartab[ch];
+		if (ch == old_ch && !(char_type&B_NUM ) ) {
+			if (++rep_count > 2 ) continue;
+		} else {
+			if ( (last_type&CH_RPT) && rep_count > 2 ) {
+				sprintf (rpt_buf, " times %d . ", ++rep_count );
+				synth_write_string (rpt_buf );
+			}
+			rep_count = 0;
+		}
+		if ( !( char_type&B_NUM ) )
+				exn_ptr = NULL;
+		if (ch == spk_lastkey ) {
+			rep_count = 0;
+			if ( key_echo == 1 && ch >= MINECHOCHAR )
+				speak_char( ch );
+		} else if ( ( char_type&B_ALPHA ) ) {
+			if ( (synth_flags&SF_DEC) && (last_type&PUNC) )
+				synth_buffer_add ( SPACE );
+			synth_write( &ch, 1 );
+		} else if ( ( char_type&B_NUM ) ) {
+			rep_count = 0;
+			if ( (last_type&B_EXNUM) && synth_buff_in == exn_ptr+1 ) {
+				synth_buff_in--;
+				synth_buffer_add( old_ch );
+				exn_ptr = NULL;
+			}
+			synth_write( &ch, 1 );
+		} else if ( (char_type&punc_mask) ) {
+			speak_char( ch );
+			char_type &= ~PUNC; /* for dec nospell processing */
+		} else if ( ( char_type&SYNTH_OK ) ) {
+/* these are usually puncts like . and , which synth needs for expression.
+ * suppress multiple to get rid of long pausesand clear repeat count so if
+ *someone has repeats on you don't get nothing repeated count */
+			if ( ch != old_ch )
+				synth_write( &ch, 1 );
+			else rep_count = 0;
+		} else {
+			if ( ( char_type&B_EXNUM ) )
+					exn_ptr = (u_char *)synth_buff_in;
+/* send space and record position, if next is num overwrite space */
+			if ( old_ch != ch ) synth_buffer_add ( SPACE );
+			else rep_count = 0;
+		}
+		old_ch = ch;
+		last_type = char_type;
+	}
+	spk_lastkey = 0;
+	if (in_count > 2 && rep_count > 2 ) {
+		if ( (last_type&CH_RPT) ) {
+			sprintf (rpt_buf, " repeated %d . ", ++rep_count );
+			synth_write_string (rpt_buf );
+		}
+		rep_count = 0;
+	}
+}
+
+static char *ctl_key_ids[] = {
+	"shift", "altgr", "control", "ault", "l shift", "speakup",
+"l control", "r control"
+};
+#define NUM_CTL_LABELS 8
+
+static void read_all_doc( struct vc_data *vc);
+void cursor_stop_timer(void );
+
+static void
+handle_shift( KBD_PROTO )
+{
+	(*do_shift)( KBD_ARGS );
+	if ( synth == NULL || up_flag || spk_killed ) return;
+	if (cursor_track==read_all_mode)
+	{
+		switch (value)
+		{
+			case KVAL(K_SHIFT):
+				cursor_stop_timer( );
+				spk_shut_up &= 0xfe;
+				do_flush();
+				read_all_doc( vc );
+				break;
+			case KVAL(K_CTRL):
+				cursor_stop_timer( );
+				cursor_track=prev_cursor_track;
+				spk_shut_up &= 0xfe;
+				do_flush();
+				break;
+		}
+	}
+	else
+	{
+		spk_shut_up &= 0xfe;
+		do_flush();
+	}
+	//synth_write_immediate("\x19");
+	if ( say_ctrl && value < NUM_CTL_LABELS )
+		synth_write_string ( ctl_key_ids[value] );
+}
+
+static void
+handle_latin( KBD_PROTO )
+{
+	(*do_latin)( KBD_ARGS );
+	if ( up_flag ) {
+		spk_lastkey = spk_keydown = 0;
+		return;
+	}
+	if ( synth == NULL || spk_killed ) return;
+	spk_shut_up &= 0xfe;
+	spk_lastkey = value;
+	spk_keydown++;
+	spk_parked &= 0xfe;
+	if ( key_echo == 2 && value >= MINECHOCHAR )
+		speak_char( value );
+}
+
+static int
+set_key_info( u_char *key_info, u_char *k_buffer )
+{
+	int i = 0,  states, key_data_len;
+	u_char *cp = key_info, *cp1 = k_buffer;
+	u_char ch, version, num_keys;
+	version = *cp++;
+	if ( version != KEY_MAP_VER ) return -1;
+	num_keys = *cp;
+	states = (int)cp[1];
+	key_data_len = ( states+1 ) * ( num_keys+1 );
+	if ( key_data_len+SHIFT_TBL_SIZE+4 >= sizeof(key_buf ) ) return -2;
+	memset( k_buffer, 0, SHIFT_TBL_SIZE );
+	memset( our_keys, 0, sizeof( our_keys ) );
+	shift_table = k_buffer;
+	our_keys[0] = shift_table;
+	cp1 += SHIFT_TBL_SIZE;
+	memcpy( cp1, cp, key_data_len+3 );
+/* get num_keys, states and data*/
+	cp1 += 2; /* now pointing at shift states */
+	for ( i = 1; i <= states; i++ ) {
+		ch = *cp1++;
+		if ( ch >= SHIFT_TBL_SIZE ) return -3;
+		shift_table[ch] = i;
+	}
+	keymap_flags = *cp1++;
+	while ( ( ch = *cp1 ) ) {
+		if ( ch >= MAX_KEY ) return -4;
+		our_keys[ch] = cp1;
+		cp1 += states+1;
+	}
+	return 0;
+}
+
+num_var spk_num_vars[] = { /* bell must be first to set high limit */
+	{ BELL_POS, 0, 0, 0, 0, 0, 0, 0 },
+	{ SPELL_DELAY, 0, 0, 0, 5, 0, 0, 0 },
+	{ ATTRIB_BLEEP, 0, 1, 0, 3, 0, 0, 0 },
+	{ BLEEPS, 0, 3, 0, 3, 0, 0, 0 },
+	{ BLEEP_TIME, 0, 4, 1, 20, 0, 0, 0 },
+	{ PUNC_LEVEL, 0, 1, 0, 4, 0, 0, 0 },
+	{ READING_PUNC, 0, 1, 0, 4, 0, 0, 0 },
+	{ CURSOR_TIME, 0, 120, 50, 600, 0, 0, 0 },
+	{ SAY_CONTROL, TOGGLE_0 },
+	{ SAY_WORD_CTL, TOGGLE_0 },
+	{ NO_INTERRUPT, TOGGLE_0 },
+	{ KEY_ECHO, 0, 1, 0, 2, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+static char *cursor_msgs[] = { "cursoring off", "cursoring on",
+	"highlight tracking", "read all" };
+//#define MAXCURSORTRACK 2 static int cursor_track = 1;static int prev_cursor_track=cursor_track;static int read_all_mode=MAXCURSORTRACK+1;
+/* increase when we add more cursor modes */
+/* attribute cursor code coming soon */
+
+static void
+toggle_cursoring( struct vc_data *vc )
+{
+	if (cursor_track==read_all_mode)
+		cursor_track=prev_cursor_track;
+        cursor_track++;
+	if ( cursor_track > MAXCURSORTRACK )
+		cursor_track = 0;
+	synth_write_msg (cursor_msgs[cursor_track] );
+}
+
+static void
+reset_default_chars (void )
+{
+	int i;
+	if (default_chars[(int )'a'] == NULL ) { /* lowers are null first time */
+		for (i = (int )'a'; default_chars[i] == NULL; i++ )
+			default_chars[i] = default_chars[i-32];
+	} else { /* free any non-default */
+		for (i = 0; i < 256; i++ ) {
+			if (characters[i] != default_chars[i] )
+				kfree (characters[i] );
+		}
+	}
+		memcpy( characters, default_chars, sizeof( default_chars ) );
+}
+
+static void
+handle_cursor( KBD_PROTO );
+static void
+handle_spec( KBD_PROTO );
+static void
+cursor_done(u_long data );
+
+declare_timer( cursor_timer );
+
+void __init speakup_open (struct vc_data *vc, spk_t *first_console )
+{
+	int i;
+	num_var *n_var;
+
+	reset_default_chars();
+	memset( speakup_console, 0, sizeof(speakup_console));
+	if ( first_console == NULL ) return;
+	memset( first_console, 0, spk_size);
+	speakup_console[vc->vc_num] = first_console;
+	speakup_date(vc);
+	pr_info ("%s: initialized\n", SPEAKUP_VERSION );
+	init_timer(&cursor_timer);
+	cursor_timer.entry.prev = NULL;
+	cursor_timer.function = cursor_done;
+	init_sleeper(synth_sleeping_list);
+	strlwr(synth_name);
+ 	spk_num_vars[0].high = vc->vc_cols;
+	for ( n_var = spk_num_vars; n_var->var_id >= 0; n_var++ )
+		speakup_register_var(n_var);
+	for (i = 1; punc_info[i].mask != 0; i++ )
+		set_mask_bits( 0, i, 2 );
+	do_latin = key_handler[KT_LATIN];
+	key_handler[KT_LATIN] = handle_latin;
+	do_spec = key_handler[KT_SPEC];
+	key_handler[KT_SPEC] = handle_spec;
+	do_cursor = key_handler[KT_CUR];
+	key_handler[KT_CUR] = handle_cursor;
+	do_shift = key_handler[KT_SHIFT];
+	key_handler[KT_SHIFT] = handle_shift;
+	set_key_info(key_defaults, key_buf);
+}
+
+#ifdef CONFIG_PROC_FS
+
+// speakup /proc interface code
+
+/* Usage:
+cat /proc/speakup/version
+
+cat /proc/speakup/characters > foo
+less /proc/speakup/characters
+vi /proc/speakup/characters
+
+cat foo > /proc/speakup/characters
+cat > /proc/speakup/characters
+echo 39 apostrophe > /proc/speakup/characters
+echo 87 w > /proc/speakup/characters
+echo 119 w > /proc/speakup/characters
+echo defaults > /proc/speakup/characters
+echo reset > /proc/speakup/characters
+*/
+
+// keymap handlers
+
+static int
+keys_read_proc (PROC_READ_PROTOTYPE )
+{
+	char *cp = page;
+	int i, n, num_keys, nstates;
+	u_char *cp1 = key_buf + SHIFT_TBL_SIZE, ch;
+	num_keys = (int)(*cp1);
+	nstates = (int)cp1[1];
+	cp += sprintf( cp, "%d, %d, %d,\n", KEY_MAP_VER,  num_keys, nstates );
+	cp1 += 2; /* now pointing at shift states */
+/* dump num_keys+1 as first row is shift states + flags,
+   each subsequent row is key + states */
+	for ( n = 0; n <= num_keys; n++ ) {
+		for ( i = 0; i <= nstates; i++ ) {
+			ch = *cp1++;
+			cp += sprintf( cp, "%d,", (int)ch );
+			*cp++ = ( i < nstates ) ? SPACE : '\n';
+		}
+	}
+	cp += sprintf( cp, "0, %d\n", KEY_MAP_VER );
+	*start = 0;
+	*eof = 1;
+	return (int)(cp-page);
+}
+
+static char *
+s2uchar ( char *start, char *dest )
+{
+	int val = 0;
+	while ( *start && *start <= SPACE ) start++;
+	while ( *start >= '0' && *start <= '9' ) {
+		val *= 10;
+		val += ( *start ) - '0';
+		start++;
+	}
+	if ( *start == ',' ) start++;
+	*dest = (u_char)val;
+	return start;
+}
+
+static int
+keys_write_proc (PROC_WRITE_PROTOTYPE )
+{
+	int i, ret = count;
+	char *in_buff, *cp;
+	u_char *cp1;
+	if (count < 1 || count > 1800 )
+		return -EINVAL;
+	in_buff = ( char * ) __get_free_page ( GFP_KERNEL );
+	if ( !in_buff ) return -ENOMEM;
+	if (copy_from_user (in_buff, buffer, count ) ) {
+		free_page ( ( unsigned long ) in_buff );
+		return -EFAULT;
+	}
+	if (in_buff[count - 1] == '\n' ) count--;
+	in_buff[count] = '\0';
+	if ( count == 1 && *in_buff == 'd' ) {
+		free_page ( ( unsigned long ) in_buff );
+		set_key_info( key_defaults, key_buf );
+		return ret;
+	}
+	cp = in_buff;
+	cp1 = (u_char *)in_buff;
+	for ( i = 0; i < 3; i++ ) {
+		cp = s2uchar( cp, cp1 );
+		cp1++;
+	}
+	i = (int)cp1[-2]+1;
+	i *= (int)cp1[-1]+1;
+	i+= 2; /* 0 and last map ver */
+	if ( cp1[-3] != KEY_MAP_VER || cp1[-1] > 10 ||
+			i+SHIFT_TBL_SIZE+4 >= sizeof(key_buf ) ) {
+pr_warn( "i %d %d %d %d\n", i, (int)cp1[-3], (int)cp1[-2], (int)cp1[-1] );
+		free_page ( ( unsigned long ) in_buff );
+		return -EINVAL;
+	}
+	while ( --i >= 0 ) {
+		cp = s2uchar( cp, cp1 );
+		cp1++;
+		if ( !(*cp) ) break;
+	}
+	if ( i != 0 || cp1[-1] != KEY_MAP_VER || cp1[-2] != 0 ) {
+		ret = -EINVAL;
+pr_warn( "end %d %d %d %d\n", i, (int)cp1[-3], (int)cp1[-2], (int)cp1[-1] );
+	} else {
+		if ( set_key_info( in_buff, key_buf ) ) {
+			set_key_info( key_defaults, key_buf );
+		ret = -EINVAL;
+pr_warn( "set key failed\n" );
+		}
+	}
+	free_page ( ( unsigned long ) in_buff );
+	return ret;
+}
+
+// this is the handler for /proc/speakup/version
+static int
+version_read_proc (PROC_READ_PROTOTYPE )
+{
+	int len = sprintf (page, "%s\n", SPEAKUP_VERSION );
+	if ( synth != NULL )
+		len += sprintf( page+len, "synth %s version %s\n",
+			synth->name, synth->version );
+	*start = 0;
+	*eof = 1;
+	return len;
+}
+
+// this is the read handler for /proc/speakup/characters
+static int
+chars_read_proc (PROC_READ_PROTOTYPE )
+{
+	int i, len = 0;
+	off_t begin = 0;
+	char *cp;
+	for (i = 0; i < 256; i++ ) {
+		cp = (characters[i] ) ? characters[i] : "NULL";
+		len += sprintf (page + len, "%d\t%s\n", i, cp );
+		if (len + begin > off + count )
+			break;
+		if (len + begin < off ) {
+			begin += len;
+			len = 0;
+		}
+	}
+	if (i >= 256 )
+		*eof = 1;
+	if (off >= len + begin )
+		return 0;
+	*start = page + (off - begin );
+	return ((count < begin + len - off ) ? count : begin + len - off );
+}
+
+static volatile int chars_timer_active = 0;	// indicates when timer is set
+static declare_timer( chars_timer );
+
+static inline void
+chars_stop_timer (void )
+{
+	if (chars_timer_active )
+		stop_timer ( chars_timer );
+}
+
+static int strings, rejects, updates;
+
+static void
+show_char_results (u_long data )
+{
+	int len;
+	char buf[80];
+	chars_stop_timer ( );
+	len = sprintf (buf, " updated %d of %d character descriptions\n",
+		       updates, strings );
+	if (rejects )
+		sprintf (buf + (len-1), " with %d reject%s\n",
+			 rejects, rejects > 1 ? "s" : "" );
+	printk( buf );
+}
+
+/* this is the write handler for /proc/speakup/silent */
+static int
+silent_write_proc (PROC_WRITE_PROTOTYPE )
+{
+	struct vc_data *vc = vc_cons[fg_console].d;
+	char ch = 0, shut;
+	if (count > 0 || count < 3 ) {
+		get_user (ch, buffer );
+		if ( ch == '\n' ) ch = '0';
+	}
+	if ( ch < '0' || ch > '7' ) {
+		pr_warn ( "silent value not in range (0,7)\n" );
+		return count;
+	}
+	if ( (ch&2) ) {
+		shut = 1;
+		do_flush( );
+	} else shut = 0;
+	if ( (ch&4) ) shut |= 0x40;
+	if ( (ch&1) )
+		spk_shut_up |= shut;
+		else spk_shut_up &= ~shut;
+	return count;
+}
+
+// this is the write handler for /proc/speakup/characters
+static int
+chars_write_proc (PROC_WRITE_PROTOTYPE )
+{
+#define max_desc_len 72
+	static int cnt = 0, state = 0;
+	static char desc[max_desc_len + 1];
+	static u_long jiff_last = 0;
+	short i = 0, num;
+	int len;
+	char ch, *cp, *p_new;
+	// reset certain vars if enough time has elapsed since last called
+	if (jiffies - jiff_last > 10 ) {
+		cnt = state = strings = rejects = updates = 0;
+	}
+	jiff_last = jiffies;
+get_more:
+	desc[cnt] = '\0';
+	state = 0;
+	for (; i < count && state < 2; i++ ) {
+		get_user (ch, buffer + i );
+		if ( ch == '\n' ) {
+			desc[cnt] = '\0';
+			state = 2;
+		} else if (cnt < max_desc_len )
+			desc[cnt++] = ch;
+	}
+	if (state < 2 ) return count;
+	cp = desc;
+	while ( *cp && *cp <= SPACE ) cp++;
+	if ((!cnt ) || strchr ("dDrR", *cp ) ) {
+		reset_default_chars ( );
+		pr_info( "character descriptions reset to defaults\n" );
+		cnt = 0;
+		return count;
+	}
+	cnt = 0;
+	if (*cp == '#' ) goto get_more;
+	num = -1;
+	cp = speakup_s2i(cp, &num );
+	while ( *cp && *cp <= SPACE ) cp++;
+	if (num < 0 || num > 255 ) {	// not in range
+		rejects++;
+		strings++;
+		goto get_more;
+	}
+	if (num >= 27 && num <= 31 ) goto get_more;
+	if (!strcmp(cp, characters[num] ) ) {
+		strings++;
+		goto get_more;
+	}
+	len = strlen(cp );
+	if (characters[num] == default_chars[num] )
+		p_new = (char * ) kmalloc (sizeof (char ) * len+1, GFP_KERNEL );
+	else if ( strlen(characters[num] ) >= len )
+		p_new = characters[num];
+	else {
+		kfree(characters[num] );
+		characters[num] = default_chars[num];
+		p_new = (char * ) kmalloc (sizeof (char ) * len+1, GFP_KERNEL );
+	}
+	if (!p_new ) return -ENOMEM;
+	strcpy ( p_new, cp );
+	characters[num] = p_new;
+	updates++;
+	strings++;
+	if (i < count ) goto get_more;
+	chars_stop_timer ( );
+	init_timer (&chars_timer );
+	chars_timer.function = show_char_results;
+	chars_timer.expires = jiffies + 5;
+		start_timer (chars_timer );
+	chars_timer_active++;
+	return count;
+}
+
+static int
+bits_read_proc (PROC_READ_PROTOTYPE )
+{
+	int i;
+	var_header *p_header = (var_header * )data;
+	proc_var *var = p_header->data;
+	bits_data *pb = &punc_info[var->value];
+	short mask = pb->mask;
+	char *cp = page;
+	*start = 0;
+	*eof = 1;
+	for ( i = 33; i < 128; i++ ) {
+		if ( !(spk_chartab[i]&mask ) ) continue;
+		*cp++ = (char )i;
+	}
+	*cp++ = '\n';
+	return cp-page;
+}
+
+/* set_mask_bits sets or clears the punc/delim/repeat bits,
+ * if input is null uses the defaults.
+ * values for how: 0 clears bits of chars supplied,
+ * 1 clears allk, 2 sets bits for chars */
+
+int
+set_mask_bits( const char *input, const int which, const int how )
+{
+	u_char *cp;
+	short mask = punc_info[which].mask;
+	if ( how&1 ) {
+		for ( cp = (u_char * )punc_info[3].value; *cp; cp++ )
+			spk_chartab[*cp] &= ~mask;
+	}
+	cp = (u_char * )input;
+	if ( cp == 0 ) cp = punc_info[which].value;
+	else {
+		for ( ; *cp; cp++ ) {
+			if ( *cp < SPACE ) break;
+			if ( mask < PUNC ) {
+				if ( !(spk_chartab[*cp]&PUNC) ) break;
+			} else if ( (spk_chartab[*cp]&B_NUM) ) break;
+		}
+		if ( *cp ) return -EINVAL;
+		cp = (u_char * )input;
+	}
+	if ( how&2 ) {
+		for ( ; *cp; cp++ )
+			if ( *cp > SPACE ) spk_chartab[*cp] |= mask;
+	} else {
+		for ( ; *cp; cp++ )
+			if ( *cp > SPACE ) spk_chartab[*cp] &= ~mask;
+	}
+	return 0;
+}
+
+static bits_data *pb_edit = NULL;
+
+static int edit_bits (struct vc_data *vc, u_char type, u_char ch, u_short key )
+{
+	short mask = pb_edit->mask, ch_type = spk_chartab[ch];
+	if ( type != KT_LATIN || (ch_type&B_NUM ) || ch < SPACE ) return -1;
+	if ( ch == SPACE ) {
+		synth_write_msg( "edit done" );
+		special_handler = NULL;
+		return 1;
+	}
+	if ( mask < PUNC && !(ch_type&PUNC) ) return -1;
+	spk_chartab[ch] ^= mask;
+	speak_char( ch );
+	synth_write_msg( (spk_chartab[ch]&mask ) ? " on" : " off" );
+	return 1;
+}
+
+static int
+bits_write_proc (PROC_WRITE_PROTOTYPE )
+{
+	var_header *p_header = (var_header * )data;
+	proc_var *var = p_header->data;
+	int ret = count;
+	char punc_buf[100];
+	if (count < 1 || count > 99 )
+		return -EINVAL;
+	if (copy_from_user (punc_buf, buffer, count ) )
+		return -EFAULT;
+	if (punc_buf[count - 1] == '\n' )
+		count--;
+	punc_buf[count] = '\0';
+	if ( *punc_buf == 'd' || *punc_buf == 'r' )
+		count = set_mask_bits( 0, var->value, 3 );
+	else
+		count = set_mask_bits( punc_buf, var->value, 3 );
+	if ( count < 0 ) return count;
+	return ret;
+}
+
+// this is the read handler for /proc/speakup/synth
+static int
+synth_read_proc (PROC_READ_PROTOTYPE )
+{
+	int len;
+	if ( synth == NULL ) strcpy( synth_name, "none" );
+	else strcpy( synth_name, synth->name );
+	len = sprintf (page, "%s\n", synth_name );
+	*start = 0;
+	*eof = 1;
+	return len;
+}
+
+// this is the write handler for /proc/speakup/synth
+static int
+synth_write_proc (PROC_WRITE_PROTOTYPE )
+{
+	int ret = count;
+	char new_synth_name[10];
+	const char *old_name = ( synth != NULL ) ? synth->name : "none";
+	if (count < 2 || count > 9 )
+		return -EINVAL;
+	if (copy_from_user (new_synth_name, buffer, count ) )
+		return -EFAULT;
+	if (new_synth_name[count - 1] == '\n' )
+		count--;
+	new_synth_name[count] = '\0';
+	strlwr (new_synth_name );
+	if (!strcmp (new_synth_name, old_name ) ) {
+		pr_warn ( "%s already in use\n", new_synth_name );
+		return ret;
+	}
+	if ( synth_init( new_synth_name ) == 0 ) return ret;
+	pr_warn( "failed to init synth %s\n", new_synth_name );
+	return -ENODEV;
+}
+
+proc_var spk_proc_vars[] = {
+	 { VERSION, version_read_proc, 0, 0 },
+	 { SILENT, 0, silent_write_proc, 0 },
+	 { CHARS, chars_read_proc, chars_write_proc, 0 },
+	 { SYNTH, synth_read_proc, synth_write_proc, 0 },
+	 { KEYMAP, keys_read_proc, keys_write_proc, 0 },
+	 { PUNC_SOME, bits_read_proc, bits_write_proc, 1 },
+	 { PUNC_MOST, bits_read_proc, bits_write_proc, 2 },
+	 { PUNC_ALL, bits_read_proc, 0, 3 },
+	 { DELIM, bits_read_proc, bits_write_proc, 4 },
+	 { REPEATS, bits_read_proc, bits_write_proc, 5 },
+	 { EXNUMBER, bits_read_proc, bits_write_proc, 6 },
+	{ -1, 0, 0, 0 }
+};
+
+#endif // CONFIG_PROC_FS
+
+#ifdef CONFIG_SPEAKUP
+
+
+void __init
+speakup_init (struct vc_data *vc )
+{
+	spk_t *first_console = (spk_t *) alloc_bootmem (spk_size+1 );
+	speakup_open( vc, first_console );
+}
+
+#endif
+
+void
+speakup_allocate (struct vc_data *vc )
+{
+	int vc_num;
+
+	vc_num = vc->vc_num;
+	if ( speakup_console[vc_num] == NULL ) {
+		speakup_console[vc_num] = (spk_t *) kmalloc (spk_size + 1,
+			GFP_KERNEL );
+		if ( speakup_console[vc_num] == NULL ) return;
+		memset( speakup_console[vc_num], 0, spk_size );
+		speakup_date( vc);
+	} else if ( !spk_parked ) speakup_date( vc);
+}
+
+static void
+speakup_date (struct vc_data *vc )
+{
+	spk_x = spk_cx = vc->vc_x;
+	spk_y = spk_cy = vc->vc_y;
+	spk_pos = spk_cp = vc->vc_pos;
+	spk_old_attr = spk_attr;
+	spk_attr = ((scr_readw ((u_short * ) spk_pos ) & 0xff00 ) >> 8 );
+}
+
+static u_char is_cursor = 0;
+static u_long old_cursor_pos, old_cursor_x, old_cursor_y;
+static int cursor_con;
+volatile int cursor_timer_active = 0;
+
+void
+cursor_stop_timer(void )
+{
+  if (!cursor_timer_active ) return;
+		stop_timer ( cursor_timer );
+	cursor_timer_active = 0;
+}
+
+static void reset_highlight_buffers( struct vc_data * );
+
+//extern void kbd_fakekey(unsigned int);
+extern struct input_dev *fakekeydev;
+
+int read_all_key;
+
+void reset_index_count(int);
+void get_index_count(int *, int *);
+//int synth_supports_indexing(void);
+static void start_read_all_timer( struct vc_data *vc, int command );
+
+enum {RA_NOTHING,RA_NEXT_SENT,RA_PREV_LINE,RA_NEXT_LINE,RA_PREV_SENT,RA_DOWN_ARROW,RA_TIMER,RA_FIND_NEXT_SENT,RA_FIND_PREV_SENT};
+
+static void
+kbd_fakekey2(struct vc_data *vc,int v,int command)
+{
+	cursor_stop_timer();
+        (*do_cursor)( vc,v,0,fakekeydev->regs);
+        (*do_cursor)( vc,v,1,fakekeydev->regs);
+	start_read_all_timer(vc,command);
+}
+
+static void
+read_all_doc( struct vc_data *vc)
+{
+	if (!synth_supports_indexing())
+		return;
+	if ( synth == NULL || spk_shut_up || (vc->vc_num != fg_console ) )
+		return;
+	if (cursor_track!=read_all_mode)
+		prev_cursor_track=cursor_track;
+	cursor_track=read_all_mode;
+	reset_index_count(0);
+	if (get_sentence_buf(vc,0)==-1)
+	{
+		kbd_fakekey2(vc,0,RA_DOWN_ARROW);
+	}
+	else
+	{
+		say_sentence_num(0,0);
+		synth_insert_next_index(0);
+		start_read_all_timer(vc,RA_TIMER);
+	}
+}
+
+static void
+stop_read_all( struct vc_data *vc)
+{
+	cursor_stop_timer( );
+	cursor_track=prev_cursor_track;
+	spk_shut_up &= 0xfe;
+	do_flush();
+}
+
+static void
+start_read_all_timer( struct vc_data *vc, int command )
+{
+	cursor_con = vc->vc_num;
+	cursor_timer.expires = jiffies + cursor_timeout;
+	read_all_key=command;
+	start_timer (cursor_timer );
+	cursor_timer_active++;
+}
+
+static void
+handle_cursor_read_all( struct vc_data *vc,int command )
+{
+	int indcount,sentcount,rv,sn;
+
+	switch (command)
+	{
+		case RA_NEXT_SENT:
+			// Get Current Sentence
+			get_index_count(&indcount,&sentcount);
+			//printk("%d %d  ",indcount,sentcount);
+			reset_index_count(sentcount+1);
+			if (indcount==1)
+			{
+				if (!say_sentence_num(sentcount+1,0))
+				{
+					kbd_fakekey2(vc,0,RA_FIND_NEXT_SENT);
+					return;
+				}
+				synth_insert_next_index(0);
+			}
+			else
+			{
+				sn=0;
+				if (!say_sentence_num(sentcount+1,1))
+				{
+					sn=1;
+					reset_index_count(sn);
+				}
+				else
+					synth_insert_next_index(0);
+				if (!say_sentence_num(sn,0))
+				{
+					kbd_fakekey2(vc,0,RA_FIND_NEXT_SENT);
+					return;
+				}
+				synth_insert_next_index(0);
+			}
+			start_read_all_timer(vc,RA_TIMER);
+			break;
+		case RA_PREV_SENT:
+			break;
+		case RA_NEXT_LINE:
+			read_all_doc(vc);
+			break;
+		case RA_PREV_LINE:
+			break;
+		case RA_DOWN_ARROW:
+			if (get_sentence_buf(vc,0)==-1)
+			{
+				kbd_fakekey2(vc,0,RA_DOWN_ARROW);
+			}
+			else
+			{
+				say_sentence_num(0,0);
+				synth_insert_next_index(0);
+				start_read_all_timer(vc,RA_TIMER);
+			}
+			break;
+		case RA_FIND_NEXT_SENT:
+			rv=get_sentence_buf(vc,0);
+			if (rv==-1)
+			{
+				read_all_doc(vc);
+			}
+			if (rv==0)
+			{
+				kbd_fakekey2(vc,0,RA_FIND_NEXT_SENT);
+			}
+			else
+			{
+				say_sentence_num(1,0);
+				synth_insert_next_index(0);
+				start_read_all_timer(vc,RA_TIMER);
+			}
+			break;
+		case RA_FIND_PREV_SENT:
+			break;
+		case RA_TIMER:
+			get_index_count(&indcount,&sentcount);
+			if (indcount<2)
+			{
+				kbd_fakekey2(vc,0,RA_DOWN_ARROW);
+			}
+			else
+			{
+				start_read_all_timer(vc,RA_TIMER);
+			}
+			break;
+	}
+}
+
+static void
+handle_cursor( KBD_PROTO )
+{
+	if (cursor_track == read_all_mode)
+	{
+		spk_parked &= 0xfe;
+		if ( synth == NULL || up_flag || spk_shut_up )
+			return;
+		cursor_stop_timer();
+		spk_shut_up &= 0xfe;
+		do_flush();
+
+		start_read_all_timer(vc,value+1);
+		return;
+	}
+	(*do_cursor)( KBD_ARGS );
+	spk_parked &= 0xfe;
+	if ( synth == NULL || up_flag || spk_shut_up || cursor_track == 0 )
+	  return;
+	spk_shut_up &= 0xfe;
+	if ( no_intr ) do_flush( );
+/* the key press flushes if !no_inter but we want to flush on cursor
+ * moves regardless of no_inter state */
+	is_cursor = value+1;
+	old_cursor_pos = vc->vc_pos;
+	old_cursor_x = vc->vc_x;
+	old_cursor_y = vc->vc_y;
+	speakup_console[vc->vc_num]->ht.cy=vc->vc_y;
+	cursor_con = vc->vc_num;
+	cursor_stop_timer( );
+	cursor_timer.expires = jiffies + cursor_timeout;
+	if ( cursor_track == 2)
+		reset_highlight_buffers( vc );
+	read_all_key=value+1;
+	start_timer (cursor_timer );
+	cursor_timer_active++;
+}
+
+static void
+update_color_buffer( struct vc_data *vc , const char *ic , int len )
+{
+	int i,bi,hi;
+	int vc_num=vc->vc_num;
+
+	bi = ( (vc->vc_attr & 0x70) >> 4 ) ;
+	hi=speakup_console[vc_num]->ht.highsize[bi];
+
+	i=0;
+	if (speakup_console[vc_num]->ht.highsize[bi]==0)
+	{
+		speakup_console[vc_num]->ht.rpos[bi]=vc->vc_pos;
+		speakup_console[vc_num]->ht.rx[bi]=vc->vc_x;
+		speakup_console[vc_num]->ht.ry[bi]=vc->vc_y;
+	}
+	while (( hi<COLOR_BUFFER_SIZE ) && ( i < len ))
+	{
+		if (( ic[i]>32 ) && ( ic[i]<127 ))
+		{
+			speakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];
+			hi++;
+		}
+		else if (( ic[i] == 32 ) && ( hi != 0 ))
+		{
+			if (speakup_console[vc_num]->ht.highbuf[bi][hi-1]!=32)
+			{
+				speakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];
+				hi++;
+			}
+		}
+		i++;
+	}
+	speakup_console[vc_num]->ht.highsize[bi]=hi;
+}
+
+static void
+reset_highlight_buffers( struct vc_data *vc )
+{
+	int i;
+	int vc_num=vc->vc_num;
+	for ( i=0 ; i<8 ; i++ )
+		speakup_console[vc_num]->ht.highsize[i]=0;
+}
+
+static int
+count_highlight_color(struct vc_data *vc)
+{
+	int i,bg;
+	int cc;
+	int vc_num=vc->vc_num;
+	u16 ch;
+	u16 *start = (u16 *) vc->vc_origin;
+
+	for ( i=0 ; i<8 ; i++ )
+		speakup_console[vc_num]->ht.bgcount[i]=0;
+
+	for ( i=0 ; i<vc->vc_rows; i++ ){
+		u16 *end = start + vc->vc_cols*2;
+		u16 *ptr;
+		for ( ptr=start ; ptr<end ; ptr++){
+			ch = scr_readw( ptr );
+			bg = ( ch & 0x7000 ) >> 12;
+			speakup_console[vc_num]->ht.bgcount[bg]++;
+		}
+		start += vc->vc_size_row;
+	}
+
+	cc=0;
+	for ( i=0 ; i<8 ; i++ )
+		if (speakup_console[vc_num]->ht.bgcount[i]>0)
+			cc++;
+	return cc;
+}
+
+static int
+get_highlight_color( struct vc_data *vc )
+{
+	int i,j;
+	unsigned int cptr[8],tmp;
+	int vc_num=vc->vc_num;
+
+	for ( i=0 ; i<8 ; i++ )
+		cptr[i]=i;
+
+	for ( i=0 ; i<7 ; i++ )
+		for ( j=i+1 ; j<8 ; j++ )
+			if ( speakup_console[vc_num]->ht.bgcount[cptr[i]] > speakup_console[vc_num]->ht.bgcount[cptr[j]]){
+				tmp=cptr[i];
+				cptr[i]=cptr[j];
+				cptr[j]=tmp;
+			}
+
+	for ( i=0; i<8; i++ )
+		if ( speakup_console[vc_num]->ht.bgcount[cptr[i]] != 0)
+			if ( speakup_console[vc_num]->ht.highsize[cptr[i]] > 0)
+			{
+				return cptr[i];
+			}
+	return -1;
+}
+
+static int
+speak_highlight( struct vc_data *vc )
+{
+	int hc,d;
+	int vc_num=vc->vc_num;
+	if (count_highlight_color( vc )==1)
+		return 0;
+	hc=get_highlight_color( vc );
+	if ( hc != -1 )
+	{
+		d=vc->vc_y-speakup_console[vc_num]->ht.cy;
+		if ((d==1)||(d==-1))
+		{
+			if (speakup_console[vc_num]->ht.ry[hc]!=vc->vc_y)
+				return 0;
+		}
+		spk_parked |= 0x01;
+		do_flush();
+		spkup_write (speakup_console[vc_num]->ht.highbuf[hc] , speakup_console[vc_num]->ht.highsize[hc] );
+		spk_pos=spk_cp=speakup_console[vc_num]->ht.rpos[hc];
+		spk_x=spk_cx=speakup_console[vc_num]->ht.rx[hc];
+		spk_y=spk_cy=speakup_console[vc_num]->ht.ry[hc];
+		return 1;
+	}
+	return 0;
+}
+
+static void
+cursor_done (u_long data )
+{
+	struct vc_data *vc = vc_cons[cursor_con].d;
+	cursor_stop_timer( );
+	if (cursor_con != fg_console ) {
+		is_cursor = 0;
+		return;
+	}
+	speakup_date (vc );
+	if ( win_enabled ) {
+		if ( vc->vc_x >= win_left && vc->vc_x <= win_right &&
+		vc->vc_y >= win_top && vc->vc_y <= win_bottom ) {
+			spk_keydown = is_cursor = 0;
+			return;
+		}
+	}
+	if ( cursor_track == 2){
+		if ( speak_highlight( vc )) {
+			spk_keydown = is_cursor = 0;
+			return;
+		}
+	}
+	else if ( cursor_track == read_all_mode )
+	{
+		handle_cursor_read_all(vc,read_all_key);
+		return;
+	}
+
+        if ( is_cursor == 1 || is_cursor == 4 )
+		say_line_from_to (vc, 0, vc->vc_cols, 0 );
+	else
+		say_char ( vc );
+	spk_keydown = is_cursor = 0;
+}
+
+/* These functions are the interface to speakup from the actual kernel code. */
+
+void
+speakup_bs (struct vc_data *vc )
+{
+	if (!spk_parked )
+		speakup_date (vc );
+	if ( spk_shut_up || synth == NULL ) return;
+	if ( vc->vc_num == fg_console  && spk_keydown ) {
+		spk_keydown = 0;
+		if (!is_cursor ) say_char (vc );
+	}
+}
+
+void
+speakup_con_write (struct vc_data *vc, const char *str, int len )
+{
+	if (spk_shut_up || (vc->vc_num != fg_console ) )
+		return;
+	if (bell_pos && spk_keydown && (vc->vc_x == bell_pos - 1 ) )
+		bleep(3 );
+	if (synth == NULL) return;
+	if ((is_cursor)||(cursor_track == read_all_mode )){
+		if (cursor_track == 2 )
+			update_color_buffer( vc, str, len);
+		return;
+	}
+	if ( win_enabled ) {
+		if ( vc->vc_x >= win_left && vc->vc_x <= win_right &&
+		vc->vc_y >= win_top && vc->vc_y <= win_bottom ) return;
+	}
+
+	spkup_write (str, len );
+}
+
+void
+speakup_con_update (struct vc_data *vc )
+{
+	if ( speakup_console[vc->vc_num] == NULL || spk_parked )
+		return;
+	speakup_date (vc );
+}
+
+static void
+handle_spec( KBD_PROTO )
+{
+	int on_off = 2;
+	char *label;
+	static const char *lock_status[] = { " off", " on", "" };
+	(*do_spec)( KBD_ARGS );
+	if ( synth == NULL || up_flag || spk_killed ) return;
+	spk_shut_up &= 0xfe;
+	if ( no_intr ) do_flush( );
+	switch (value ) {
+		case KVAL( K_CAPS ):
+			label = "caps lock";
+			on_off =  (vc_kbd_led(kbd , VC_CAPSLOCK ) );
+			break;
+		case KVAL( K_NUM ):
+			label = "num lock";
+			on_off = (vc_kbd_led(kbd , VC_NUMLOCK ) );
+			break;
+		case KVAL( K_HOLD ):
+			label = "scroll lock";
+			on_off = (vc_kbd_led(kbd , VC_SCROLLOCK ) );
+			break;
+	default:
+		spk_parked &= 0xfe;
+		return;
+	}
+	synth_write_string ( label );
+	synth_write_msg ( lock_status[on_off] );
+}
+
+static int
+inc_dec_var( u_char value )
+{
+	var_header *p_header;
+	num_var *var_data;
+	char num_buf[32];
+	char *cp = num_buf, *pn;
+	int var_id = (int)value - VAR_START;
+	int how = (var_id&1) ? E_INC : E_DEC;
+	var_id = var_id/2+FIRST_SET_VAR;
+	p_header = get_var_header( var_id );
+	if ( p_header == NULL ) return -1;
+	if ( p_header->var_type != VAR_NUM ) return -1;
+	var_data = p_header->data;
+	if ( set_num_var( 1, p_header, how ) != 0 )
+		return -1;
+	if ( !spk_close_press ) {
+		for ( pn = p_header->name; *pn; pn++ ) {
+			if ( *pn == '_' ) *cp = SPACE;
+			else *cp++ = *pn;
+		}
+	}
+	sprintf( cp, " %d ", (int)var_data->value );
+	synth_write_string( num_buf );
+	return 0;
+}
+
+static void
+speakup_win_set (struct vc_data *vc )
+{
+	char info[40];
+	if ( win_start > 1 ) {
+		synth_write_msg( "window already set, clear then reset" );
+		return;
+	}
+	if ( spk_x < win_left || spk_y < win_top ) {
+		synth_write_msg( "error end before start" );
+		return;
+	}
+	if ( win_start && spk_x == win_left && spk_y == win_top ) {
+		win_left = 0;
+		win_right = vc->vc_cols-1;
+		win_bottom = spk_y;
+		sprintf( info, "window is line %d", (int)win_top+1 );
+	} else {
+		if ( !win_start ) {
+			win_top = spk_y;
+			win_left = spk_x;
+		} else {
+			win_bottom = spk_y;
+			win_right = spk_x;
+		}
+		sprintf( info, "%s at line %d, column %d",
+			(win_start) ? "end" : "start",
+			(int)spk_y+1, (int)spk_x+1 );
+	}
+	synth_write_msg( info );
+	win_start++;
+}
+
+static void
+speakup_win_clear (struct vc_data *vc )
+{
+	win_top = win_bottom = 0;
+	win_left = win_right = 0;
+	win_start = 0;
+	synth_write_msg( "window cleared" );
+}
+
+static void
+speakup_win_enable (struct vc_data *vc )
+{
+	if ( win_start < 2 ) {
+		synth_write_msg( "no window" );
+		return;
+	}
+	win_enabled ^= 1;
+	if ( win_enabled ) synth_write_msg( "window silenced" );
+	else synth_write_msg( "window silence disabled" );
+}
+
+static void
+speakup_bits (struct vc_data *vc )
+{
+	int val = this_speakup_key - ( FIRST_EDIT_BITS - 1 );
+	if ( special_handler != NULL || val < 1 || val > 6 ) {
+		synth_write_msg( "error" );
+		return;
+	}
+	pb_edit = &punc_info[val];
+	sprintf( buf, "edit  %s, press space when done", pb_edit->name );
+	synth_write_msg( buf );
+	special_handler = edit_bits;
+}
+
+static int handle_goto (struct vc_data *vc, u_char type, u_char ch, u_short key )
+{
+	static u_char *goto_buf = "\0\0\0\0\0\0";
+	static int num = 0;
+	short maxlen, go_pos;
+	char *cp;
+	if ( type == KT_SPKUP && ch == SPEAKUP_GOTO ) goto do_goto;
+	if ( type == KT_LATIN && ch == '\n' ) goto do_goto;
+	if ( type != 0 ) goto oops;
+	if (ch == 8 ) {
+		if ( num == 0 ) return -1;
+		ch = goto_buf[--num];
+		goto_buf[num] = '\0';
+		spkup_write( &ch, 1 );
+		return 1;
+}
+	if ( ch < '+' || ch > 'y' ) goto oops;
+	goto_buf[num++] = ch;
+	goto_buf[num] = '\0';
+	spkup_write( &ch, 1 );
+	maxlen = ( *goto_buf >= '0' ) ? 3 : 4;
+	if ((ch == '+' || ch == '-' ) && num == 1 ) return 1;
+	if (ch >= '0' && ch <= '9' && num < maxlen ) return 1;
+	if ( num < maxlen-1 || num > maxlen ) goto oops;
+	if ( ch < 'x' || ch > 'y' ) {
+oops:
+		if (!spk_killed )
+			synth_write_msg (" goto canceled" );
+		goto_buf[num = 0] = '\0';
+		special_handler = NULL;
+		return 1;
+	}
+	cp = speakup_s2i (goto_buf, &go_pos );
+	goto_pos = (u_long)go_pos;
+	if (*cp == 'x' ) {
+		if (*goto_buf < '0' ) goto_pos += spk_x;
+		else goto_pos--;
+		if (goto_pos < 0 ) goto_pos = 0;
+		if (goto_pos >= vc->vc_cols )
+			goto_pos = vc->vc_cols-1;
+		goto_x = 1;
+	} else {
+		if (*goto_buf < '0' ) goto_pos += spk_y;
+		else goto_pos--;
+		if (goto_pos < 0 ) goto_pos = 0;
+	if (goto_pos >= vc->vc_rows ) goto_pos = vc->vc_rows-1;
+		goto_x = 0;
+	}
+		goto_buf[num = 0] = '\0';
+do_goto:
+	special_handler = NULL;
+	spk_parked |= 0x01;
+	if ( goto_x ) {
+		spk_pos -= spk_x * 2;
+		spk_x = goto_pos;
+		spk_pos += goto_pos * 2;
+		say_word( vc );
+	} else {
+		spk_y = goto_pos;
+		spk_pos = vc->vc_origin + ( goto_pos * vc->vc_size_row );
+		say_line( vc );
+	}
+	return 1;
+}
+
+static void
+speakup_goto (struct vc_data *vc )
+{
+	if ( special_handler != NULL ) {
+		synth_write_msg( "error" );
+		return;
+	}
+	synth_write_msg( "go to?" );
+	special_handler = handle_goto;
+	return;
+}
+
+static void
+load_help ( void *dummy )
+{
+	request_module( "speakup_keyhelp" );
+	if ( help_handler ) {
+		(*help_handler)(0, KT_SPKUP, SPEAKUP_HELP, 0 );
+	} else synth_write_string( "help module not found" );
+}
+
+static DECLARE_WORK(ld_help, load_help, NULL);
+#define schedule_help schedule_work
+
+static void
+speakup_help (struct vc_data *vc )
+{
+	if ( help_handler == NULL ) {
+/* we can't call request_module from this context so schedule it*/
+/* **** note kernel hangs and my wrath will be on you */
+		schedule_help (&ld_help);
+		return;
+	}
+	(*help_handler)(vc, KT_SPKUP, SPEAKUP_HELP, 0 );
+}
+
+static void
+do_nothing (struct vc_data *vc )
+{
+	return; /* flush done in do_spkup */
+}
+static u_char key_speakup = 0, spk_key_locked = 0;
+
+static void
+speakup_lock (struct vc_data *vc )
+{
+	if ( !spk_key_locked )
+		spk_key_locked = key_speakup = 16;
+	else spk_key_locked = key_speakup = 0;
+}
+
+typedef void (*spkup_hand )(struct vc_data * );
+spkup_hand spkup_handler[] = { /* must be ordered same as defines in speakup.h */
+	do_nothing, speakup_goto, speech_kill, speakup_shut_up,
+	speakup_cut, speakup_paste, say_first_char, say_last_char,
+	say_char, say_prev_char, say_next_char,
+	say_word, say_prev_word, say_next_word,
+	say_line, say_prev_line, say_next_line,
+	top_edge, bottom_edge, left_edge, right_edge,
+	        spell_word, spell_word, say_screen,
+	say_position, say_attributes,
+	speakup_off, speakup_parked, say_line, // this is for indent
+	say_from_top, say_to_bottom,
+	say_from_left, say_to_right,
+	say_char_num, speakup_bits, speakup_bits, say_phonetic_char,
+	speakup_bits, speakup_bits, speakup_bits,
+	speakup_win_set, speakup_win_clear, speakup_win_enable, speakup_win_say,
+	speakup_lock, speakup_help, toggle_cursoring, read_all_doc,  NULL
+};
+
+void do_spkup( struct vc_data *vc,u_char value )
+{
+	if (spk_killed && value != SPEECH_KILL ) return;
+	spk_keydown = 0;
+	spk_lastkey = 0;
+	spk_shut_up &= 0xfe;
+	this_speakup_key = value;
+	if (value < SPKUP_MAX_FUNC && spkup_handler[value] ) {
+		do_flush( );
+		(*spkup_handler[value] )(vc );
+	} else {
+		if ( inc_dec_var( value ) < 0 )
+			bleep( 9 );
+	}
+}
+
+	static const char *pad_chars = "0123456789+-*/\015,.?()";
+
+int
+speakup_key (struct vc_data *vc, int shift_state, int keycode, u_short keysym, int up_flag, struct pt_regs *regs )
+{
+	int kh;
+	u_char *key_info;
+	u_char type = KTYP( keysym ), value = KVAL( keysym ), new_key = 0;
+	u_char shift_info, offset;
+	tty = vc->vc_tty;
+	if ( synth == NULL ) return 0;
+	if ( type >= 0xf0 ) type -= 0xf0;
+	if ( type == KT_PAD && (vc_kbd_led(kbd , VC_NUMLOCK ) ) ) {
+		if ( up_flag ) {
+			spk_keydown = 0;
+			return 0;
+		}
+		value = spk_lastkey = pad_chars[value];
+		spk_keydown++;
+		spk_parked &= 0xfe;
+		goto no_map;
+	}
+	if ( keycode >= MAX_KEY ) goto no_map;
+	if ( ( key_info = our_keys[keycode] ) == 0 ) goto no_map;
+	// Check valid read all mode keys
+        if ( (cursor_track==read_all_mode) && ( !up_flag ))
+	{
+                switch (value)
+                {
+                        case KVAL(K_DOWN):
+                        case KVAL(K_UP):
+                        case KVAL(K_LEFT):
+                        case KVAL(K_RIGHT):
+                        case KVAL(K_PGUP):
+                        case KVAL(K_PGDN):
+                                break;
+                        default:
+				stop_read_all(vc);
+                                break;
+                }
+	}
+	shift_info = ( shift_state&0x0f ) + key_speakup;
+	offset = shift_table[shift_info];
+	if ( offset && ( new_key = key_info[offset] ) ) {
+		if ( new_key == SPK_KEY ) {
+			if ( !spk_key_locked )
+				key_speakup = ( up_flag ) ? 0 : 16;
+			if ( up_flag || spk_killed ) return 1;
+			spk_shut_up &= 0xfe;
+			do_flush( );
+			return 1;
+		}
+		if ( up_flag ) return 1;
+		if ( last_keycode == keycode && last_spk_jiffy+MAX_DELAY > jiffies ) {
+			spk_close_press = 1;
+			offset = shift_table[shift_info+32];
+/* double press? */
+			if ( offset && key_info[offset] )
+				new_key = key_info[offset];
+		}
+		last_keycode = keycode;
+		last_spk_jiffy = jiffies;
+		type = KT_SPKUP;
+		value = new_key;
+	}
+no_map:
+	if ( type == KT_SPKUP && special_handler == NULL ) {
+		do_spkup( vc, new_key );
+		spk_close_press = 0;
+		return 1;
+	}
+	if ( up_flag || spk_killed || type == KT_SHIFT ) return 0;
+	spk_shut_up &= 0xfe;
+	kh=(value==KVAL(K_DOWN))||(value==KVAL(K_UP))||(value==KVAL(K_LEFT))||(value==KVAL(K_RIGHT));
+	if ((cursor_track != read_all_mode) || !kh)
+		if (!no_intr ) do_flush( );
+	if ( special_handler ) {
+		int status;
+		if ( type == KT_SPEC && value == 1 ) {
+			value = '\n';
+			type = KT_LATIN;
+		} else if ( type == KT_LETTER ) type = KT_LATIN;
+		else if ( value == 0x7f ) value = 8; /* make del = backspace */
+		status = (*special_handler)(vc, type, value, keycode );
+		spk_close_press = 0;
+		if ( status < 0 ) bleep( 9 );
+		return status;
+	}
+	last_keycode = 0;
+	return 0;
+}
+
+#ifdef MODULE
+
+extern void speakup_remove(void);
+extern void speakup_set_addresses ( spk_con_func, spk_con_func, spk_write_func, spk_con_func, spk_key_func);
+
+static void __exit mod_speakup_exit(void)
+{
+	int i;
+
+	key_handler[KT_LATIN] = do_latin;
+	key_handler[KT_SPEC] = do_spec;
+	key_handler[KT_CUR] = do_cursor;
+	key_handler[KT_SHIFT] = do_shift;
+	speakup_set_addresses(NULL, NULL, NULL, NULL, NULL);
+	synth_release();
+	speakup_remove();
+	for(i = 0; i < 256; i++) {
+		if (characters[i] != default_chars[i])
+			kfree(characters[i]);
+	}
+	for(i = 0; speakup_console[i]; i++) {
+	  kfree(speakup_console[i]);
+	  speakup_console[i] = NULL;
+	}
+}
+
+static int __init mod_speakup_init( void )
+{
+int i;
+	spk_t *first_console = (spk_t *) kmalloc (spk_size + 1, GFP_KERNEL );
+	speakup_open( vc_cons[fg_console].d, first_console );
+for ( i = 0; vc_cons[i].d; i++)
+  speakup_allocate(vc_cons[i].d);
+	speakup_set_addresses( speakup_allocate, speakup_bs,
+		speakup_con_write, speakup_con_update, speakup_key );
+	speakup_dev_init();
+	return 0;
+}
+
+module_init( mod_speakup_init );
+module_exit( mod_speakup_exit );
+
+#endif
diff --git a/drivers/char/speakup/speakup_acnt.h b/drivers/char/speakup/speakup_acnt.h
new file mode 100644
index 0000000000..4c27f4dcaf
--- /dev/null
+++ b/drivers/char/speakup/speakup_acnt.h
@@ -0,0 +1,16 @@
+/* speakup_acntpc.h - header file for speakups Accent-PC driver. */
+
+#define SYNTH_IO_EXTENT	0x02
+
+#define SYNTH_CLEAR 0x18		/* stops speech */
+
+	/* Port Status Flags */
+#define SYNTH_READABLE     0x01	/* mask for bit which is nonzero if a
+				   byte can be read from the data port */
+#define SYNTH_WRITABLE     0x02	/* mask for RDY bit, which when set to
+             			   1, indicates the data port is ready
+             			   to accept a byte of data. */
+#define SYNTH_QUIET      'S' /* synth is not speaking */
+#define SYNTH_FULL  'F' /* synth is full. */
+#define SYNTH_ALMOST_EMPTY 'M' /* synth has les than 2 seconds of text left */
+#define SYNTH_SPEAKING 's' /* synth is speaking and has a fare way to go */
diff --git a/drivers/char/speakup/speakup_acntpc.c b/drivers/char/speakup/speakup_acntpc.c
new file mode 100644
index 0000000000..260b03231e
--- /dev/null
+++ b/drivers/char/speakup/speakup_acntpc.c
@@ -0,0 +1,161 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "speakup_acnt.h" /* local header file for Accent values */
+
+#define MY_SYNTH synth_acntpc
+#define synth_readable( ) ( inb_p( synth_port_control ) & SYNTH_READABLE )
+#define synth_writable( ) ( inb_p( synth_port_control ) & SYNTH_WRITABLE )
+#define synth_full( ) ( inb_p( synth_port_tts ) == 'F' )
+#define PROCSPEECH '\r'
+
+
+static int synth_port_control;
+static unsigned int synth_portlist[] =
+    { 0x2a8, 0 };
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while (  (  ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+		if ( synth_full( ) )
+			return buf;
+		while ( synth_writable( ) );
+		outb_p( ch, synth_port_tts );
+	buf++;
+	}
+	return 0;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	synth_stop_timer( );
+	while (  synth_buff_out < synth_buff_in ) {
+		if ( synth_full( ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		while ( synth_writable( ) );
+		ch = *synth_buff_out++;
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+		outb_p( ch, synth_port_tts );
+		if ( jiffies >= jiff_max && ch == SPACE ) {
+			while ( synth_writable( ) );
+			outb_p( PROCSPEECH, synth_port_tts );
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	while ( synth_writable( ) );
+	outb_p( PROCSPEECH, synth_port_tts );
+	synth_done(  );
+}
+
+static void synth_flush( void )
+{
+	outb_p( SYNTH_CLEAR, synth_port_tts );
+}
+
+static int synth_probe( void )
+{
+	unsigned int port_val = 0;
+	int i = 0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	if ( synth_port_forced ) {
+		synth_port_tts = synth_port_forced;
+		pr_info( "probe forced to %x by kernel command line\n", synth_port_tts );
+		if ( synth_request_region( synth_port_tts-1, SYNTH_IO_EXTENT ) ) {
+			pr_warn( "sorry, port already reserved\n" );
+			return -EBUSY;
+		}
+		port_val = inw( synth_port_tts-1 );
+		synth_port_control = synth_port_tts-1;
+	} else {
+		for( i=0; synth_portlist[i]; i++ ) {
+			if ( synth_request_region( synth_portlist[i], SYNTH_IO_EXTENT ) ) {
+				pr_warn( "request_region:  failed with 0x%x, %d\n",
+					synth_portlist[i], SYNTH_IO_EXTENT );
+				continue;
+			}
+			port_val = inw( synth_portlist[i] );
+			if ( ( port_val &= 0xfffc ) == 0x53fc ) { /* 'S' and out&input bits */
+				synth_port_control = synth_portlist[i];
+				synth_port_tts = synth_port_control+1;
+				break;
+			}
+		}
+	}
+	if ( ( port_val &= 0xfffc ) != 0x53fc ) { /* 'S' and out&input bits */
+		pr_info( "%s:  not found\n", synth->long_name );
+		synth_release_region( synth_portlist[i], SYNTH_IO_EXTENT );
+		synth_port_control = 0;
+		return -ENODEV;
+	}
+	pr_info( "%s:  %03x-%03x, driver version %s,\n", synth->long_name,
+		synth_port_control,	synth_port_control+SYNTH_IO_EXTENT-1,
+		synth->version );
+	return 0;
+}
+
+static void accent_release(  void )
+{
+	if (  synth_port_tts )
+		synth_release_region( synth_port_tts-1, SYNTH_IO_EXTENT );
+	synth_port_tts = 0;
+}
+
+static int synth_is_alive( void )
+{
+	synth_alive = 1;
+	return 1;
+}
+
+static const char init_string[] = "\033=X \033Oi\033T2\033=M\033N1\n";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\033P8" },
+	{ CAPS_STOP, "\033P5" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\033R%c", 9, 0, 17, 0, 0, "0123456789abcdefgh" },
+	{ PITCH, "\033P%d", 5, 0, 9, 0, 0, 0 },
+	{ VOL, "\033A%d", 5, 0, 9, 0, 0, 0 },
+	{ TONE, "\033V%d", 5, 0, 9, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_acntpc = {"acntpc", "1.1", "Accent PC",
+	 init_string, 500, 50, 50, 1000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, accent_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_acntsa.c b/drivers/char/speakup/speakup_acntsa.c
new file mode 100644
index 0000000000..c73477d820
--- /dev/null
+++ b/drivers/char/speakup/speakup_acntsa.c
@@ -0,0 +1,185 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+#include "speakup_acnt.h"	/* local header file for Accent values */
+
+#define MY_SYNTH synth_acntsa
+#define synth_full( ) ( inb_p( synth_port_tts ) == 'F' )
+#define PROCSPEECH '\r'
+
+static int timeouts = 0;	/* sequential number of timeouts */
+
+static int
+wait_for_xmitr ( void )
+{
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		return 0;
+	}
+	do { /* holding register empty? */
+		check = inb_p ( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn ( "%s:  timed out\n", synth->long_name );
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do { /* CTS */
+		check = inb_p ( synth_port_tts + UART_MSR );
+		if ( --tmout == 0 ) {
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int
+spk_serial_out ( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr ( ) ) {
+		outb_p ( ch, synth_port_tts );
+		return 1;
+	}
+	return 0;
+}
+
+static void
+do_catch_up ( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	synth_stop_timer ( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+	if ( ch == 0x0a ) ch = 0x0D;
+		if ( !spk_serial_out ( ch ) ) {
+			synth_delay ( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( jiffies >= jiff_max && ch == ' ' ) {
+			spk_serial_out ( PROCSPEECH );
+			synth_delay ( synth_delay_time );
+			return;
+		}
+	}
+	spk_serial_out ( PROCSPEECH );
+	synth_done( );
+}
+
+static const char *synth_immediate ( const char *buff )
+{
+	u_char ch;
+	while ( ( ch = *buff ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+          outb( ch, synth_port_tts );
+        else return buff;
+	buff++;
+	}
+	return 0;
+}
+
+static void synth_flush ( void )
+{
+	spk_serial_out ( SYNTH_CLEAR );
+}
+
+static int serprobe ( int index )
+{
+	struct serial_state *ser = spk_serial_init( index );
+	if ( ser == NULL ) return -1;
+	outb ( 0x0d, ser->port );
+	//	mdelay ( 1 );
+	/* ignore any error results, if port was forced */
+	if ( synth_port_forced ) return 0;
+	/* check for accent s.a now... */
+	if ( !synth_immediate( "\x18" ) )
+		return 0;
+	spk_serial_release( );
+	timeouts = synth_alive = 0;	/* not ignoring */
+	return -1;
+}
+
+static int synth_probe ( void )
+{
+	int i = 0, failed=0;
+	pr_info ( "Probing for %s.\n", synth->long_name );
+	for ( i = SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+        }
+        if ( failed ) {
+		pr_info ( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info ( "%s: %03x-%03x, Driver Version %s,\n", synth->long_name,
+		synth_port_tts, synth_port_tts + 7, synth->version );
+	synth_immediate( "\033=R\r" );
+	mdelay( 100 );
+	return 0;
+}
+
+static int
+synth_is_alive ( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive && wait_for_xmitr ( ) > 0 ) {	/* restart */
+		synth_alive = 1;
+		synth_write_string ( synth->init );
+		return 2;
+	}
+	pr_warn ( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "\033T2\033=M\033Oi\033N1\n";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\033P8" },
+	{ CAPS_STOP, "\033P5" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\033R%c", 9, 0, 17, 0, 0, "0123456789abcdefgh" },
+	{ PITCH, "\033P%d", 5, 0, 9, 0, 0, 0 },
+	{ VOL, "\033A%d", 9, 0, 9, 0, 0, 0 },
+	{ TONE, "\033V%d", 5, 0, 9, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_acntsa = { "acntsa", "1.1", "Accent-SA",
+	init_string, 400, 5, 30, 1000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_apollo.c b/drivers/char/speakup/speakup_apollo.c
new file mode 100644
index 0000000000..6b6c842803
--- /dev/null
+++ b/drivers/char/speakup/speakup_apollo.c
@@ -0,0 +1,196 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#define MY_SYNTH synth_apollo
+#define SYNTH_CLEAR 0x18
+#define PROCSPEECH '\r'
+
+static int timeouts = 0;	/* sequential number of timeouts */
+
+static int wait_for_xmitr( void )
+{
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do {
+		check = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn( "APOLLO:  timed out\n" );
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do {
+		check = inb( synth_port_tts + UART_MSR );
+				if ( --tmout == 0 ) {
+					timeouts++;
+					return 0;
+				}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out( const char ch )
+{
+ // int timer = 9000000;
+	if ( synth_alive && wait_for_xmitr( ) ) {
+		outb( ch, synth_port_tts );
+		/*while ( inb( synth_port_tts+UART_MSR ) & UART_MSR_CTS ) if ( --timer == 0 ) break;*/
+		/*    outb( UART_MCR_DTR, synth_port_tts + UART_MCR );*/
+		return 1;
+	}
+	return 0;
+}
+
+/*
+static unsigned char spk_serial_in( void )
+{
+	int c, lsr, tmout = SPK_SERIAL_TIMEOUT;
+	do {
+		lsr = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) return 0xff;
+	} while ( !( lsr & UART_LSR_DR ) );
+	c = inb( synth_port_tts + UART_RX );
+	return ( unsigned char ) c;
+}
+*/
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( !spk_serial_out( ch ) ) {
+			outb( UART_MCR_DTR, synth_port_tts + UART_MCR );
+			outb( UART_MCR_DTR | UART_MCR_RTS, synth_port_tts + UART_MCR );
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( jiffies >= jiff_max && synth_buff_out-synth_buffer > 10 ) {
+		spk_serial_out( PROCSPEECH );
+		synth_delay( synth_delay_time );
+		return;
+		}
+	}
+	spk_serial_out( PROCSPEECH );
+	synth_done( );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+	  outb( ch, synth_port_tts );
+	else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush ( void )
+{
+	spk_serial_out ( SYNTH_CLEAR );
+}
+
+static int serprobe( int index )
+{
+	struct serial_state *ser = spk_serial_init( index );
+	if ( ser == NULL ) return -1;
+	outb( 0x0d, ser->port ); /* wake it up if older BIOS */
+	mdelay( 1 );
+	synth_port_tts = ser->port;
+	if ( synth_port_forced ) return 0;
+	/* check for apollo now... */
+	if ( !synth_immediate( "\x18" ) ) return 0;
+	pr_warn( "port %x failed\n", synth_port_tts );
+	spk_serial_release( );
+	timeouts = synth_alive = synth_port_tts = 0;
+	return -1;
+}
+
+static int synth_probe( void )
+{
+int i, failed=0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	for ( i=SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+	}
+	if ( failed ) {
+		pr_info( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info( "%s:  %03x-%03x, Driver version %s,\n", synth->long_name,
+	 synth_port_tts, synth_port_tts + 7, synth->version );
+	return 0;
+}
+
+static int synth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive && wait_for_xmitr( ) > 0 ) { /* restart */
+		synth_alive = 1;
+		synth_write_string( synth->init );
+		return 2;  /* reenabled */
+	} else pr_warn( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "@R3@D0@K1\r";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "cap, " },
+	{ CAPS_STOP, "" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "@W%d", 6, 1, 9, 0, 0, 0 },
+	{ PITCH, "@F%x", 10, 0, 15, 0, 0, 0 },
+	{ VOL, "@A%x", 10, 0, 15, 0, 0, 0 },
+	{ VOICE, "@V%d", 1, 1, 6, 0, 0, 0 },
+	{ LANG, "@=%d,", 1, 1, 4, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_apollo = {"apollo", "1.2", "Apollo",
+	init_string, 500, 50, 50, 5000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_audptr.c b/drivers/char/speakup/speakup_audptr.c
new file mode 100644
index 0000000000..7149568705
--- /dev/null
+++ b/drivers/char/speakup/speakup_audptr.c
@@ -0,0 +1,202 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#define MY_SYNTH synth_audptr
+#define SYNTH_CLEAR 0x18 /* flush synth buffer */
+#define PROCSPEECH '\r' /* start synth processing speech char */
+
+static int timeouts = 0;	/* sequential number of timeouts */
+
+static int wait_for_xmitr( void )
+{
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do { /* holding register empty? */
+		check = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn( "%s:  timed out\n", synth->long_name );
+		  timeouts++;
+		  return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do { /* CTS */
+		check = inb( synth_port_tts + UART_MSR );
+		if ( --tmout == 0 ) {
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr( ) ) {
+		outb( ch, synth_port_tts );
+		return 1;
+	}
+	return 0;
+}
+
+static unsigned char spk_serial_in( void )
+{
+	int c, lsr, tmout = SPK_SERIAL_TIMEOUT;
+	do {
+		lsr = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) return 0xff;
+	} while ( !( lsr & UART_LSR_DR ) );
+	c = inb( synth_port_tts + UART_RX );
+	return ( unsigned char ) c;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == 0x0a ) ch = PROCSPEECH;
+		if ( !spk_serial_out( ch ) ) {
+		  	synth_delay( synth_full_time );
+		  	return;
+		}
+		synth_buff_out++;
+		if ( jiffies >= jiff_max && ch == SPACE ) {
+		  	spk_serial_out( PROCSPEECH );
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	spk_serial_out( PROCSPEECH );
+	synth_done( );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+          outb( ch, synth_port_tts );
+        else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush( void )
+{
+	while ( ( inb( synth_port_tts + UART_LSR ) & BOTH_EMPTY ) != BOTH_EMPTY );
+	outb( SYNTH_CLEAR, synth_port_tts );
+		  spk_serial_out( PROCSPEECH );
+		}
+
+static char synth_id[40] = "";
+
+static int serprobe( int index )
+{
+	u_char test = 0;
+	struct serial_state *ser = spk_serial_init( index );
+	if ( ser == NULL ) return -1;
+	/* ignore any error results, if port was forced */
+	if ( synth_port_forced )
+		return 0;
+	synth_immediate( "\x05[Q]" );
+	if ( ( synth_id[test] = spk_serial_in( ) ) == 'A' ) {
+		do { /* read version string from synth */
+		  synth_id[++test] = spk_serial_in( );
+		} while ( synth_id[test] != '\n' && test < 32 );
+		synth_id[++test] = 0x00;
+		if ( test != 32 )
+		  return 0;
+	}
+	spk_serial_release( );
+		    timeouts = synth_alive = 0; /* not ignoring */
+		    return -1;
+}
+
+static int synth_probe( void )
+{
+int i=0, failed=0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	for ( i=SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+	}
+	if ( failed ) {
+		pr_info( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info( "%s:  %03x-%03x, Driver %s,\n", synth->long_name,
+	 synth_port_tts, synth_port_tts + 7, synth->version );
+	if ( synth_id[0] == 'A' )
+	  pr_info( "%s version: %s", synth->long_name, synth_id );
+		return 0;
+}
+
+static int synth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive && wait_for_xmitr( ) > 0 ) { /* restart */
+		synth_alive = 1;
+		synth_write_string( synth->init );
+		return 2;
+	}
+	return 0;
+}
+
+static const char init_string[] = "\x05[D1]\x05[Ol]";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x05[f99]" },
+	{ CAPS_STOP, "\x05[f80]" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\x05[r%d]", 10, 0, 20, -100, 10, 0 },
+	{ PITCH, "\x05[f%d]", 80, 39, 4500, 0, 0, 0 },
+	{ VOL, "\x05[g%d]", 21, 0, 40, 0, 0, 0 },
+	{ TONE, "\x05[s%d]", 9, 0,63, 0, 0, 0 },
+	{ PUNCT, "\x05[A%c]", 0, 0, 3, 0, 0, "nmsa" },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_audptr = {"audptr", "1.1", "Audapter",
+	 init_string, 400, 5, 30, 5000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_bns.c b/drivers/char/speakup/speakup_bns.c
new file mode 100644
index 0000000000..36acbc2cc7
--- /dev/null
+++ b/drivers/char/speakup/speakup_bns.c
@@ -0,0 +1,175 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#define MY_SYNTH synth_bns
+#define SYNTH_CLEAR 0x18
+#define PROCSPEECH '\r'
+
+static int wait_for_xmitr( void )
+{
+	static int timeouts = 0;	/* sequential number of timeouts */
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do {
+		check = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+		 	pr_warn( "BNS:  timed out\n" );
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do {
+		check = inb( synth_port_tts + UART_MSR );
+		if ( --tmout == 0 ) {
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr( ) ) {
+		outb( ch, synth_port_tts );
+		return 1;
+	}
+	return 0;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == '\n' ) ch = PROCSPEECH;
+		if ( !spk_serial_out( ch ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( jiffies >= jiff_max && ch == ' ' ) {
+			spk_serial_out( PROCSPEECH );
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	spk_serial_out( PROCSPEECH );
+	synth_done( );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+          outb( ch, synth_port_tts );
+        else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush ( void )
+{
+	spk_serial_out ( SYNTH_CLEAR );
+}
+
+static int serprobe( int index )
+{
+	struct serial_state *ser = spk_serial_init( index );
+	if ( ser == NULL ) return -1;
+	outb( '\r', ser->port );
+	if ( synth_port_forced ) return 0;
+	/* check for bns now... */
+	if ( !synth_immediate( "\x18" ) ) return 0;
+	spk_serial_release( );
+	synth_alive = 0;
+				return -1;
+}
+
+static int synth_probe( void )
+{
+int i=0, failed=0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	for ( i=SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+        }
+        if ( failed ) {
+		pr_info( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info( "%s:  %03x-%03x, Driver version %s,\n", synth->long_name,
+		synth_port_tts, synth_port_tts + 7, synth->version );
+	return 0;
+}
+
+static int synth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive && wait_for_xmitr( ) > 0 ) { /* restart */
+		synth_alive = 1;
+		synth_write_string( synth->init );
+		return 2;
+	}
+	pr_warn( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "\x05Z\x05\x43";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x05\x31\x32P" },
+	{ CAPS_STOP, "\x05\x38P" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\x05%dE", 8, 1, 16, 0, 0, 0 },
+	{ PITCH, "\x05%dP", 8, 0, 16, 0, 0, 0 },
+	{ VOL, "\x05%dV", 8, 0, 16, 0, 0, 0 },
+	{ TONE, "\x05%dT", 8, 0, 16, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_bns = {"bns", "1.1", "Braille 'N Speak",
+	init_string, 500, 50, 50, 5000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_decext.c b/drivers/char/speakup/speakup_decext.c
new file mode 100644
index 0000000000..e7f939866f
--- /dev/null
+++ b/drivers/char/speakup/speakup_decext.c
@@ -0,0 +1,206 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#define MY_SYNTH synth_decext
+#define SYNTH_CLEAR 0x03
+#define PROCSPEECH 0x0b
+#define synth_full( ) ( inb_p( synth_port_tts ) == 0x13 )
+
+static int timeouts = 0;
+static int in_escape = 0;
+
+static int wait_for_xmitr ( void )
+{
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do { /* holding register empty? */
+		check = inb_p( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn ( "%s:  timed out\n", synth->long_name );
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do { /* CTS */
+		check = inb_p ( synth_port_tts + UART_MSR );
+		if ( --tmout == 0 ) {
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out ( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr ( ) ) {
+		outb_p ( ch, synth_port_tts );
+		return 1;
+	}
+	return 0;
+}
+
+static u_char
+spk_serial_in ( void )
+{
+	int lsr, tmout = SPK_SERIAL_TIMEOUT, c;
+	do {
+		lsr = inb_p ( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 )
+			return 0xff;
+	} while ( !( lsr & UART_LSR_DR ) );
+	c = inb_p ( synth_port_tts + UART_RX );
+	return ( u_char ) c;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+static u_char last='\0';
+	synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == '\n' ) ch = 0x0D;
+		if ( synth_full( ) || !spk_serial_out( ch ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( ch == '[' ) in_escape = 1;
+		else if ( ch == ']' ) in_escape = 0;
+		else if ( ch <= SPACE ) {
+			if ( !in_escape && strchr( ",.!?;:", last ) )
+				spk_serial_out( PROCSPEECH );
+			if ( jiffies >= jiff_max ) {
+				if ( !in_escape )
+					spk_serial_out( PROCSPEECH );
+				synth_delay( synth_delay_time );
+				return;
+			}
+		}
+		last = ch;
+	}
+	if ( synth_done( ) || !in_escape )
+	spk_serial_out( PROCSPEECH );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+          outb( ch, synth_port_tts );
+        else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush( void )
+{
+	in_escape = 0;
+	synth_immediate( "\033P;10z\033\\" );
+}
+
+static int serprobe( int index )
+{
+		u_char test=0;
+		struct serial_state *ser = spk_serial_init( index );
+		if ( ser == NULL ) return -1;
+		/* ignore any error results, if port was forced */
+	if ( synth_port_forced )
+				return 0;
+	synth_immediate( "\033[;5n\033\\" );
+	if ( ( test = spk_serial_in( ) ) == '\033' )
+		return 0;
+	spk_serial_release( );
+	timeouts = synth_alive = synth_port_tts = 0; /* not ignoring */
+	return -1;
+}
+
+static int synth_probe( void )
+{
+	int i=0, failed=0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+		/* check ttyS0-ttyS3 */
+	for ( i=SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+        }
+        if ( failed ) {
+		pr_info( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info( "%s: %03x-%03x, Driver Version %s,\n", synth->long_name,
+		synth_port_tts, synth_port_tts+7, synth->version );
+	return 0;
+}
+
+static int synth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive&& wait_for_xmitr( ) > 0 ) { /* restart */
+		synth_alive = 1;
+		synth_write_string( synth->init );
+		return 2;
+	}
+	pr_warn( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "[:pe -380]";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "[:dv ap 222]" },
+	{ CAPS_STOP, "[:dv ap 100]" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "[:ra %d]", 7, 0, 9, 150, 25, 0 },
+	{ PITCH, "[:dv ap %d]", 100, 0, 100, 0, 0, 0 },
+	{ VOL, "[:dv gv %d]", 13, 0, 16, 0, 5, 0 },
+	{ PUNCT, "[:pu %c]", 0, 0, 2, 0, 0, "nsa" },
+	{ VOICE, "[:n%c]", 0, 0, 9, 0, 0, "phfdburwkv" },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_decext = {"decext", "1.1", "Dectalk External",
+	 init_string, 500, 50, 50, 1000, 0, SF_DEC, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_decpc.c b/drivers/char/speakup/speakup_decpc.c
new file mode 100644
index 0000000000..87c6eabdcd
--- /dev/null
+++ b/drivers/char/speakup/speakup_decpc.c
@@ -0,0 +1,243 @@
+/*
+* written by David Borowski, david575@golden.net
+
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "dtpc_reg.h"
+
+#define MY_SYNTH synth_dec_pc
+#define PROCSPEECH 0x0b
+#define SYNTH_IO_EXTENT 8
+
+static int synth_portlist[] = { 0x340, 0x350, 0x240, 0x250, 0 };
+static int in_escape = 0, is_flushing = 0;
+static int dt_stat, dma_state = 0;
+
+static inline int dt_getstatus( void )
+{
+	dt_stat =  inb_p( synth_port_tts )|(inb_p( synth_port_tts+1 )<<8);
+	return dt_stat;
+}
+
+static inline void dt_sendcmd( u_int cmd )
+{
+	outb_p( cmd & 0xFF, synth_port_tts );
+	outb_p( (cmd>>8) & 0xFF, synth_port_tts+1 );
+}
+
+static int dt_waitbit( int bit )
+{
+	int timeout = 100;
+	while ( --timeout > 0 ) {
+		if( (dt_getstatus( ) & bit ) == bit ) return 1;
+		udelay( 50 );
+	}
+	return 0;
+}
+
+static int dt_wait_dma( void )
+{
+	int timeout = 100, state = dma_state;
+	if( ! dt_waitbit( STAT_dma_ready ) ) return 0;
+	while ( --timeout > 0 ) {
+		if( (dt_getstatus()&STAT_dma_state) == state ) return 1;
+		udelay( 50 );
+	}
+	dma_state = dt_getstatus( ) & STAT_dma_state;
+	return 1;
+}
+
+int dt_ctrl( u_int cmd )
+{
+	int timeout = 10;
+	if ( !dt_waitbit( STAT_cmd_ready ) ) return -1;
+	outb_p( 0, synth_port_tts+2 );
+	outb_p( 0, synth_port_tts+3 );
+	dt_getstatus( );
+	dt_sendcmd( CMD_control|cmd );
+	outb_p( 0, synth_port_tts+6 );
+	while ( dt_getstatus( ) & STAT_cmd_ready ) {
+		udelay( 20 );
+		if ( --timeout == 0 ) break;
+	}
+	dt_sendcmd( CMD_null );
+	return 0;
+}
+
+static void synth_flush( void )
+{
+	int timeout = 10;
+	if ( is_flushing ) return;
+	is_flushing = 4;
+	in_escape = 0;
+	while ( dt_ctrl( CTRL_flush ) ) {
+		if ( --timeout == 0 ) break;
+udelay( 50 );
+	}
+	for ( timeout = 0; timeout < 10; timeout++ ) {
+		if ( dt_waitbit( STAT_dma_ready ) ) break;
+udelay( 50 );
+	}
+	outb_p( DMA_sync, synth_port_tts+4 );
+	outb_p( 0, synth_port_tts+4 );
+	udelay( 100 );
+	for ( timeout = 0; timeout < 10; timeout++ ) {
+		if ( !( dt_getstatus( ) & STAT_flushing ) ) break;
+udelay( 50 );
+	}
+	dma_state = dt_getstatus( ) & STAT_dma_state;
+	dma_state ^= STAT_dma_state;
+	is_flushing = 0;
+}
+
+static int dt_sendchar( char ch )
+{
+	if( ! dt_wait_dma( ) ) return -1;
+	if( ! (dt_stat & STAT_rr_char) ) return -2;
+	outb_p( DMA_single_in, synth_port_tts+4 );
+	outb_p( ch, synth_port_tts+4 );
+	dma_state ^= STAT_dma_state;
+	return 0;
+}
+
+static int testkernel( void )
+{
+	int status = 0;
+	if ( dt_getstatus( ) == 0xffff ) {
+		status = -1;
+		goto oops;
+	}
+	dt_sendcmd( CMD_sync );
+	if( ! dt_waitbit( STAT_cmd_ready ) ) status = -2;
+	else if ( ( dt_stat&0x8000 ) ) {
+		return 0;
+	} else if ( dt_stat == 0x0dec )
+		pr_warn( "dec_pc at 0x%x, software not loaded\n", synth_port_tts );
+	status = -3;
+oops:	synth_release_region( synth_port_tts, SYNTH_IO_EXTENT );
+	synth_port_tts = 0;
+	return status;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+static u_char last='\0';
+	synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == '\n' ) ch = 0x0D;
+		if ( dt_sendchar( ch ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( ch == '[' ) in_escape = 1;
+		else if ( ch == ']' ) in_escape = 0;
+		else if ( ch <= SPACE ) {
+			if ( !in_escape && strchr( ",.!?;:", last ) )
+				dt_sendchar( PROCSPEECH );
+			if ( jiffies >= jiff_max ) {
+				if ( !in_escape )
+					dt_sendchar( PROCSPEECH );
+				synth_delay( synth_delay_time );
+				return;
+			}
+		}
+		last = ch;
+	}
+	if ( synth_done( ) || !in_escape )
+	dt_sendchar( PROCSPEECH );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+		if ( dt_sendchar ( ch ) )
+			return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static int synth_probe ( void )
+{
+	int i=0, failed=0;
+	pr_info ( "Probing for %s.\n", synth->long_name );
+	for( i=0; synth_portlist[i]; i++ ) {
+		if ( synth_request_region( synth_portlist[i], SYNTH_IO_EXTENT ) ) {
+			pr_warn( "request_region:  failed with 0x%x, %d\n",
+				synth_portlist[i], SYNTH_IO_EXTENT );
+			continue;
+		}
+		synth_port_tts = synth_portlist[i];
+		if (( failed = testkernel( )) == 0 ) break;
+	}
+	if ( failed ) {
+		pr_info ( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info ( "%s: %03x-%03x, Driver Version %s,\n", synth->long_name,
+		synth_port_tts, synth_port_tts + 7, synth->version );
+	return 0;
+}
+
+static void dtpc_release(  void )
+{
+	if (  synth_port_tts )
+		synth_release_region( synth_port_tts, SYNTH_IO_EXTENT );
+	synth_port_tts = 0;
+}
+
+static int synth_is_alive( void )
+{
+	synth_alive = 1;
+	return 1;
+}
+
+static const char init_string[] = "[:pe -380]";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "[:dv ap 200]" },
+	{ CAPS_STOP, "[:dv ap 100]" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "[:ra %d]", 9, 0, 18, 150, 25, 0 },
+	{ PITCH, "[:dv ap %d]", 80, 0, 100, 20, 0, 0 },
+	{ VOL, "[:vo se %d]", 5, 0, 9, 5, 10, 0 },
+	{ PUNCT, "[:pu %c]", 0, 0, 2, 0, 0, "nsa" },
+	{ VOICE, "[:n%c]", 0, 0, 9, 0, 0, "phfdburwkv" },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_dec_pc = { "decpc", "1.1", "Dectalk PC",
+	init_string, 500, 50, 50, 1000, 0, SF_DEC, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, dtpc_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_dectlk.c b/drivers/char/speakup/speakup_dectlk.c
new file mode 100644
index 0000000000..a3e5f49973
--- /dev/null
+++ b/drivers/char/speakup/speakup_dectlk.c
@@ -0,0 +1,285 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+#include <linux/unistd.h>
+#include <linux/proc_fs.h>
+
+#define MY_SYNTH synth_dectlk
+#define SYNTH_CLEAR 0x03
+#define PROCSPEECH 0x0b
+#define synth_full( )  ( inb_p( synth_port_tts ) == 0x13 )
+
+static int timeouts = 0;
+static int in_escape = 0, is_flushing = 0;
+atomic_t dectest=ATOMIC_INIT(0);
+
+static int wait_for_xmitr ( void )
+{
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do { /* holding register empty? */
+		check = inb_p( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn ( "%s:  timed out\n", synth->long_name );
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	//} while ( ( check & UART_LSR_THRE ) != UART_LSR_THRE );
+	tmout = SPK_XMITR_TIMEOUT;
+	do { /* CTS */
+		check = inb_p ( synth_port_tts + UART_MSR );
+		if ( --tmout == 0 ) {
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out ( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr ( ) ) {
+		outb_p ( ch, synth_port_tts );
+
+		return 1;
+	}
+	return 0;
+}
+
+/*static u_char
+spk_serial_in ( void )
+{
+	int c = 0;
+
+	while (inb_p(synth_port_tts + UART_LSR) & UART_LSR_DR) {
+		c = inb_p(synth_port_tts+UART_RX);
+	}
+	return (u_char) c;
+}*/
+
+int is_indnum(u_char *ch)
+{
+	if ((*ch>47)&&(*ch<58))
+	{
+		*ch=*ch-48;
+		return 1;
+	}
+	return 0;
+}
+
+static const char *synth_immediate (const char *);
+
+u_char lastind=0;
+
+static unsigned char get_index( void )
+{
+	u_char rv;
+	rv=lastind;
+	lastind=0;
+	return rv;
+}
+
+void read_buff_add(u_char c)
+{
+	static int ind=-1;
+
+	if (c==0x01)
+	{
+		is_flushing=0;
+		atomic_set(&dectest,0);
+	}
+	else if (is_indnum(&c))
+	{
+		if (ind==-1)
+			ind=c;
+		else
+			ind=ind*10+c;
+	}
+	else if ((c>31) && (c<127))
+	{
+		if (ind!=-1)
+			lastind=(u_char)ind;
+		ind=-1;
+	}
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	static u_char last='\0';
+	synth_stop_timer( );
+	if (is_flushing)
+	{
+		if (--is_flushing == 0 )
+			pr_warn ( "flush timeout\n" );
+		else
+		{
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == '\n' ) ch = 0x0D;
+		if ( synth_full( ) || !spk_serial_out( ch ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( ch == '[' ) in_escape = 1;
+		else if ( ch == ']' ) in_escape = 0;
+		else if ( ch <= SPACE ) {
+			if ( !in_escape && strchr( ",.!?;:", last ) )
+				spk_serial_out( PROCSPEECH );
+			if ( jiffies >= jiff_max ) {
+				if ( !in_escape )
+					spk_serial_out( PROCSPEECH );
+				synth_delay( synth_delay_time );
+				return;
+			}
+		}
+		last = ch;
+	}
+	if ( synth_done( ) || !in_escape )
+	spk_serial_out( PROCSPEECH );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+          outb( ch, synth_port_tts );
+        else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush( void )
+{
+	if (in_escape)
+	{
+		// if in command output ']' so we don't get an error
+		spk_serial_out( ']' );
+	}
+	in_escape = 0;
+	spk_serial_out ( SYNTH_CLEAR );
+	is_flushing = 5; /* if no ctl-a in 4, send data anyway */
+}
+
+static int serprobe ( int index )
+{
+	struct serial_state *ser = spk_serial_init( index );
+	//u_char test;//, timeout = 10000;
+	int timeout=1000000;
+	if ( ser == NULL ) return -1;
+	outb ( 0x0d, ser->port );
+	/* ignore any error results, if port was forced */
+	if ( synth_port_forced ) return 0;
+	/* check for dectalk express now... */
+
+	atomic_set(&dectest,5);
+	if ( !synth_immediate ( "\x03" ) ) {
+		/*do {
+			test = spk_serial_in ( );
+			if ( test == 0x01 ) return 0;
+		} while ( --timeout > 0 );*/
+
+		do {
+			if ( atomic_read(&dectest)==0) return 0;
+			outb('a',0x80);  // Sleep about a microsecond
+		} while ( --timeout > 0);
+
+	}
+	spk_serial_release( );
+	timeouts = synth_alive = synth_port_tts = 0;	/* not ignoring */
+	return -1;
+}
+
+static int synth_probe ( void )
+{
+	int i = 0, failed=0;
+	pr_info ( "Probing for %s.\n", synth->long_name );
+	/* check ttyS0-ttyS3 */
+	for ( i = SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+        }
+        if ( failed ) {
+		pr_info ( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info ( "%s: %03x-%03x, Driver Version %s,\n", synth->long_name,
+		synth_port_tts, synth_port_tts + 7, synth->version );
+	return 0;
+}
+
+static int
+synth_is_alive ( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive && wait_for_xmitr ( ) > 0 ) {	/* restart */
+		synth_alive = 1;
+		synth_write_string ( synth->init );
+		return 2;
+	} else
+		pr_warn ( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "[:pe -380][:dv ap 100][:error sp]";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "[:dv ap 200]" },
+	{ CAPS_STOP, "[:dv ap 100]" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "[:ra %d]", 9, 0, 18, 150, 25, 0 },
+	{ PITCH, "[:dv ap %d]", 80, 0, 200, 20, 0, 0 },
+	{ VOL, "[:dv gv %d]", 13, 0, 14, 0, 5, 0 },
+	{ PUNCT, "[:pu %c]", 0, 0, 2, 0, 0, "nsa" },
+	{ VOICE, "[:n%c]", 0, 0, 9, 0, 0, "phfdburwkv" },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_dectlk = { "dectlk", "1.3", "Dectalk Express",
+	init_string, 500, 50, 50, 1000, 0, SF_DEC, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, read_buff_add,
+	get_index, {"[:in re %d] ",1,8,1} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_drvcommon.c b/drivers/char/speakup/speakup_drvcommon.c
new file mode 100644
index 0000000000..bf1606748b
--- /dev/null
+++ b/drivers/char/speakup/speakup_drvcommon.c
@@ -0,0 +1,1007 @@
+#define KERNEL
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/ctype.h>	/* for isdigit( ) and friends */
+#include <linux/fs.h>
+#include <linux/mm.h>		/* for verify_area */
+#include <linux/errno.h>	/* for -EBUSY */
+#include <linux/ioport.h>	/* for check_region, request_region */
+#include <linux/interrupt.h>
+#include <linux/delay.h>	/* for loops_per_sec */
+#include <asm/segment.h>	/* for put_user_byte */
+#include <asm/semaphore.h>
+#include <linux/wait.h>		/* for wait_queue */
+#include <linux/miscdevice.h>	/* for misc_register, and SYNTH_MINOR */
+#include "spk_priv.h"
+#include "serialio.h"
+#include <linux/kmod.h>
+
+static struct serial_state rs_table[] = {
+	SERIAL_PORT_DFNS
+};
+
+#include "synthlist.h"
+static struct spk_synth *synths[16] = {
+#include "synthlist.h"
+	NULL };
+
+#define synthBufferSize 8192	/* currently 8K bytes */
+struct spk_synth *synth = NULL;
+struct spk_synth *module_synth = NULL;
+int synth_port_tts = 0, synth_port_forced = 0;
+volatile int synth_timer_active = 0;	/* indicates when a timer is set */
+	static struct miscdevice synth_device;
+static int misc_registered = 0;
+static char pitch_buff[32] = "";
+static char module_name[32] = "";
+static struct semaphore sem; /* no mo races */
+declare_sleeper( synth_sleeping_list );
+static int module_status = 0;
+declare_timer( synth_timer );
+short synth_delay_time = 500, synth_trigger_time = 50;
+short synth_jiffy_delta = 50, synth_full_time = 1000;
+int synth_alive = 0;
+u_char synth_buffer[synthBufferSize];	/* guess what this is for! */
+u_char *buffer_highwater = synth_buffer+synthBufferSize-100;
+u_char *buffer_end = synth_buffer+synthBufferSize-1;
+volatile u_char *synth_buff_in = synth_buffer, *synth_buff_out = synth_buffer;
+static irqreturn_t synth_readbuf_handler(int irq, void *dev_id,struct pt_regs *);
+struct serial_state *serstate;
+
+struct serial_state *spk_serial_init( int index )
+{
+	int baud = 9600, quot = 0;
+	unsigned int cval = 0;
+	int     i, cflag = CREAD | HUPCL | CLOCAL | B9600 | CS8;
+	struct serial_state *ser = NULL;
+
+	if ( synth_port_forced ) {
+		if ( index > 0 ) return NULL;
+		pr_info ( "probe forced to 0x%x by kernel command line\n",
+			synth_port_forced );
+          for ( i=0; i <= SPK_HI_TTY; i++ )
+            if ( ( rs_table+i )->port == synth_port_forced ) {
+              ser = rs_table+i;
+              break;
+            }
+        } else  ser = rs_table + index;
+	/*	Divisor, bytesize and parity */
+	quot = ser->baud_base / baud;
+	cval = cflag & ( CSIZE | CSTOPB );
+#if defined( __powerpc__ ) || defined( __alpha__ )
+	cval >>= 8;
+#else /* !__powerpc__ && !__alpha__ */
+	cval >>= 4;
+#endif /* !__powerpc__ && !__alpha__ */
+	if ( cflag & PARENB )
+		cval |= UART_LCR_PARITY;
+	if ( !( cflag & PARODD ) )
+		cval |= UART_LCR_EPAR;
+	if ( synth_request_region( ser->port, 8 ) ) { // try to take it back.
+	   __release_region(&ioport_resource, ser->port, 8 );
+	if ( synth_request_region( ser->port, 8 ) ) return NULL;
+	}
+
+	/*	Disable UART interrupts, set DTR and RTS high
+	 *	and set speed. */
+	outb( cval | UART_LCR_DLAB, ser->port + UART_LCR );	/* set DLAB */
+	outb( quot & 0xff, ser->port + UART_DLL );	/* LS of divisor */
+	outb( quot >> 8, ser->port + UART_DLM );		/* MS of divisor */
+	outb( cval, ser->port + UART_LCR );		/* reset DLAB */
+
+	// Turn off Interrupts
+	outb( 0, ser->port + UART_IER );
+	outb( UART_MCR_DTR | UART_MCR_RTS, ser->port + UART_MCR );
+
+	/* If we read 0xff from the LSR, there is no UART here. */
+	if ( inb ( ser->port + UART_LSR ) == 0xff ) {
+		synth_release_region( ser->port, 8 );
+		serstate=NULL;
+		return NULL;
+	}
+
+	mdelay( 1 );
+	synth_port_tts = ser->port;
+	serstate=ser;
+
+	start_serial_interrupt(ser->irq);
+
+	return ser;
+}
+
+void start_serial_interrupt( int irq )
+{
+	int rv;
+
+	if (synth->read_buff_add == NULL)
+		return;
+
+	rv = request_irq(irq, synth_readbuf_handler, SA_SHIRQ,
+			 "serial", (void *) synth_readbuf_handler);
+
+	if (rv)
+	{
+		printk(KERN_ERR "Unable to request Speakup serial I R Q\n");
+	}
+	// Set MCR
+	outb(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2, synth_port_tts + UART_MCR);
+	// Turn on Interrupts
+	outb(UART_IER_MSI|UART_IER_RLSI|UART_IER_RDI,synth_port_tts+ UART_IER );
+	inb(synth_port_tts+UART_LSR);
+	inb(synth_port_tts+UART_RX);
+	inb(synth_port_tts+UART_IIR);
+	inb(synth_port_tts+UART_MSR);
+	outb( 1, synth_port_tts + UART_FCR );	/* Turn FIFO On */
+}
+
+void stop_serial_interrupt()
+{
+	// Turn off interrupts
+	outb(0,synth_port_tts+UART_IER);
+	// Free IRQ
+	free_irq(serstate->irq, (void *) synth_readbuf_handler);
+}
+
+void spk_serial_release( void )
+{
+	if ( synth_port_tts == 0 ) return;
+	synth_release_region( synth_port_tts, 8 );
+	synth_port_tts = 0;
+}
+
+static irqreturn_t synth_readbuf_handler(int irq, void *dev_id,struct pt_regs *regs)
+{
+//printk(KERN_ERR "in irq\n");
+//pr_warn("in IRQ\n");
+	int c;
+	while (inb_p(synth_port_tts + UART_LSR) & UART_LSR_DR)
+	{
+
+		c=inb_p(synth_port_tts+UART_RX);
+		synth->read_buff_add((u_char) c);
+//printk(KERN_ERR "c = %d\n",c);
+//pr_warn("C = %d\n",c);
+	}
+	return IRQ_HANDLED;
+}
+
+/* sleep for ms milliseconds */
+void
+synth_delay ( int val )
+{
+        if (val == 0) return;
+	synth_timer.expires = jiffies + val;
+		start_timer( synth_timer );
+	synth_timer_active++;
+}
+
+void
+synth_dummy_catchup( unsigned long data )
+{
+	synth_stop_timer( );
+	synth_done( );
+	return;
+} /* a bogus catchup if no synth */
+
+void
+synth_stop_timer ( void )
+{
+	if ( synth_timer_active )
+		stop_timer ( synth_timer );
+	synth_timer_active = 0;
+}
+
+int synth_done( void )
+{
+	synth_buff_out = synth_buff_in = synth_buffer;
+	if (waitqueue_active(&synth_sleeping_list)) {
+		  wake_up_interruptible(&synth_sleeping_list);
+		return 0;
+	}
+	return 1;
+}
+
+static inline void synth_start( void )
+{
+	if ( !synth_alive )
+		synth_done( );
+	else if ( synth->start )
+		synth->start( );
+	else if (synth_timer_active == 0)
+		synth_delay( synth_trigger_time );
+}
+
+void do_flush( void )
+{
+	synth_stop_timer( );
+	synth_buff_out = synth_buff_in = synth_buffer;
+	if ( synth_alive ) {
+		synth->flush( );
+		if ( synth->flush_wait )
+			synth_delay( ( synth->flush_wait * HZ ) / 1000 );
+		if ( pitch_shift ) {
+			synth_write_string( pitch_buff );
+			pitch_shift = 0;
+		}
+	}
+	if (waitqueue_active(&synth_sleeping_list))
+		wake_up_interruptible(&synth_sleeping_list);
+}
+
+void
+synth_buffer_add ( char ch )
+{
+	if ( synth_buff_in >= buffer_highwater ) {
+		synth_start ( );
+		if ( !waitqueue_active ( &synth_sleeping_list ) )
+			interruptible_sleep_on ( &synth_sleeping_list );
+		if ( synth_buff_in >= buffer_end ) return;
+	}
+	*synth_buff_in++ = ch;
+}
+
+void
+synth_write ( const char *buf, size_t count )
+{
+	while ( count-- )
+		synth_buffer_add ( *buf++ );
+	synth_start ( );
+}
+
+void
+synth_write_string ( const char *buf )
+{
+	while ( *buf )
+		synth_buffer_add ( *buf++ );
+	synth_start ( );
+}
+
+void
+synth_write_msg ( const char *buf )
+{
+	while ( *buf )
+		synth_buffer_add ( *buf++ );
+		synth_buffer_add ( '\n' );
+	synth_start ( );
+}
+
+static int index_count=0;
+int next_index;
+int sentence_count=0;
+
+int first=1;
+
+void
+reset_index_count(int sc)
+{
+	if (first)
+		first=0;
+	else
+		synth->get_index();
+	index_count=0;
+	sentence_count=sc;
+	next_index=synth->indexing.currindex+1;
+}
+
+int
+synth_supports_indexing( void )
+{
+	if ( synth->get_index!=NULL )
+		return 1;
+	return 0;
+}
+
+void
+synth_insert_next_index( int sent_num )
+{
+	int out;
+	char buf[50];
+	if ( synth_alive ) {
+		if (sent_num==0)
+		{
+			synth->indexing.currindex++;
+			index_count++;
+			if (synth->indexing.currindex>synth->indexing.highindex)
+				synth->indexing.currindex=synth->indexing.lowindex;
+		}
+
+		out=synth->indexing.currindex*10+sent_num;
+		sprintf(buf,synth->indexing.command,out,out);
+		synth_write_string(buf);
+	}
+}
+
+void
+get_index_count(int *linecount,int *sentcount)
+{
+	int ind=synth->get_index();
+	if (ind)
+	{
+		sentence_count=ind%10;
+
+		if ((ind/10)<=synth->indexing.currindex)
+			index_count = synth->indexing.currindex-(ind/10);
+		else
+			index_count = synth->indexing.currindex-synth->indexing.lowindex + synth->indexing.highindex-(ind/10)+1;
+
+	}
+	*sentcount=sentence_count;
+	*linecount=index_count;
+}
+
+static struct resource synth_res;
+
+int synth_request_region ( unsigned long start, unsigned long n )
+{
+	struct resource *parent = &ioport_resource;
+	memset ( &synth_res, 0, sizeof ( synth_res ) );
+	synth_res.name = synth->name;
+	synth_res.start = start;
+	synth_res.end = start + n - 1;
+	synth_res.flags = IORESOURCE_BUSY;
+	return request_resource ( parent, &synth_res );
+}
+
+int synth_release_region ( unsigned long start, unsigned long n )
+{
+	return release_resource ( &synth_res );
+}
+
+#ifdef CONFIG_PROC_FS
+
+// /proc/synth-specific code
+
+#include <asm/uaccess.h>
+#include <linux/limits.h>
+
+// this is the write handler for /proc/speakup/synth-specific/direct
+static int
+spk_direct_write_proc ( PROC_WRITE_PROTOTYPE )
+{
+	u_char buf[256];
+	int ret = count, bytes;
+	const char *ptr = buffer;
+	if ( synth == NULL ) return -EPERM;
+	while ( count > 0 ) {
+		bytes = MIN ( count, 250 );
+		if ( copy_from_user ( buf, ptr, bytes  ) )
+			return -EFAULT;
+		buf[bytes] = '\0';
+		xlate ( buf );
+		synth_write_string ( buf );
+		ptr += bytes;
+		count -= bytes;
+	}
+	return ret;
+}
+
+proc_var synth_direct = { SYNTH_DIRECT, 0, spk_direct_write_proc, 0 };
+
+#endif
+
+static num_var synth_time_vars[] = {
+	{ DELAY, 0, 100, 100, 2000, 0, 0, 0 },
+	{ TRIGGER, 0, 20, 10, 200, 0, 0, 0 },
+	{ JIFFY, 0, 50, 20, 200, 0, 0, 0 },
+	{ FULL, 0, 400, 200, 10000, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+int synth_init(char *synth_name)
+{
+	int i;
+	if (synth_name == NULL) return 0;
+	sema_init(&sem, 1); /* not sure where else to put this. */
+	if (strcmp(synth_name, "none") == 0) {
+		synth_release();
+		 return 0;
+	}
+	for(i = 0; synths[i] != NULL; i++) {
+		if (strcmp(synths[i]->name, synth_name) == 0)
+			return do_synth_init(synths[i]);
+	}
+	return 0;
+}
+
+int do_synth_init(struct spk_synth *in_synth)
+{
+	num_var *n_var;
+	string_var *s_var;
+
+	synth_release();
+	if (in_synth->checkval != SYNTH_CHECK) return -EINVAL;
+	synth = in_synth;
+pr_warn("synth probe\n");
+	if (synth->probe() < 0) {
+		pr_warn("%s: device probe failed\n", in_synth->name);
+		synth = NULL;
+		return -ENODEV;
+	}
+	synth_time_vars[0].default_val = synth->delay;
+	synth_time_vars[1].default_val = synth->trigger;
+	synth_time_vars[2].default_val = synth->jiffies;
+	synth_time_vars[3].default_val = synth->full;
+	  synth_timer.function = synth->catch_up;
+	  synth_timer.entry.prev = NULL;
+	  init_timer(&synth_timer);
+	  for(n_var = synth_time_vars; n_var->var_id >= 0; n_var++)
+	    speakup_register_var(n_var);
+	synth_alive = 1;
+	synth_write_string(synth->init);
+	for(s_var = synth->string_vars; s_var->var_id >= 0; s_var++)
+		speakup_register_var((num_var *) s_var);
+	for(n_var = synth->num_vars; n_var->var_id >= 0; n_var++)
+		speakup_register_var(n_var);
+	synth_write_string(synth->long_name);
+	synth_write_msg(" found");
+#ifdef CONFIG_PROC_FS
+	speakup_register_var((num_var *) &synth_direct);
+#endif
+	synth_flags = synth->flags;
+	return 0;
+}
+
+void
+synth_release ( void )
+{
+	num_var *n_var;
+	string_var *s_var;
+	if ( synth == NULL ) return;
+	if (down_interruptible ( &sem )) return;
+	pr_info ( "releasing synth %s\n", synth->name );
+	for ( s_var = synth->string_vars; s_var->var_id >= 0; s_var++ )
+		speakup_unregister_var( s_var->var_id );
+	for ( n_var = synth_time_vars; n_var->var_id >= 0; n_var++ )
+		speakup_unregister_var( n_var->var_id );
+	for ( n_var = synth->num_vars; n_var->var_id >= 0; n_var++ )
+		speakup_unregister_var( n_var->var_id );
+#ifdef CONFIG_PROC_FS
+	speakup_unregister_var( SYNTH_DIRECT );
+#endif
+	synth_dummy_catchup((unsigned long) NULL );
+	synth_timer.function = synth_dummy_catchup;
+	stop_serial_interrupt();
+	synth->release( );
+	synth = NULL;
+	up( &sem );
+}
+
+void synth_add ( struct spk_synth *in_synth )
+{
+	int i;
+	for (i = 0; synths[i] != NULL; i++ )
+	if ( in_synth == synths[i] ) return;
+	synths[i++] = in_synth;
+	synths[i] = NULL;
+}
+
+void synth_remove ( struct spk_synth *in_synth )
+{
+	int i;
+	for (i = 0; synths[i] != NULL; i++ ) {
+		if ( in_synth == synths[i] ) break;
+	}
+for ( ;synths[i] != NULL; i++ ) /* compress table */
+		synths[i] = synths[i+1];
+	module_status = 0;
+}
+
+var_header var_headers[] = {
+  { "version", VERSION, VAR_PROC, USER_R, 0, 0, 0 },
+  { "synth_name", SYNTH, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "keymap", KEYMAP, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "silent", SILENT, VAR_PROC, USER_W, 0, 0, 0 },
+  { "punc_some", PUNC_SOME, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "punc_most", PUNC_MOST, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "punc_all", PUNC_ALL, VAR_PROC, USER_R, 0, 0, 0 },
+  { "delimiters", DELIM, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "repeats", REPEATS, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "ex_num", EXNUMBER, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "characters", CHARS, VAR_PROC, USER_RW, 0, 0, 0 },
+  { "synth_direct", SYNTH_DIRECT, VAR_PROC, USER_W, 0, 0, 0 },
+  { "caps_start", CAPS_START, VAR_STRING, USER_RW, 0, str_caps_start, 0 },
+  { "caps_stop", CAPS_STOP, VAR_STRING, USER_RW, 0, str_caps_stop, 0 },
+  { "delay_time", DELAY, VAR_TIME, ROOT_W, 0, &synth_delay_time, 0 },
+  { "trigger_time", TRIGGER, VAR_TIME, ROOT_W, 0, &synth_trigger_time, 0 },
+  { "jiffy_delta", JIFFY, VAR_TIME, ROOT_W, 0, &synth_jiffy_delta, 0 },
+  { "full_time", FULL, VAR_TIME, ROOT_W, 0, &synth_full_time, 0 },
+  { "spell_delay", SPELL_DELAY, VAR_NUM, USER_RW, 0, &spell_delay, 0 },
+  { "bleeps", BLEEPS, VAR_NUM, USER_RW, 0, &bleeps, 0 },
+  { "attrib_bleep", ATTRIB_BLEEP, VAR_NUM, USER_RW, 0, &attrib_bleep, 0 },
+  { "bleep_time", BLEEP_TIME, VAR_NUM, USER_RW, 0, &bleep_time, 0 },
+  { "cursor_time", CURSOR_TIME, VAR_TIME, USER_RW, 0, &cursor_timeout, 0 },
+  { "punc_level", PUNC_LEVEL, VAR_NUM, USER_RW, 0, &punc_level, 0 },
+  { "reading_punc", READING_PUNC, VAR_NUM, USER_RW, 0, &reading_punc, 0 },
+  { "say_control", SAY_CONTROL, VAR_NUM, USER_RW, 0, &say_ctrl, 0 },
+  { "say_word_ctl", SAY_WORD_CTL, VAR_NUM, USER_RW, 0, &say_word_ctl, 0 },
+  { "no_interrupt", NO_INTERRUPT, VAR_NUM, USER_RW, 0, &no_intr, 0 },
+  { "key_echo", KEY_ECHO, VAR_NUM, USER_RW, 0, &key_echo, 0 },
+  { "bell_pos", BELL_POS, VAR_NUM, USER_RW, 0, &bell_pos, 0 },
+  { "rate", RATE, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "pitch", PITCH, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "vol", VOL, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "tone", TONE, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "punct", PUNCT, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "voice", VOICE, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "freq", FREQ, VAR_NUM, USER_RW, 0, 0, 0 },
+  { "lang", LANG, VAR_NUM, USER_RW, 0, 0, 0 }
+};
+
+var_header *var_ptrs[MAXVARS] = { 0, 0, 0 };
+
+char *
+speakup_s2i ( char *start, short *dest )
+{
+	int val;
+	char ch = *start;
+	if ( ch == '-' || ch == '+' ) start++;
+	if ( *start < '0' || *start > '9' ) return start;
+	val = ( *start ) - '0';
+	start++;
+	while ( *start >= '0' && *start <= '9' ) {
+		val *= 10;
+		val += ( *start ) - '0';
+		start++;
+	}
+	if ( ch == '-' ) *dest = -val;
+	else *dest = val;
+	return start;
+}
+
+short punc_masks[] = { 0, SOME, MOST, PUNC, PUNC|B_SYM };
+
+// handlers for setting vars
+int
+set_num_var( short input, var_header *var, int how )
+{
+	short val, ret = 0;
+	short *p_val = var->p_val;
+	int l;
+	char buf[32], *cp;
+	num_var *var_data = var->data;
+	if ( var_data == NULL ) return E_UNDEF;
+	if ( how == E_DEFAULT ) {
+		val = var_data->default_val;
+		ret = SET_DEFAULT;
+	} else {
+		if ( how == E_SET ) val = input;
+		else val = var_data->value;
+		if ( how == E_INC ) val += input;
+		else if ( how == E_DEC ) val -= input;
+		if ( val < var_data->low || val > var_data->high )
+			return E_RANGE;
+	}
+	var_data->value = val;
+	if ( var->var_type == VAR_TIME && p_val != 0 ) {
+		*p_val = ( val * HZ + 1000 - HZ ) / 1000;
+		return ret;
+	}
+	if ( p_val != 0 ) *p_val = val;
+	if ( var->var_id == PUNC_LEVEL ) {
+		punc_mask = punc_masks[val];
+	return ret;
+	}
+	if ( var_data->multiplier != 0 )
+		val *= var_data->multiplier;
+	val += var_data->offset;
+	if ( var->var_id < FIRST_SYNTH_VAR || synth == NULL ) return ret;
+	if ( synth->synth_adjust != NULL ) {
+		int status = synth->synth_adjust( var );
+		return ( status != 0 ) ? status : ret;
+	}
+	if ( !var_data->synth_fmt ) return ret;
+	if ( var->var_id == PITCH ) cp = pitch_buff;
+	else cp = buf;
+	if ( !var_data->out_str )
+		l = sprintf( cp, var_data->synth_fmt, (int)val );
+	else l = sprintf( cp, var_data->synth_fmt, var_data->out_str[val] );
+	synth_write_string( cp );
+	return ret;
+}
+
+static int
+set_string_var( char *page, var_header *var, int len )
+{
+	int ret = 0;
+	string_var *var_data = var->data;
+	if ( var_data == NULL ) return E_UNDEF;
+	if ( len > MAXVARLEN )
+		return -E_TOOLONG;
+	if ( !len ) {
+	if ( !var_data->default_val ) return 0;
+		ret = SET_DEFAULT;
+		if ( !var->p_val ) var->p_val = var_data->default_val;
+		if ( var->p_val != var_data->default_val )
+			strcpy( (char *)var->p_val, var_data->default_val );
+		} else if ( var->p_val )
+			strcpy( (char *)var->p_val, page );
+	else return -E_TOOLONG;
+	return ret;
+}
+
+	var_header * get_var_header( short var_id )
+{
+	var_header *p_header;
+	if ( var_id < 0 || var_id >= MAXVARS ) return NULL;
+	p_header = var_ptrs[var_id];
+	if ( p_header->data == NULL ) return NULL;
+	return p_header;
+}
+
+#ifdef CONFIG_PROC_FS
+// this is the write handler for /proc/speakup vars
+static int
+speakup_vars_write_proc ( PROC_WRITE_PROTOTYPE )
+{
+  var_header *p_header = data;
+	int len = count, ret = 0;
+	char *page = ( char * ) __get_free_page ( GFP_KERNEL );
+	char *v_name = p_header->name, *cp;
+	num_var *var_data;
+	short value;
+	if ( !page ) return -ENOMEM;
+	if ( copy_from_user ( page, buffer, count ) ) {
+		ret = -EFAULT;
+		goto out;
+	}
+	if ( page[len - 1] == '\n' ) --len;
+	page[len] = '\0';
+	cp = xlate( page );
+	switch( p_header->var_type ) {
+		case VAR_NUM:
+		case VAR_TIME:
+			if ( *cp == 'd' || *cp == 'r' || *cp == '\0' )
+				len = E_DEFAULT;
+			else if ( *cp == '+' || *cp == '-' ) len = E_INC;
+			else len = E_SET;
+			speakup_s2i( cp, &value );
+			ret = set_num_var( value, p_header, len );
+			if ( ret != E_RANGE ) break;
+	var_data = p_header->data;
+			pr_warn( "value for %s out of range, expect %d to %d\n",
+			v_name, (int)var_data->low, (int)var_data->high );
+			break;
+		case VAR_STRING:
+			len = strlen( page );
+			ret = set_string_var( page, p_header, len );
+			if ( ret != E_TOOLONG ) break;
+			pr_warn( "value too long for %s\n", v_name );
+			break;
+		default:
+			pr_warn( "%s unknown type %d\n",
+				p_header->name, ( int )p_header->var_type );
+		break;
+	}
+out:
+	if ( ret == SET_DEFAULT )
+		pr_info( "%s reset to default value\n", v_name );
+	free_page ( ( unsigned long ) page );
+	return count;
+}
+
+// this is the read handler for /proc/speakup vars
+static int
+speakup_vars_read_proc ( PROC_READ_PROTOTYPE )
+{
+	var_header *var = ( var_header * )data;
+	num_var *n_var = var->data;
+	char ch, *cp, *cp1;
+	*start = 0;
+	*eof = 1;
+	switch( var->var_type ) {
+		case VAR_NUM:
+		case VAR_TIME:
+			return sprintf( page, "%d\n", ( int )n_var->value );
+			break;
+		case VAR_STRING:
+			cp1 = page;
+			*cp1++ = '"';
+			for ( cp = (char *)var->p_val; ( ch = *cp ); cp++ ) {
+				if ( ch >= ' ' && ch < '~' )
+					*cp1++ = ch;
+				else
+					cp1 += sprintf( cp1, "\\""x%02x", ch );
+			}
+			*cp1++ = '"';
+			*cp1++ = '\n';
+			*cp1 = '\0';
+			return cp1-page;
+			break;
+		default:
+			return sprintf( page, "oops bad type %d\n",
+				( int )var->var_type );
+	}
+	return 0;
+}
+
+static const char spk_dir[] = "speakup";
+static struct proc_dir_entry *dir_ent = 0;
+
+static int
+spk_make_proc( var_header *p_header )
+{
+	struct proc_dir_entry *ent = p_header->proc_entry;
+	char *name = p_header->name;
+	proc_var *p_var;
+	if ( dir_ent == 0 || p_header->proc_mode == 0 || ent != 0 ) return 0;
+	ent = create_proc_entry ( name, p_header->proc_mode, dir_ent );
+	if ( !ent ) {
+		pr_warn( "Unable to create /proc/%s/%s entry.\n",
+			spk_dir, name );
+		return -1;
+	}
+	if ( p_header->var_type == VAR_PROC ) {
+		p_var = ( proc_var * )p_header->data;
+		if ( p_header->proc_mode&S_IRUSR )
+			ent->read_proc = p_var->read_proc;
+		if ( p_header->proc_mode&S_IWUSR )
+			ent->write_proc = p_var->write_proc;
+	} else {
+		if ( p_header->proc_mode&S_IRUSR )
+			ent->read_proc = speakup_vars_read_proc;
+		if ( p_header->proc_mode&S_IWUSR )
+			ent->write_proc = speakup_vars_write_proc;
+	}
+	ent->data = ( void * )p_header;
+	p_header->proc_entry = ( void * ) ent;
+	return 0;
+}
+
+#endif
+
+int
+speakup_register_var( num_var *var )
+{
+	static char nothing[2] = "\0";
+	int i, var_id = var->var_id;
+	var_header *p_header;
+	string_var *s_var;
+	if ( var_id < 0 || var_id >= MAXVARS ) return -1;
+	if ( var_ptrs[0] == 0 ) {
+		for ( i = 0; i < MAXVARS; i++ ) {
+			p_header = &var_headers[i];
+			var_ptrs[p_header->var_id] = p_header;
+			p_header->data = 0;
+		}
+	}
+	p_header = var_ptrs[var_id];
+	if ( p_header->data != 0 ) return 0;
+	p_header->data  = var;
+	switch ( p_header->var_type ) {
+		case VAR_STRING:
+			s_var = ( string_var * )var;
+			set_string_var( nothing, p_header, 0 );
+			break;
+		case VAR_NUM:
+		case VAR_TIME:
+			set_num_var( 0, p_header, E_DEFAULT );
+			break;
+	}
+#ifdef CONFIG_PROC_FS
+	return spk_make_proc( p_header );
+#else
+	return 0;
+#endif
+}
+
+void
+speakup_unregister_var( short var_id )
+{
+	var_header *p_header;
+	if ( var_id < 0 || var_id >= MAXVARS ) return;
+	p_header = var_ptrs[var_id];
+	p_header->data = 0;
+#ifdef CONFIG_PROC_FS
+	if ( dir_ent != 0 && p_header->proc_entry != 0 )
+		remove_proc_entry( p_header->name, dir_ent );
+	p_header->proc_entry = 0;
+#endif
+}
+
+extern char synth_name[];
+
+// called by
+int speakup_dev_init(void)
+{
+	int i;
+	var_header *p_header;
+	proc_var *pv = spk_proc_vars;
+
+	//pr_warn("synth name on entry is: %s\n", synth_name);
+	synth_init(synth_name);
+	speakup_register_devsynth();
+#ifdef CONFIG_PROC_FS
+	dir_ent = create_proc_entry(spk_dir, S_IFDIR, 0);
+	if (!dir_ent) {
+		pr_warn("Unable to create /proc/%s entry.\n", spk_dir);
+		return -1;
+	}
+	while(pv->var_id >= 0) {
+		speakup_register_var((void *) pv);
+		pv++;
+	}
+		for (i = 0; i < MAXVARS; i++) {
+			p_header = &var_headers[i];
+		if ( p_header->data != 0 ) spk_make_proc(p_header);
+	}
+#endif
+	return 0;
+}
+
+void speakup_remove(void)
+{
+	int i;
+
+	for (i = 0; i < MAXVARS; i++)
+		speakup_unregister_var(i);
+	pr_info("speakup: unregistering synth device /dev/synth\n");
+	misc_deregister(&synth_device);
+	misc_registered = 0;
+#ifdef CONFIG_PROC_FS
+	if (dir_ent != 0)
+		remove_proc_entry(spk_dir, NULL);
+#endif
+}
+
+// provide a file to users, so people can send to /dev/synth
+
+static ssize_t
+speakup_file_write ( struct file *fp, const char *buffer,
+		    size_t nbytes, loff_t * ppos )
+{
+	size_t count = nbytes;
+	const char *ptr = buffer;
+	int bytes;
+	u_char buf[256];
+	if ( synth == NULL ) return -ENODEV;
+	while ( count > 0 ) {
+		bytes = MIN ( count, sizeof ( buf ) );
+		if ( copy_from_user ( buf, ptr, bytes ) )
+			return -EFAULT;
+		count -= bytes;
+		ptr += bytes;
+		synth_write ( buf, bytes );
+	}
+	return ( ssize_t ) nbytes;
+}
+
+static int
+speakup_file_ioctl ( struct inode *inode, struct file *file,
+		    unsigned int cmd, unsigned long arg )
+{
+	return 0;		// silently ignore
+}
+
+static ssize_t
+speakup_file_read ( struct file *fp, char *buf, size_t nbytes, loff_t * ppos )
+{
+	return 0;
+}
+
+static int synth_file_inuse = 0;
+
+static int
+speakup_file_open ( struct inode *ip, struct file *fp )
+{
+	if ( synth_file_inuse )
+		return -EBUSY;
+	else if ( synth == NULL )
+		return -ENODEV;
+	synth_file_inuse++;
+	return 0;
+}
+
+static int
+speakup_file_release ( struct inode *ip, struct file *fp )
+{
+	synth_file_inuse = 0;
+	return 0;
+}
+
+static struct file_operations synth_fops = {
+	read:speakup_file_read,
+	write:speakup_file_write,
+	ioctl:speakup_file_ioctl,
+	open:speakup_file_open,
+	release:speakup_file_release,
+};
+
+void
+speakup_register_devsynth ( void ) {
+	if ( misc_registered != 0 ) return;
+	misc_registered = 1;
+	memset( &synth_device, 0, sizeof( synth_device ) );
+/* zero it so if register fails, deregister will not ref invalid ptrs */
+	synth_device.minor = SYNTH_MINOR;
+	synth_device.name = "synth";
+	synth_device.fops = &synth_fops;
+	if ( misc_register ( &synth_device ) )
+		pr_warn(
+			"Couldn't initialize miscdevice /dev/synth.\n" );
+	else
+		pr_info(
+		    "initialized device: /dev/synth, node ( MAJOR 10, MINOR 25 )\n" );
+}
+
+char *
+xlate ( char *s )
+{
+static const char finds[] = "nrtvafe";
+static const char subs[] = "\n\r\t\013\001\014\033";
+static const char hx[] = "0123456789abcdefABCDEF";
+	char *p = s, *p1, *p2, c;
+	int num;
+	while ( ( p = strchr ( p, '\\' ) ) ) {
+		p1 = p+1;
+		p2 = strchr( finds, *p1 );
+		if ( p2 ) {
+			*p++ = subs[p2-finds];
+			p1++;
+		} else if ( *p1 >= '0' && *p1 <= '7' ) {
+			num = ( *p1++ )&7;
+			while ( num < 256 && *p1 >= '0' && *p1 <= '7' ) {
+				num <<= 3;
+				num = ( *p1++ )&7;
+			}
+			*p++ = num;
+		} else if ( *p1 == 'x'&& strchr( hx, p1[1] ) && strchr( hx, p1[2] ) ) {
+			p1++;
+			c = *p1++;
+			if ( c > '9' )
+				c = ( c-'7' )&0x0f;
+			else
+				c -= '0';
+			num = c<<4;
+			c = *p1++;
+			if ( c > '9' )
+				c = ( c-'7' )&0x0f;
+			else
+				c -= '0';
+			num += c;
+			*p++ = num;
+		} else
+			*p++ = *p1++;
+		p2 = p;
+		while ( *p1 ) *p2++ = *p1++;
+		*p2 = '\0';
+	}
+	return s;
+}
+
+#ifdef CONFIG_SPEAKUP
+__initcall(speakup_dev_init);
+#endif
+
+/* exported symbols needed by synth modules */
+EXPORT_SYMBOL(speakup_dev_init);
+EXPORT_SYMBOL(synth_init);
+EXPORT_SYMBOL(do_synth_init);
+EXPORT_SYMBOL(spk_serial_init);
+EXPORT_SYMBOL(spk_serial_release);
+EXPORT_SYMBOL(synth);
+EXPORT_SYMBOL(synth_alive);
+EXPORT_SYMBOL(synth_buffer);
+EXPORT_SYMBOL(synth_buff_in);
+EXPORT_SYMBOL(synth_buff_out);
+EXPORT_SYMBOL(synth_delay);
+EXPORT_SYMBOL(synth_delay_time);
+EXPORT_SYMBOL(synth_done);
+EXPORT_SYMBOL(synth_full_time);
+EXPORT_SYMBOL(synth_jiffy_delta);
+EXPORT_SYMBOL(synth_port_forced);
+EXPORT_SYMBOL(synth_port_tts);
+EXPORT_SYMBOL(synth_request_region);
+EXPORT_SYMBOL(synth_release_region);
+EXPORT_SYMBOL(synth_release);
+EXPORT_SYMBOL(synth_add);
+EXPORT_SYMBOL(synth_remove);
+EXPORT_SYMBOL(synth_stop_timer);
+EXPORT_SYMBOL(synth_write_string);
+EXPORT_SYMBOL(synth_write_msg);
+EXPORT_SYMBOL(synth_write);
+EXPORT_SYMBOL(synth_supports_indexing);
+EXPORT_SYMBOL(start_serial_interrupt);
+MODULE_AUTHOR("Kirk Reiser <kirk@braille.uwo.ca>");
+MODULE_DESCRIPTION("Speakup module required by all synthesizer specific modules");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/speakup/speakup_dtlk.c b/drivers/char/speakup/speakup_dtlk.c
new file mode 100644
index 0000000000..7996d74547
--- /dev/null
+++ b/drivers/char/speakup/speakup_dtlk.c
@@ -0,0 +1,233 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+#include "speakup_dtlk.h" /* local header file for DoubleTalk values */
+
+#define MY_SYNTH synth_dtlk
+#define PROCSPEECH 0x00
+#define synth_readable() ((synth_status = inb_p(synth_port_tts)) & TTS_READABLE)
+#define synth_full() ((synth_status = inb_p(synth_port_tts)) & TTS_ALMOST_FULL)
+
+static int synth_lpc;
+static unsigned int synth_portlist[] =
+		{ 0x25e, 0x29e, 0x2de, 0x31e, 0x35e, 0x39e, 0 };
+static u_char synth_status = 0;
+
+static inline void spk_out(const char ch)
+{
+	int tmout = 100000;
+	while (((synth_status = inb_p(synth_port_tts)) & TTS_WRITABLE) == 0);
+	outb_p(ch, synth_port_tts);
+	while ((((synth_status = inb_p(synth_port_tts)) & TTS_WRITABLE) != 0)
+		&& (--tmout != 0) );
+}
+
+static void do_catch_up(unsigned long data)
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	synth_stop_timer();
+	synth_status = inb_p(synth_port_tts);
+	while (synth_buff_out < synth_buff_in) {
+		if (synth_status & TTS_ALMOST_FULL) {
+			synth_delay(synth_full_time);
+			return;
+		}
+		ch = *synth_buff_out++;
+		if (ch == 0x0a) ch = PROCSPEECH;
+		spk_out( ch );
+		if (jiffies >= jiff_max && ch == SPACE) {
+			spk_out(PROCSPEECH);
+			synth_delay(synth_delay_time);
+			return;
+		}
+	}
+	spk_out(PROCSPEECH);
+	synth_done( );
+}
+
+static const char *synth_immediate(const char *buf )
+{
+	u_char ch;
+	synth_status = inb_p(synth_port_tts);
+	while ( (ch = (u_char)*buf ) ) {
+		if (synth_status & TTS_ALMOST_FULL)
+			return buf;
+		if ( ch == 0x0a ) ch = PROCSPEECH;
+		spk_out(ch);
+		buf++;
+	}
+	return 0;
+}
+
+static unsigned char get_index( void )
+{
+        int c, lsr;//, tmout = SPK_SERIAL_TIMEOUT;
+        lsr = inb_p( synth_port_tts + UART_LSR );
+        if ( ( lsr & UART_LSR_DR) == UART_LSR_DR )
+        {
+                c = inb_p( synth_port_tts + UART_RX );
+                return ( unsigned char ) c;
+        }
+        return 0;
+}
+
+static void synth_flush(void)
+{
+	outb_p(SYNTH_CLEAR, synth_port_tts);
+	while (((synth_status = inb_p(synth_port_tts)) & TTS_WRITABLE) != 0);
+	}
+
+static char synth_read_tts(void)
+{
+	u_char ch;
+	while (((synth_status = inb_p(synth_port_tts)) & TTS_READABLE) == 0);
+	ch = synth_status & 0x7f;
+	outb_p(ch, synth_port_tts);
+	while ((inb_p(synth_port_tts) & TTS_READABLE) != 0);
+return (char) ch;
+}
+
+/* interrogate the DoubleTalk PC and return its settings */
+static struct synth_settings * synth_interrogate(void)
+{
+	u_char *t;
+static char buf[sizeof(struct synth_settings) + 1];
+int total, i;
+static struct synth_settings status;
+	synth_immediate("\x18\x01?");
+	for (total = 0, i = 0; i < 50; i++) {
+			buf[total] = synth_read_tts();
+			if (total > 2 && buf[total] == 0x7f) break;
+			if (total < sizeof(struct synth_settings)) total++;
+		}
+	t = buf;
+	status.serial_number = t[0] + t[1]*256; /* serial number is little endian */
+	t += 2;
+	for ( i = 0; *t != '\r'; t++ ) {
+			status.rom_version[i] = *t;
+			if (i < sizeof(status.rom_version)-1) i++;
+		}
+	status.rom_version[i] = 0;
+	t++;
+	status.mode = *t++;
+	status.punc_level = *t++;
+	status.formant_freq = *t++;
+	status.pitch = *t++;
+	status.speed = *t++;
+	status.volume = *t++;
+	status.tone = *t++;
+	status.expression = *t++;
+	status.ext_dict_loaded = *t++;
+	status.ext_dict_status = *t++;
+	status.free_ram = *t++;
+	status.articulation = *t++;
+	status.reverb = *t++;
+	status.eob = *t++;
+	return &status;
+}
+
+static int synth_probe(void)
+{
+		unsigned int port_val = 0;
+	int i = 0;
+	struct synth_settings *sp;
+	pr_info("Probing for DoubleTalk.\n");
+	if (synth_port_forced) {
+		synth_port_tts = synth_port_forced;
+		pr_info("probe forced to %x by kernel command line\n", synth_port_tts);
+		if (synth_request_region(synth_port_tts-1, SYNTH_IO_EXTENT)) {
+			pr_warn("sorry, port already reserved\n");
+			return -EBUSY;
+		}
+		port_val = inw(synth_port_tts-1);
+		synth_lpc = synth_port_tts-1;
+	} else {
+		for(i=0; synth_portlist[i]; i++) {
+			if (synth_request_region(synth_portlist[i], SYNTH_IO_EXTENT))
+	continue;
+			port_val = inw(synth_portlist[i]);
+			if ((port_val &= 0xfbff) == 0x107f) {
+	synth_lpc = synth_portlist[i];
+	synth_port_tts = synth_lpc+1;
+	break;
+			}
+			synth_release_region(synth_portlist[i], SYNTH_IO_EXTENT);
+		}
+	}
+	if ((port_val &= 0xfbff) != 0x107f) {
+		pr_info("DoubleTalk PC:  not found\n");
+		return -ENODEV;
+	}
+	while (inw_p(synth_lpc) != 0x147f ); /* wait until it's ready */
+	sp = synth_interrogate();
+	pr_info("%s:  %03x-%03x, ROM ver %s, s/n %u, driver: %s\n",
+		synth->long_name, synth_lpc, synth_lpc+SYNTH_IO_EXTENT - 1,
+	 sp->rom_version, sp->serial_number, synth->version);
+	//	synth_alive = 1;
+	return 0;
+}
+
+static int synth_is_alive(void)
+{
+	return 1;	/* I'm *INVINCIBLE* */
+}
+
+static void
+dtlk_release( void )
+{
+	if ( synth_port_tts )
+		synth_release_region(synth_port_tts-1, SYNTH_IO_EXTENT);
+	synth_port_tts = 0;
+}
+
+static const char init_string[] = "\x01@\x01\x31y";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x01+35p" },
+	{ CAPS_STOP, "\x01-35p" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\x01%ds", 8, 0, 9, 0, 0, 0 },
+	{ PITCH, "\x01%dp", 50, 0, 99, 0, 0, 0 },
+	{ VOL, "\x01%dv", 5, 0, 9, 0, 0, 0 },
+	{ TONE, "\x01%dx", 1, 0, 2, 0, 0, 0 },
+	{ PUNCT, "\x01%db", 7, 0, 15, 0, 0, 0 },
+	{ VOICE, "\x01%do", 0, 0, 7, 0, 0, 0 },
+	{ FREQ, "\x01%df", 5, 0, 9, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_dtlk = {"dtlk", "1.1", "DoubleTalk PC",
+			   init_string, 500, 30, 50, 1000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, dtlk_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, get_index,
+	{"\x01%di",1,5,1} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_dtlk.h b/drivers/char/speakup/speakup_dtlk.h
new file mode 100644
index 0000000000..46496b70da
--- /dev/null
+++ b/drivers/char/speakup/speakup_dtlk.h
@@ -0,0 +1,54 @@
+/* speakup_dtlk.h - header file for speakups DoubleTalk driver. */
+
+#define SYNTH_IO_EXTENT	0x02
+#define SYNTH_CLEAR 0x18		/* stops speech */
+	/* TTS Port Status Flags */
+#define TTS_READABLE	   0x80	/* mask for bit which is nonzero if a
+					 byte can be read from the TTS port */
+#define TTS_SPEAKING	   0x40	/* mask for SYNC bit, which is nonzero
+					 while DoubleTalk is producing
+					 output with TTS, PCM or CVSD
+					 synthesizers or tone generators
+					 (that is, all but LPC) */
+#define TTS_SPEAKING2	  0x20	/* mask for SYNC2 bit,
+					 which falls to zero up to 0.4 sec
+					 before speech stops */
+#define TTS_WRITABLE	   0x10	/* mask for RDY bit, which when set to
+	           			   1, indicates the TTS port is ready
+	           			   to accept a byte of data.  The RDY
+	           			   bit goes zero 2-3 usec after
+	           			   writing, and goes 1 again 180-190
+	           			   usec later. */
+#define TTS_ALMOST_FULL	0x08	/* mask for AF bit: When set to 1,
+					 indicates that less than 300 bytes
+					 are available in the TTS input
+					 buffer. AF is always 0 in the PCM,
+					 TGN and CVSD modes. */
+#define TTS_ALMOST_EMPTY 0x04	/* mask for AE bit: When set to 1,
+					 indicates that less than 300 bytes
+					 are remaining in DoubleTalk's input
+					 (TTS or PCM) buffer. AE is always 1
+					 in the TGN and CVSD modes. */
+
+				/* data returned by Interrogate command */
+struct synth_settings {
+	u_short serial_number;	/* 0-7Fh:0-7Fh */
+	u_char rom_version[24]; /* null terminated string */
+	u_char mode;		/* 0=Character; 1=Phoneme; 2=Text */
+	u_char punc_level;	/* nB; 0-7 */
+	u_char formant_freq;	/* nF; 0-9 */
+	u_char pitch;		/* nP; 0-99 */
+	u_char speed;		/* nS; 0-9 */
+	u_char volume;		/* nV; 0-9 */
+	u_char tone;		/* nX; 0-2 */
+	u_char expression;	/* nE; 0-9 */
+	u_char ext_dict_loaded; /* 1=exception dictionary loaded */
+	u_char ext_dict_status; /* 1=exception dictionary enabled */
+	u_char free_ram;	/* # pages (truncated) remaining for
+	                                 text buffer */
+	u_char articulation;	/* nA; 0-9 */
+	u_char reverb;		/* nR; 0-9 */
+	u_char eob;		/* 7Fh value indicating end of
+	                                 parameter block */
+	u_char has_indexing;	/* nonzero if indexing is implemented */
+};
diff --git a/drivers/char/speakup/speakup_keyhelp.c b/drivers/char/speakup/speakup_keyhelp.c
new file mode 100644
index 0000000000..89dba91f44
--- /dev/null
+++ b/drivers/char/speakup/speakup_keyhelp.c
@@ -0,0 +1,288 @@
+/* speakup_keyhelp.c
+   help module for speakup
+
+  written by David Borowski.
+
+    Copyright (C ) 2003  David Borowski.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option ) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/version.h>
+#include <linux/keyboard.h>
+#include "spk_priv.h"
+
+extern u_char *our_keys[];
+extern special_func special_handler;
+extern special_func help_handler;
+#define MAXFUNCS 130
+#define MAXKEYS 256
+static u_short key_offsets[MAXFUNCS], key_buf[MAXKEYS];
+static u_short masks[] = { 32, 16, 8, 4, 2, 1 };
+static char help_info[] =
+	"press space to leav help, cursor up or down to scroll, or a letter to go to commands in list";
+static char *statenames[] = {
+	" double", " speakup", " alt",
+	" ctrl", " altgr", " shift"
+};
+static char *keynames[] = {
+	"escape", "1", "2", "3", "4",
+	"5", "6", "7", "8", "9",
+	"0", "minus", "equal", "back space", "tab",
+	"q", "w", "e", "r", "t",
+	"y", "u", "i", "o", "p",
+	"left brace", "right brace", "enter", "left control", "a",
+	"s", "d", "f", "g", "h",
+	"j", "k", "l", "semicolon", "apostrophe",
+	"accent", "left shift", "back slash", "z", "x",
+	"c", "v", "b", "n", "m",
+	"comma", "dot", "slash", "right shift", "keypad asterisk",
+	"left alt", "space", "caps lock", "f1", "f2",
+	"f3", "f4", "f5", "f6", "f7",
+	"f8", "f9", "f10", "num lock", "scroll lock",
+	"keypad 7", "keypad 8", "keypad 9", "keypad minus", "keypad 4",
+	"keypad 5", "keypad 6", "keypad plus", "keypad 1", "keypad 2",
+	"keypad 3", "keypad 0", "keypad dot", "103rd", "f13",
+	"102nd", "f11", "f12", "f14", "f15",
+	"f16", "f17", "f18", "f19", "f20",
+	"keypad enter", "right control", "keypad slash", "sysrq", "right alt",
+	"line feed", "home", "up", "page up", "left",
+	"right", "end", "down", "page down", "insert",
+	"delete", "macro", "mute", "volume down", "volume up",
+	"power", "keypad equal", "keypad plusminus", "pause", "f21",
+	"f22", "f23", "f24", "keypad comma", "left meta",
+	"right meta", "compose", "stop", "again", "props",
+	"undo", "front", "copy", "open", "paste",
+	"find", "cut", "help", "menu", "calc",
+	"setup", "sleep", "wakeup", "file", "send file",
+	"delete file", "transfer", "prog1", "prog2", "www",
+	"msdos", "coffee", "direction", "cycle windows", "mail",
+	"bookmarks", "computer", "back", "forward", "close cd",
+	"eject cd", "eject close cd", "next song", "play pause", "previous song",
+	"stop cd", "record", "rewind", "phone", "iso",
+	"config", "home page", "refresh", "exit", "move",
+	"edit", "scroll up", "scroll down", "keypad left paren", "keypad right paren",
+};
+
+static short letter_offsets[26];
+
+static u_char funcvals[] = {
+	ATTRIB_BLEEP_DEC, ATTRIB_BLEEP_INC, BLEEPS_DEC, BLEEPS_INC,
+	SAY_FIRST_CHAR, SAY_LAST_CHAR, SAY_CHAR, SAY_CHAR_NUM,
+	SAY_NEXT_CHAR, SAY_PHONETIC_CHAR, SAY_PREV_CHAR, SPEAKUP_PARKED,
+	SPEAKUP_CUT, EDIT_DELIM, EDIT_EXNUM, EDIT_MOST,
+	EDIT_REPEAT, EDIT_SOME, SPEAKUP_GOTO, BOTTOM_EDGE,
+	LEFT_EDGE, RIGHT_EDGE, TOP_EDGE, SPEAKUP_HELP,
+	SAY_LINE, SAY_NEXT_LINE, SAY_PREV_LINE, SAY_LINE_INDENT,
+	SPEAKUP_PASTE, PITCH_DEC, PITCH_INC, PUNCT_DEC,
+	PUNCT_INC, PUNC_LEVEL_DEC, PUNC_LEVEL_INC, SPEAKUP_QUIET,
+	RATE_DEC, RATE_INC, READING_PUNC_DEC, READING_PUNC_INC,
+	SAY_ATTRIBUTES, SAY_FROM_LEFT, SAY_FROM_TOP, SAY_POSITION,
+	SAY_SCREEN, SAY_TO_BOTTOM, SAY_TO_RIGHT, SPK_KEY,
+	SPK_LOCK, SPEAKUP_OFF, SPEECH_KILL, SPELL_DELAY_DEC,
+	SPELL_DELAY_INC, SPELL_WORD, SPELL_PHONETIC, TONE_DEC,
+	TONE_INC, VOICE_DEC, VOICE_INC, VOL_DEC,
+	VOL_INC, CLEAR_WIN, SAY_WIN, SET_WIN,
+	ENABLE_WIN, SAY_WORD, SAY_NEXT_WORD, SAY_PREV_WORD, 0
+};
+
+static char *funcnames[] = {
+	"attribute bleep decrement", "attribute bleep increment",
+	"bleeps decrement", "bleeps increment",
+	"character, first", "character, last",
+	"character, say current",
+	"character, say hex and decimal", "character, say next",
+	"character, say phonetic", "character, say previous",
+	"cursor park", "cut",
+	"edit delimiters", "edit exnum",
+	"edit most", "edit repeats", "edit some",
+	"go to", "go to bottom edge", "go to left edge",
+	"go to right edge", "go to top edge", "help",
+	"line, say current", "line, say next",
+	"line, say previous", "line, say with indent",
+	"paste", "pitch decrement", "pitch increment",
+	"punctuation decrement", "punctuation increment",
+	"punc  level decrement", "punc level increment",
+	"quiet",
+	"rate decrement", "rate increment",
+	"reading punctuation decrement", "reading punctuation increment",
+	"say attributes",
+	"say from left", "say from top",
+	"say position", "say screen",
+	"say to bottom", "say to right",
+	"speakup", "speakup lock",
+	"speakup off", "speech kill",
+	"spell delay decrement", "spell delay increment",
+	"spell word", "spell word phoneticly",
+	"tone decrement", "tone increment",
+	"voice decrement", "voice increment",
+	"volume decrement", "volume increment",
+	"window, clear", "window, say",
+	"window, set", "window, silence",
+	"word, say current", "word, say next",
+	"word, say previous", 0
+};
+
+static u_char *state_tbl;
+static int cur_item = 0, nstates = 0;
+
+static void build_key_data( void )
+{
+	u_char *kp, counters[MAXFUNCS], ch, ch1;
+	u_short *p_key = key_buf, key;
+	int i, offset = 1;
+	nstates = (int)( state_tbl[-1] );
+	memset( counters, 0, sizeof( counters ) );
+	memset( key_offsets, 0, sizeof( key_offsets ) );
+	kp = state_tbl + nstates + 1;
+	while ( *kp++ ) { /* count occurrances of each function */
+		for ( i = 0; i < nstates; i++, kp++ ) {
+			if ( !*kp ) continue;
+			if ( (state_tbl[i]&16) != 0 && *kp == SPK_KEY )
+				continue;
+			counters[*kp]++;
+		}
+	}
+	for ( i = 0; i < MAXFUNCS; i++ ) {
+		if ( counters[i] == 0 ) continue;
+		key_offsets[i] = offset;
+		offset += ( counters[i]+1 );
+		if ( offset >= MAXKEYS ) break;
+	}
+/* leave counters set so high keycodes come first.
+   this is done so num pad and other extended keys maps are spoken before
+   the alpha with speakup type mapping. */
+	kp = state_tbl + nstates + 1;
+	while ( ( ch = *kp++ ) ) {
+		for ( i = 0; i < nstates; i++ ) {
+			ch1 = *kp++;
+			if ( !ch1 ) continue;
+			if ( (state_tbl[i]&16) != 0 && ch1 == SPK_KEY )
+				continue;
+			key = ( state_tbl[i]<<8 ) + ch;
+			counters[ch1]--;
+			if ( !(offset = key_offsets[ch1]) ) continue;
+			p_key = key_buf + offset + counters[ch1];
+			*p_key = key;
+		}
+	}
+}
+
+static void say_key( int key )
+{
+	int i, state = key>>8;
+	key &= 0xff;
+	for ( i = 0; i < 6; i++ ) {
+		if ( ( state & masks[i] ) )
+			synth_write_string( statenames[i] );
+	}
+	synth_write_string( " " );
+		synth_write_msg( keynames[--key] );
+}
+
+static int handle_help ( struct vc_data *vc, u_char type, u_char ch, u_short key )
+{
+	int i, n;
+	char *name;
+	u_char func, *kp;
+	u_short *p_keys, val;
+	if ( type == KT_LATIN ) {
+		if ( ch == SPACE ) {
+			special_handler = NULL;
+			synth_write_msg( "leaving help" );
+			return 1;
+		}
+		ch |= 32; /* lower case */
+		if ( ch < 'a' || ch > 'z' ) return -1;
+		if ( letter_offsets[ch-'a'] == -1 ) {
+			synth_write_string( "no commands for " );
+			synth_write( &ch, 1 );
+			synth_write( "\n", 1 );
+			return 1;
+		}
+	cur_item	= letter_offsets[ch-'a'];
+	} else if ( type == KT_CUR ) {
+		if ( ch == 0 && funcnames[cur_item+1] != NULL )
+			cur_item++;
+		else if ( ch == 3 && cur_item > 0 )
+			cur_item--;
+		else return -1;
+	} else if (type == KT_SPKUP && ch == SPEAKUP_HELP && !special_handler) {
+		special_handler = help_handler;
+		synth_write_msg( help_info );
+		build_key_data( ); /* rebuild each time in case new mapping */
+		return 1;
+	} else {
+		name = NULL;
+		if ( type != KT_SPKUP ) {
+			synth_write_msg( keynames[key-1] );
+			return 1;
+		}
+		for ( i = 0; funcvals[i] != 0 && !name; i++ ) {
+			if ( ch == funcvals[i] )
+				name = funcnames[i];
+		}
+		if ( !name ) return -1;
+		kp = our_keys[key]+1;
+		for ( i = 0; i < nstates; i++ ) {
+			if ( ch == kp[i] ) break;
+		}
+		key += ( state_tbl[i]<<8 );
+		say_key( key );
+		synth_write_string( "is " );
+		synth_write_msg( name );
+		return 1;
+	}
+	name = funcnames[cur_item];
+	func = funcvals[cur_item];
+	synth_write_string( name );
+	if ( key_offsets[func] == 0 ) {
+		synth_write_msg( " is unassigned" );
+		return 1;
+	}
+	p_keys = key_buf + key_offsets[func];
+	for ( n = 0; p_keys[n]; n++ ) {
+		val = p_keys[n];
+		if ( n > 0 ) synth_write_string( "or " );
+		say_key( val );
+	}
+	return 1;
+}
+
+static void __exit mod_help_exit( void )
+{
+	help_handler = 0;
+}
+
+static int __init mod_help_init( void )
+{
+	char start = SPACE;
+	int i;
+state_tbl = our_keys[0]+SHIFT_TBL_SIZE+2;
+	for (i = 0; i < 26; i++ ) letter_offsets[i] = -1;
+	for ( i = 0; funcnames[i]; i++ ) {
+		if ( start == *funcnames[i] ) continue;
+		start = *funcnames[i];
+		letter_offsets[(start&31)-1] = i;
+	}
+	help_handler = handle_help;
+	return 0;
+}
+
+module_init( mod_help_init );
+module_exit( mod_help_exit );
+MODULE_AUTHOR("David Borowski");
+MODULE_DESCRIPTION("Speakup keyboard help MODULE");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/speakup/speakup_keypc.c b/drivers/char/speakup/speakup_keypc.c
new file mode 100644
index 0000000000..86e090a9fe
--- /dev/null
+++ b/drivers/char/speakup/speakup_keypc.c
@@ -0,0 +1,190 @@
+/*
+* written by David Borowski
+
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+
+#define MY_SYNTH synth_keypc
+#define SYNTH_IO_EXTENT	0x04
+#define SWAIT udelay( 70 )
+#define synth_writable( ) ( inb_p( synth_port ) & 0x10 )
+#define synth_readable( ) ( inb_p( synth_port ) & 0x10 )
+#define synth_full( ) ( ( inb_p( synth_port ) & 0x80 ) == 0 )
+#define PROCSPEECH 0x1f
+#define SYNTH_CLEAR 0x03
+
+static int synth_port;
+static unsigned int synth_portlist[] =
+    { 0x2a8, 0 };
+
+static int
+oops( void )
+{
+	int s1, s2, s3, s4;
+	s1 = inb_p( synth_port );
+	s2 = inb_p( synth_port+1 );
+	s3 = inb_p( synth_port+2 );
+	s4 = inb_p( synth_port+3 );
+	pr_warn( "synth timeout %d %d %d %d\n", s1, s2, s3, s4 );
+	return 0;
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	int timeout;
+	while (  (  ch = *buf ) ) {
+		if ( ch == 0x0a ) ch = PROCSPEECH;
+		if ( synth_full( ) )
+			return buf;
+	timeout = 1000;
+		while ( synth_writable( ) )
+			if ( --timeout <= 0 ) return (char *) oops( );
+		outb_p( ch, synth_port );
+		SWAIT;
+	buf++;
+	}
+	return 0;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	int timeout;
+	synth_stop_timer( );
+	while (  synth_buff_out < synth_buff_in ) {
+ 		if ( synth_full( ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+	timeout = 1000;
+		while ( synth_writable( ) )
+			if ( --timeout <= 0 ) break;
+		if ( timeout <= 0 ) {
+			oops( );
+			break;
+		}
+		ch = *synth_buff_out++;
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+		outb_p( ch, synth_port );
+		SWAIT;
+		if ( jiffies >= jiff_max && ch == SPACE ) {
+	timeout = 1000;
+		while ( synth_writable( ) )
+			if ( --timeout <= 0 ) break;
+		if ( timeout <= 0 ) {
+			oops( );
+			break;
+			}
+			outb_p( PROCSPEECH, synth_port );
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	timeout = 1000;
+		while ( synth_writable( ) )
+			if ( --timeout <= 0 ) break;
+		if ( timeout <= 0 ) oops( );
+			else
+	outb_p( PROCSPEECH, synth_port );
+	synth_done(  );
+}
+
+static void synth_flush( void )
+{
+	outb_p( SYNTH_CLEAR, synth_port );
+}
+
+static int synth_probe( void )
+{
+	unsigned int port_val = 0;
+	int i = 0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	if ( synth_port_forced ) {
+		synth_port = synth_port_forced;
+		pr_info( "probe forced to %x by kernel command line\n", synth_port );
+		if ( synth_request_region( synth_port-1, SYNTH_IO_EXTENT ) ) {
+			pr_warn( "sorry, port already reserved\n" );
+			return -EBUSY;
+		}
+		port_val = inb( synth_port );
+	} else {
+		for( i=0; synth_portlist[i]; i++ ) {
+			if ( synth_request_region( synth_portlist[i], SYNTH_IO_EXTENT ) ) {
+				pr_warn( "request_region:  failed with 0x%x, %d\n",
+					synth_portlist[i], SYNTH_IO_EXTENT );
+				continue;
+			}
+			port_val = inb( synth_portlist[i] );
+			if ( port_val == 0x80 ) {
+				synth_port = synth_portlist[i];
+				break;
+			}
+		}
+	}
+	if ( port_val != 0x80 ) {
+		pr_info( "%s:  not found\n", synth->long_name );
+		synth_release_region( synth_portlist[i], SYNTH_IO_EXTENT );
+		synth_port = 0;
+		return -ENODEV;
+	}
+	pr_info( "%s:  %03x-%03x, driver version %s,\n", synth->long_name,
+		synth_port,	synth_port+SYNTH_IO_EXTENT-1,
+		synth->version );
+	return 0;
+}
+
+static void keynote_release(  void )
+{
+	if (  synth_port )
+		synth_release_region( synth_port, SYNTH_IO_EXTENT );
+	synth_port = 0;
+}
+
+static int synth_is_alive( void )
+{
+	synth_alive = 1;
+	return 1;
+}
+
+static const char init_string[] = "[t][n7,1][n8,0]";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "[f130]" },
+	{ CAPS_STOP, "[f90]" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\04%c ", 8, 0, 10, 81, -8, 0 },
+	{ PITCH, "[f%d]", 5, 0, 9, 40, 10, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_keypc = {"keypc", "1.1", "Keynote PC",
+	 init_string, 500, 50, 50, 1000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, keynote_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_ltlk.c b/drivers/char/speakup/speakup_ltlk.c
new file mode 100644
index 0000000000..f265327ba4
--- /dev/null
+++ b/drivers/char/speakup/speakup_ltlk.c
@@ -0,0 +1,229 @@
+/*
+ * originally written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#include "speakup_dtlk.h" /* local header file for LiteTalk values */
+
+#define MY_SYNTH synth_ltlk
+#define PROCSPEECH 0x0d
+#define synth_full( ) ( !( inb( synth_port_tts + UART_MSR ) & UART_MSR_CTS ) )
+
+static inline int wait_for_xmitr( void )
+{
+	static int timeouts = 0;	/* sequential number of timeouts */
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do { /* holding register empty? */
+		check = inb( synth_port_tts + UART_LSR );
+    		if ( --tmout == 0 ) {
+    			pr_warn( "%s:  register timed out\n", synth->long_name );
+			timeouts++;
+    			return 0;
+    		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do { /* CTS */
+		check = inb( synth_port_tts + UART_MSR );
+    		if ( --tmout == 0 ) {
+    			timeouts++;
+    			return 0;
+    		}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr( ) ) {
+		outb( ch, synth_port_tts );
+		return 1;
+	}
+	return 0;
+}
+
+static unsigned char spk_serial_in( void )
+{
+	int c, lsr, tmout = SPK_SERIAL_TIMEOUT;
+	do {
+		lsr = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn( "time out while waiting for input.\n" );
+			return 0xff;
+		}
+	} while ( ( lsr & UART_LSR_DR ) != UART_LSR_DR );
+	c = inb( synth_port_tts + UART_RX );
+	return ( unsigned char ) c;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+	synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == 0x0a ) ch = PROCSPEECH;
+		if ( !spk_serial_out( ch ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( jiffies >= jiff_max && ch == SPACE ) {
+			spk_serial_out( PROCSPEECH );
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	spk_serial_out( PROCSPEECH );
+	synth_done ( );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+	  outb( ch, synth_port_tts );
+	else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush( void )
+{
+	spk_serial_out( SYNTH_CLEAR );
+}
+
+static unsigned char get_index( void )
+{
+	int c, lsr;//, tmout = SPK_SERIAL_TIMEOUT;
+	lsr = inb( synth_port_tts + UART_LSR );
+	if ( ( lsr & UART_LSR_DR) == UART_LSR_DR )
+	{
+		c = inb( synth_port_tts + UART_RX );
+		return ( unsigned char ) c;
+	}
+	return 0;
+}
+
+/* interrogate the LiteTalk and print its settings */
+static void synth_interrogate( void )
+{
+	unsigned char *t, i;
+	unsigned char buf[50], rom_v[20];
+	synth_immediate( "\x18\x01?" );
+	for ( i = 0; i < 50; i++ ) {
+		buf[i] = spk_serial_in( );
+		if ( i > 2 && buf[i] == 0x7f ) break;
+	}
+	t = buf+2;
+	for ( i = 0; *t != '\r'; t++ ) {
+		rom_v[i] = *t;
+		if (i++ > 48) break;
+	}
+	rom_v[i] = 0;
+	pr_info( "%s: ROM version: %s\n", synth->long_name, rom_v );
+}
+
+static int serprobe( int index )
+{
+	struct serial_state *ser = spk_serial_init( index );
+	if ( ser == NULL ) return -1;
+	outb( 0, ser->port );
+	mdelay( 1 );
+	outb( '\r', ser->port );
+	/* ignore any error results, if port was forced */
+	if ( synth_port_forced ) return 0;
+	/* check for device... */
+	if ( !synth_immediate( "\x18" ) ) return 0;
+	spk_serial_release( );
+	synth_alive = 0; /* try next port */
+	return -1;
+}
+
+static int synth_probe( void )
+{
+	int i, failed=0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	for ( i=SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+	}
+	if ( failed ) {
+	  pr_info( "%s:  not found\n", synth->long_name );
+	  return -ENODEV;
+	}
+	synth_interrogate( );
+	pr_info( "%s: at  %03x-%03x, driver %s\n", synth->long_name,
+	       synth_port_tts, synth_port_tts + 7, synth->version );
+	return 0;
+}
+
+static int synth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	if ( !synth_alive && wait_for_xmitr( ) > 0 ) { /* restart */
+		synth_alive = 1;
+		synth_write_string( synth->init );
+		return 2;
+	} else pr_warn( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "\01@\x01\x31y\n\0";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x01+35p" },
+	{ CAPS_STOP, "\x01-35p" },
+	V_LAST_STRING
+};
+
+static num_var numvars[] = {
+	{ RATE, "\x01%ds", 8, 0, 9, 0, 0, 0 },
+	{ PITCH, "\x01%dp", 50, 0, 99, 0, 0, 0 },
+	{ VOL, "\x01%dv", 5, 0, 9, 0, 0, 0 },
+	{ TONE, "\x01%dx", 1, 0, 2, 0, 0, 0 },
+	{ PUNCT, "\x01%db", 7, 0, 15, 0, 0, 0 },
+	{ VOICE, "\x01%do", 0, 0, 7, 0, 0, 0 },
+	{ FREQ, "\x01%df", 5, 0, 9, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_ltlk = { "ltlk", "1.1", "LiteTalk",
+	init_string, 500, 50, 50, 5000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, get_index,
+	{"\x01%di",1,5,1} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_sftsyn.c b/drivers/char/speakup/speakup_sftsyn.c
new file mode 100644
index 0000000000..6318458b88
--- /dev/null
+++ b/drivers/char/speakup/speakup_sftsyn.c
@@ -0,0 +1,207 @@
+/* speakup_sftsynth.c - speakup driver to register and make available
+ * a user space device for software synthesizers.  written by: Kirk
+ * Reiser <kirk@braille.uwo.ca>
+
+		Copyright (C) 2003  Kirk Reiser.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.  */
+
+#include <linux/unistd.h>
+#include <asm/semaphore.h>
+#include <linux/miscdevice.h>   /* for misc_register, and SYNTH_MINOR */
+#include <linux/poll.h>  // for poll_wait()
+#include "spk_priv.h"
+
+#define MY_SYNTH synth_sftsyn
+#define SOFTSYNTH_MINOR 26  // might as well give it one more than /dev/synth
+#define PROCSPEECH 0x0d
+#define CLEAR_SYNTH 0x18
+
+static struct miscdevice synth_device;
+static int misc_registered = 0;
+static int dev_opened = 0;
+static struct semaphore sem;
+DECLARE_WAIT_QUEUE_HEAD ( wait_on_output );
+
+
+static int softsynth_open (struct inode *inode, struct file *fp)
+{
+        if (dev_opened) return -EBUSY;
+	//if ((fp->f_flags & O_ACCMODE) != O_RDONLY ) return -EPERM;
+	sema_init( &sem, 1 );
+	dev_opened++;
+        return 0;
+}
+
+static int softsynth_close (struct inode *inode, struct file *fp)
+{
+        fp->f_op = NULL;
+	dev_opened = 0;
+	return 0;
+}
+
+static ssize_t softsynth_read (struct file *fp, char *buf, size_t count, loff_t *pos)
+{
+	int chars_sent=0;
+
+        if (down_interruptible( &sem )) return -ERESTARTSYS;
+        while (synth_buff_in == synth_buff_out) {
+	  up ( &sem );
+	  if (fp->f_flags & O_NONBLOCK)
+	    return -EAGAIN;
+	  if (wait_event_interruptible( wait_on_output, (synth_buff_in > synth_buff_out)))
+	    return -ERESTARTSYS;
+	  if (down_interruptible( &sem )) return -ERESTARTSYS;
+	}
+
+	chars_sent = (count > synth_buff_in-synth_buff_out)
+	  ? synth_buff_in-synth_buff_out : count;
+	if (copy_to_user(buf, (char *) synth_buff_out, chars_sent)) {
+	  up ( &sem);
+	  return -EFAULT;
+	}
+	synth_buff_out += chars_sent;
+	*pos += chars_sent;
+	if (synth_buff_out >= synth_buff_in) {
+	  synth_done();
+	  *pos = 0;
+	}
+	up ( &sem );
+	return chars_sent;
+}
+
+int last_index=0;
+
+static ssize_t softsynth_write (struct file *fp, const char *buf, size_t count, loff_t *pos)
+{
+	int i;
+	char indbuf[5];
+	if (down_interruptible( &sem))
+		return -ERESTARTSYS;
+
+	if (copy_from_user(indbuf,buf,count))
+	{
+		up(&sem);
+		return -EFAULT;
+	}
+	up(&sem);
+	last_index=0;
+	for (i=0;i<strlen(indbuf);i++)
+		last_index=last_index*10+indbuf[i]-48;
+	return count;
+}
+
+static unsigned int softsynth_poll (struct file *fp, struct poll_table_struct *wait)
+{
+        poll_wait(fp, &wait_on_output, wait);
+
+	if (synth_buff_out < synth_buff_in)
+	  return (POLLIN | POLLRDNORM);
+	return 0;
+}
+
+static void
+softsynth_flush( void )
+{
+	synth_write( "\x18", 1 );
+}
+
+static unsigned char get_index( void )
+{
+	int rv;
+	rv=last_index;
+	last_index=0;
+	return rv;
+}
+
+static struct file_operations softsynth_fops = {
+        poll:softsynth_poll,
+        read:softsynth_read,
+	write:softsynth_write,
+        open:softsynth_open,
+        release:softsynth_close,
+};
+
+
+static int
+softsynth_probe( void )
+{
+
+        if ( misc_registered != 0 ) return 0;
+	memset( &synth_device, 0, sizeof( synth_device ) );
+        synth_device.minor = SOFTSYNTH_MINOR;
+        synth_device.name = "softsynth";
+        synth_device.fops = &softsynth_fops;
+        if ( misc_register ( &synth_device ) ) {
+	  pr_warn("Couldn't initialize miscdevice /dev/softsynth.\n" );
+	  return -ENODEV;
+        }
+
+        misc_registered = 1;
+	pr_info("initialized device: /dev/softsynth, node (MAJOR 10, MINOR 26)\n" );
+	return 0;
+}
+
+static void
+softsynth_release(void)
+{
+        misc_deregister( &synth_device );
+	misc_registered = 0;
+	pr_info("unregistered /dev/softsynth\n");
+}
+
+static void
+softsynth_start ( void )
+{
+        wake_up_interruptible ( &wait_on_output );
+}
+
+static int
+softsynth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	return 0;
+}
+
+static const char init_string[] = "\01@\x01\x31y\n";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x01+3p" },
+	{ CAPS_STOP, "\x01-3p" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\x01%ds", 5, 0, 9, 0, 0, 0 },
+	{ PITCH, "\x01%dp", 5, 0, 9, 0, 0, 0 },
+	{ VOL, "\x01%dv", 5, 0, 9, 0, 0, 0 },
+	{ TONE, "\x01%dx", 1, 0, 2, 0, 0, 0 },
+	{ PUNCT, "\x01%db", 7, 0, 15, 0, 0, 0 },
+	{ VOICE, "\x01%do", 0, 0, 7, 0, 0, 0 },
+	{ FREQ, "\x01%df", 5, 0, 9, 0, 0, 0 },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_sftsyn = { "sftsyn", "0.3", "software synth",
+	init_string, 0, 0, 0, 0, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, softsynth_probe, softsynth_release, NULL,
+	NULL, softsynth_start, softsynth_flush, softsynth_is_alive, NULL, NULL,
+	get_index, {"\x01%di",1,5,1} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_spkout.c b/drivers/char/speakup/speakup_spkout.c
new file mode 100644
index 0000000000..c79ee932a7
--- /dev/null
+++ b/drivers/char/speakup/speakup_spkout.c
@@ -0,0 +1,201 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#define MY_SYNTH synth_spkout
+#define SYNTH_CLEAR 0x18
+#define PROCSPEECH '\r'
+
+static int wait_for_xmitr(void)
+{
+	static int timeouts = 0;	/* sequential number of timeouts */
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ((synth_alive) && (timeouts >= NUM_DISABLE_TIMEOUTS)) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do {
+		check = inb(synth_port_tts + UART_LSR);
+		if (--tmout == 0) {
+			pr_warn("SpeakOut:  timed out\n");
+			timeouts++;
+			return 0;
+		}
+	} while ((check & BOTH_EMPTY) != BOTH_EMPTY);
+	tmout = SPK_XMITR_TIMEOUT;
+	do {
+		check = inb(synth_port_tts + UART_MSR);
+				if (--tmout == 0) {
+					timeouts++;
+					return 0;
+				}
+	} while ((check & UART_MSR_CTS) != UART_MSR_CTS);
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out(const char ch)
+{
+	if (synth_alive && wait_for_xmitr()) {
+		outb(ch, synth_port_tts);
+		return 1;
+	}
+	return 0;
+}
+
+static unsigned char spk_serial_in(void)
+{
+	int c, lsr, tmout = SPK_SERIAL_TIMEOUT;
+	do {
+		lsr = inb(synth_port_tts + UART_LSR);
+		if (--tmout == 0) return 0xff;
+	} while (!(lsr & UART_LSR_DR));
+	c = inb(synth_port_tts + UART_RX);
+	return (unsigned char) c;
+}
+
+static void do_catch_up(unsigned long data)
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+synth_stop_timer();
+	while (synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if (ch == 0x0a) ch = PROCSPEECH;
+		if (!spk_serial_out(ch )) {
+			synth_delay(synth_full_time);
+			return;
+		}
+		synth_buff_out++;
+		if (jiffies >= jiff_max && ch == SPACE ) {
+			spk_serial_out(PROCSPEECH);
+			synth_delay(synth_delay_time);
+			return;
+		}
+	}
+spk_serial_out(PROCSPEECH);
+	synth_done( );
+}
+
+static const char *synth_immediate (const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if (ch == 0x0a) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+          outb( ch, synth_port_tts );
+        else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush(void)
+{
+	while ((inb(synth_port_tts + UART_LSR) & BOTH_EMPTY) != BOTH_EMPTY);
+	outb(SYNTH_CLEAR, synth_port_tts);
+}
+
+static unsigned char get_index(void)
+{
+	int c, lsr;//, tmout = SPK_SERIAL_TIMEOUT;
+	lsr = inb( synth_port_tts + UART_LSR );
+	if ( ( lsr & UART_LSR_DR) == UART_LSR_DR )
+	{
+		c = inb( synth_port_tts + UART_RX );
+		return ( unsigned char ) c;
+	}
+	return 0;
+}
+
+static int serprobe(int index)
+{
+	struct serial_state *ser = spk_serial_init(index);
+	if ( ser == NULL ) return -1;
+	/* ignore any error results, if port was forced */
+	if (synth_port_forced) return 0;
+	/* check for speak out now... */
+	synth_immediate( "\x05[\x0f\r" );
+	mdelay( 10 ); //failed with no delay
+	if (spk_serial_in() == 0x0f) return 0;
+	synth_release_region(ser->port,8);
+			  synth_alive = 0;
+			  return -1;
+}
+
+static int synth_probe(void)
+{
+int i=0, failed=0;
+	pr_info("Probing for %s.\n", synth->long_name);
+	for (i=SPK_LO_TTY; i <= SPK_HI_TTY; i++) {
+	  if (( failed = serprobe( i )) == 0 ) break; /* found it */
+        }
+        if ( failed ) {
+		pr_info("%s Out:  not found\n", synth->long_name);
+		return -ENODEV;
+	}
+	pr_info("%s Out:  %03x-%03x, Driver version %s,\n", synth->long_name,
+   synth_port_tts, synth_port_tts + 7, synth->version);
+	return 0;
+}
+
+static int synth_is_alive(void)
+{
+	if (synth_alive) return 1;
+	if (wait_for_xmitr() > 0) { /* restart */
+		synth_alive = 1;
+		synth_write_string(synth->init );
+		return 2;
+	} else pr_warn("%s Out: can't restart synth\n", synth->long_name);
+	return 0;
+}
+
+static const char init_string[] = "\005W1\005I2\005C3";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x05P+" },
+	{ CAPS_STOP, "\x05P-" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\x05R%d", 7, 0, 9, 0, 0, 0 },
+	{ PITCH, "\x05P%d", 3, 0, 9, 0, 0, 0 },
+	{ VOL, "\x05V%d", 9, 0, 9, 0, 0, 0 },
+	{ TONE, "\x05T%c", 8, 0, 25, 65, 0, 0 },
+	{ PUNCT, "\x05M%c", 0, 0, 3, 0, 0, "nsma" },
+	V_LAST_NUM
+};
+
+struct spk_synth synth_spkout = {"spkout", "1.1", "Speakout",
+	 init_string, 500, 50, 50, 5000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL,
+	get_index, {"\x05[%c",1,5,1} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakup_txprt.c b/drivers/char/speakup/speakup_txprt.c
new file mode 100644
index 0000000000..80b01259d1
--- /dev/null
+++ b/drivers/char/speakup/speakup_txprt.c
@@ -0,0 +1,196 @@
+/*
+ * originially written by: Kirk Reiser <kirk@braille.uwo.ca>
+* this version considerably modified by David Borowski, david575@rogers.com
+
+		Copyright (C) 1998-99  Kirk Reiser.
+		Copyright (C) 2003 David Borowski.
+
+		This program is free software; you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation; either version 2 of the License, or
+		(at your option) any later version.
+
+		This program is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with this program; if not, write to the Free Software
+		Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ * this code is specificly written as a driver for the speakup screenreview
+ * package and is not a general device driver.
+		*/
+#include "spk_priv.h"
+#include "serialio.h"
+
+#define MY_SYNTH synth_txprt
+#define DRV_VERSION "1.2"
+#define SYNTH_CLEAR 0x18
+#define PROCSPEECH '\r' /* process speech char */
+
+static int timeouts = 0;	/* sequential number of timeouts */
+
+static int wait_for_xmitr( void )
+{
+	int check, tmout = SPK_XMITR_TIMEOUT;
+	if ( ( synth_alive ) && ( timeouts >= NUM_DISABLE_TIMEOUTS ) ) {
+		synth_alive = 0;
+		timeouts = 0;
+		return 0;
+	}
+	do {
+		check = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) {
+			pr_warn( "TXPRT:  timed out\n" );
+			timeouts++;
+			return 0;
+		}
+	} while ( ( check & BOTH_EMPTY ) != BOTH_EMPTY );
+	tmout = SPK_XMITR_TIMEOUT;
+	do {
+		check = inb( synth_port_tts + UART_MSR );
+				if ( --tmout == 0 ) {
+					timeouts++;
+					return 0;
+				}
+	} while ( ( check & UART_MSR_CTS ) != UART_MSR_CTS );
+	timeouts = 0;
+	return 1;
+}
+
+static inline int spk_serial_out( const char ch )
+{
+	if ( synth_alive && wait_for_xmitr( ) ) {
+		outb( ch, synth_port_tts );
+		return 1;
+	}
+	return 0;
+}
+
+static unsigned char spk_serial_in( void )
+{
+	int c, lsr, tmout = SPK_SERIAL_TIMEOUT;
+	do {
+		lsr = inb( synth_port_tts + UART_LSR );
+		if ( --tmout == 0 ) return 0xff;
+	} while ( !( lsr & UART_LSR_DR ) );
+	c = inb( synth_port_tts + UART_RX );
+	return ( unsigned char ) c;
+}
+
+static void do_catch_up( unsigned long data )
+{
+	unsigned long jiff_max = jiffies+synth_jiffy_delta;
+	u_char ch;
+
+	synth_stop_timer( );
+	while ( synth_buff_out < synth_buff_in ) {
+		ch = *synth_buff_out;
+		if ( ch == '\n' ) ch = PROCSPEECH;
+		if ( !spk_serial_out( ch ) ) {
+			synth_delay( synth_full_time );
+			return;
+		}
+		synth_buff_out++;
+		if ( jiffies >= jiff_max && ch == ' ' ) {
+			spk_serial_out( PROCSPEECH );
+			synth_delay( synth_delay_time );
+			return;
+		}
+	}
+	spk_serial_out( PROCSPEECH );
+	synth_done( );
+}
+
+static const char *synth_immediate ( const char *buf )
+{
+	u_char ch;
+	while ( ( ch = *buf ) ) {
+	if ( ch == 0x0a ) ch = PROCSPEECH;
+        if ( wait_for_xmitr( ) )
+	  outb( ch, synth_port_tts );
+	else return buf;
+	buf++;
+	}
+	return 0;
+}
+
+static void synth_flush ( void )
+{
+	spk_serial_out ( SYNTH_CLEAR );
+}
+
+static int serprobe( int index )
+{
+	u_char test=0;
+	struct serial_state *ser = spk_serial_init( index );
+	if ( ser == NULL ) return -1;
+	if ( synth_port_forced ) return 0;
+	/* check for txprt now... */
+	if (synth_immediate( "\x05$" ))
+	  pr_warn("synth_immediate could not unload\n");
+	if (synth_immediate( "\x05Ik" ))
+	  pr_warn("synth_immediate could not unload again\n");
+	if (synth_immediate( "\x05Q\r" ))
+	  pr_warn("synth_immediate could not unload a third time\n");
+	if ( ( test = spk_serial_in( ) ) == 'k' ) return 0;
+	else pr_warn( "synth returned %x on port %03lx\n", test, ser->port );
+	synth_release_region( ser->port,8 );
+	timeouts = synth_alive = 0;
+			  return -1;
+}
+
+static int synth_probe( void )
+{
+	int i, failed=0;
+	pr_info( "Probing for %s.\n", synth->long_name );
+	for ( i=SPK_LO_TTY; i <= SPK_HI_TTY; i++ ) {
+		if (( failed = serprobe( i )) == 0 ) break; /* found it */
+	}
+	if ( failed ) {
+		pr_info( "%s:  not found\n", synth->long_name );
+		return -ENODEV;
+	}
+	pr_info( "%s: %03x-%03x..\n", synth->long_name, (int) synth_port_tts, (int) synth_port_tts+7 );
+	pr_info( "%s: driver version %s.\n",  synth->long_name, synth->version);
+	return 0;
+}
+
+static int synth_is_alive( void )
+{
+	if ( synth_alive ) return 1;
+	if ( wait_for_xmitr( ) > 0 ) { /* restart */
+		synth_alive = 1;
+		synth_write_string( synth->init );
+		return 2;
+	}
+	pr_warn( "%s: can't restart synth\n", synth->long_name );
+	return 0;
+}
+
+static const char init_string[] = "\x05N1";
+
+static string_var stringvars[] = {
+	{ CAPS_START, "\x05P8" },
+	{ CAPS_STOP, "\x05P5" },
+	V_LAST_STRING
+};
+static num_var numvars[] = {
+	{ RATE, "\x05R%d", 5, 0, 9, 0, 0, 0 },
+	{ PITCH, "\x05P%d", 5, 0, 9, 0, 0, 0 },
+	{ VOL, "\x05V%d", 5, 0, 9, 0, 0, 0 },
+	{ TONE, "\x05T%c", 12, 0, 25, 61, 0, 0 },
+	V_LAST_NUM
+	 };
+
+struct spk_synth synth_txprt = {"txprt", DRV_VERSION, "Transport",
+	init_string, 500, 50, 50, 5000, 0, 0, SYNTH_CHECK,
+	stringvars, numvars, synth_probe, spk_serial_release, synth_immediate,
+	do_catch_up, NULL, synth_flush, synth_is_alive, NULL, NULL, NULL,
+	{NULL,0,0,0} };
+
+#ifdef MODULE
+#include "mod_code.c"
+#endif
diff --git a/drivers/char/speakup/speakupconf b/drivers/char/speakup/speakupconf
new file mode 100644
index 0000000000..a9a5a588b1
--- /dev/null
+++ b/drivers/char/speakup/speakupconf
@@ -0,0 +1,51 @@
+#!/bin/sh
+# script to load/save all the vars in speakup
+# speakupconf save or speakupconf load
+# if root saves in /etc/speakup/<synth_name> else in $HOME/.speakup/<synth_name>
+if [ $UID -eq "0" ]; then
+  SAVEDIR="/etc/speakup"
+else
+  SAVEDIR="$HOME/.speakup"
+fi
+if [ ! -d /proc/speakup ]; then
+  echo "no directory /proc/speakup"
+  exit 0
+fi
+SYNTH=`cat /proc/speakup/synth_name`
+case "$1" in
+*save)
+  if [ ! -d $SAVEDIR ] ; then
+    echo creating $SAVEDIR
+    mkdir $SAVEDIR
+  fi
+  if [ ! -d $SAVEDIR/$SYNTH ] ; then
+    echo creating $SAVEDIR/$SYNTH
+    mkdir $SAVEDIR/$SYNTH
+  fi
+  cd /proc/speakup
+  SAVELIST=`    find . -perm -6 |sed 's/..//' |fgrep -v synth`
+  for f in $SAVELIST; do
+    cp $f $SAVEDIR/$SYNTH/$f
+  done
+;;
+*load)
+  if [ ! -d $SAVEDIR ] ; then
+    echo no directory $SAVEDIR
+    exit 1
+  fi
+  if [ ! -d $SAVEDIR/$SYNTH ] ; then
+    echo no directory $SAVEDIR/$SYNTH
+    exit 1
+  fi
+  cd $SAVEDIR/$SYNTH
+  for f in *; do
+    if [ -w /proc/speakup/$f ]; then
+      cat $f >/proc/speakup/$f
+    fi
+  done
+;;
+*)
+  echo "usage: speakupconf load/save"
+  exit 1
+;;
+esac
diff --git a/drivers/char/speakup/speakupmap.h b/drivers/char/speakup/speakupmap.h
new file mode 100644
index 0000000000..c3d32556d2
--- /dev/null
+++ b/drivers/char/speakup/speakupmap.h
@@ -0,0 +1,65 @@
+	119, 62, 6,
+	0, 16, 17, 32, 20, 48, 0,
+	2, 0, 78, 0, 0, 0, 0,
+	3, 0, 79, 0, 0, 0, 0,
+	4, 0, 76, 0, 0, 0, 0,
+	5, 0, 77, 0, 0, 0, 0,
+	6, 0, 74, 0, 0, 0, 0,
+	7, 0, 75, 0, 0, 0, 0,
+	9, 0, 5, 0, 0, 0, 0,
+	10, 0, 4, 0, 0, 0, 0,
+	11, 0, 0, 0, 0, 1, 0,
+	12, 0, 27, 33, 0, 0, 0,
+	19, 0, 47, 0, 0, 0, 0,
+	21, 0, 29, 0, 0, 17, 0,
+	22, 0, 15, 0, 0, 0, 0,
+	23, 0, 14, 0, 0, 0, 28,
+	24, 0, 16, 0, 0, 0, 0,
+	25, 0, 30, 0, 0, 18, 0,
+	28, 0, 3, 0, 0, 26, 0,
+	35, 0, 31, 0, 0, 0, 0,
+	36, 0, 12, 0, 0, 0, 0,
+	37, 0, 11, 0, 0, 0, 22,
+	38, 0, 13, 0, 0, 0, 0,
+	39, 0, 32, 0, 0, 7, 0,
+	40, 0, 23, 0, 0, 0, 0,
+	44, 0, 44, 0, 0, 0, 0,
+	49, 0, 24, 0, 0, 0, 0,
+	50, 0, 9, 6, 0, 19, 0,
+	51, 0, 8, 0, 0, 0, 36,
+	52, 0, 10, 0, 0, 20, 0,
+	53, 0, 25, 0, 0, 0, 0,
+	55, 46, 1, 0, 0, 0, 0,
+	58, 128, 128, 0, 0, 0, 0,
+	59, 0, 45, 0, 0, 0, 0,
+	60, 0, 40, 0, 0, 0, 0,
+	61, 0, 41, 0, 0, 0, 0,
+	62, 0, 42, 0, 0, 0, 0,
+	63, 0, 34, 0, 0, 0, 0,
+	64, 0, 35, 0, 0, 0, 0,
+	65, 0, 37, 0, 0, 0, 0,
+	66, 0, 38, 0, 0, 0, 0,
+	67, 0, 66, 39, 0, 0, 0,
+	68, 0, 67, 0, 0, 0, 0,
+	71, 15, 19, 0, 0, 0, 0,
+	72, 14, 29, 0, 28, 0, 0,
+	73, 16, 17, 0, 0, 0, 0,
+	74, 27, 33, 0, 0, 0, 0,
+	75, 12, 31, 0, 0, 0, 0,
+	76, 11, 21, 0, 22, 0, 0,
+	77, 13, 32, 0, 0, 0, 0,
+	78, 23, 43, 0, 0, 0, 0,
+	79, 9, 20, 0, 0, 0, 0,
+	80, 8, 30, 0, 36, 0, 0,
+	81, 10, 18, 0, 0, 0, 0,
+	82, 128, 128, 0, 0, 0, 0,
+	83, 24, 25, 0, 0, 0, 0,
+	87, 0, 68, 0, 0, 0, 0,
+	88, 0, 69, 0, 0, 0, 0,
+	96, 3, 26, 0, 0, 0, 0,
+	98, 4, 5, 0, 0, 0, 0,
+	99, 2, 0, 0, 0, 0, 0,
+	104, 0, 6, 0, 0, 0, 0,
+	109, 0, 7, 0, 0, 0, 0,
+	125, 128, 128, 0, 0, 0, 0,
+	0, 119
diff --git a/drivers/char/speakup/speakupmap.map b/drivers/char/speakup/speakupmap.map
new file mode 100644
index 0000000000..45e67ff52b
--- /dev/null
+++ b/drivers/char/speakup/speakupmap.map
@@ -0,0 +1,92 @@
+spk key_f9 = punc_level_dec
+spk key_f10 = punc_level_inc
+spk key_f11 = reading_punc_dec
+spk key_f12 = reading_punc_inc
+spk key_1 = vol_dec
+spk key_2 =  vol_inc
+spk key_3 = pitch_dec
+spk key_4 = pitch_inc
+spk key_5 = rate_dec
+spk key_6 = rate_inc
+key_kpasterisk = toggle_cursoring
+spk key_kpasterisk = speakup_goto
+spk key_f1 = speakup_help
+spk key_f2 = set_win
+spk key_f3 = clear_win
+spk key_f4 = enable_win
+spk key_f5 = edit_some
+spk key_f6 = edit_most
+spk key_f7 = edit_delim
+spk key_f8 = edit_repeat
+shift spk key_f9 = edit_exnum
+ key_kp7 = say_prev_line
+spk key_kp7 = left_edge
+ key_kp8 = say_line
+double  key_kp8 = say_line_indent
+spk key_kp8 = say_from_top
+ key_kp9 = say_next_line
+spk  key_kp9 = top_edge
+ key_kpminus = speakup_parked
+spk key_kpminus = say_char_num
+ key_kp4 = say_prev_word
+spk key_kp4 = say_from_left
+ key_kp5 = say_word
+double key_kp5 = spell_word
+spk key_kp5 = spell_phonetic
+ key_kp6 = say_next_word
+spk key_kp6 = say_to_right
+ key_kpplus = say_screen
+spk key_kpplus = say_win
+ key_kp1 = say_prev_char
+spk key_kp1 = right_edge
+ key_kp2 = say_char
+spk key_kp2 = say_to_bottom
+double key_kp2 = say_phonetic_char
+ key_kp3 = say_next_char
+spk  key_kp3 = bottom_edge
+ key_kp0 = spk_key
+ key_kpdot = say_position
+spk key_kpdot = say_attributes
+key_kpenter = speakup_quiet
+spk key_kpenter = speakup_off
+key_sysrq = speech_kill
+ key_kpslash = speakup_cut
+spk key_kpslash = speakup_paste
+spk key_pageup = say_first_char
+spk key_pagedown = say_last_char
+key_capslock = spk_key
+ spk key_z = spk_lock
+key_leftmeta = spk_key
+ctrl spk key_0 = speakup_goto
+spk key_u = say_prev_line
+spk key_i = say_line
+double spk key_i = say_line_indent
+spk key_o = say_next_line
+spk key_minus = speakup_parked
+shift spk key_minus = say_char_num
+spk key_j = say_prev_word
+spk key_k = say_word
+double spk key_k = spell_word
+spk key_l = say_next_word
+spk key_m = say_prev_char
+spk key_comma = say_char
+double spk key_comma = say_phonetic_char
+spk key_dot = say_next_char
+spk key_n = say_position
+ ctrl spk key_m = left_edge
+ ctrl spk key_y = top_edge
+ ctrl spk key_dot = right_edge
+ctrl spk key_p = bottom_edge
+spk key_apostrophe = say_screen
+spk key_h = say_from_left
+spk key_y = say_from_top
+spk key_semicolon = say_to_right
+spk key_p = say_to_bottom
+spk key_slash = say_attributes
+ spk key_enter = speakup_quiet
+ ctrl  spk key_enter = speakup_off
+ spk key_9 = speakup_cut
+spk key_8 = speakup_paste
+shift spk key_m = say_first_char
+ ctrl spk key_semicolon = say_last_char
+spk key_r = read_all_doc
diff --git a/drivers/char/speakup/spk_con_module.h b/drivers/char/speakup/spk_con_module.h
new file mode 100644
index 0000000000..b5655d01a5
--- /dev/null
+++ b/drivers/char/speakup/spk_con_module.h
@@ -0,0 +1,43 @@
+/* written bby David Borowski.
+    Copyright (C ) 2003  David Borowski.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option ) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* included by ../console.c for speakup modularization */
+
+static spk_con_func addr_spk_allocate = NULL;
+static spk_con_func addr_spk_bs = NULL;
+static spk_write_func addr_spk_con_write = NULL;
+static spk_con_func addr_spk_con_update = NULL;
+
+#define speakup_allocate(c) if (addr_spk_allocate) (*addr_spk_allocate)(c)
+#define speakup_bs(c) if (addr_spk_bs) (*addr_spk_bs)(c)
+#define speakup_con_write(c,s,l) if (addr_spk_con_write) (*addr_spk_con_write)(c,s,l)
+#define speakup_con_update(c) if (addr_spk_con_update) (*addr_spk_con_update)(c)
+
+extern spk_key_func addr_spk_key;
+
+void speakup_set_addresses( spk_con_func allocate, spk_con_func bs,
+	spk_write_func con_write, spk_con_func con_update, spk_key_func key )
+{
+	addr_spk_allocate = allocate;
+	addr_spk_bs = bs;
+	addr_spk_con_write = con_write;
+	addr_spk_con_update = con_update;
+	addr_spk_key = key;
+}
+
+EXPORT_SYMBOL(speakup_set_addresses);
diff --git a/drivers/char/speakup/spk_priv.h b/drivers/char/speakup/spk_priv.h
new file mode 100644
index 0000000000..b8b1fe5e85
--- /dev/null
+++ b/drivers/char/speakup/spk_priv.h
@@ -0,0 +1,288 @@
+/* spk_priv.h
+   review functions for the speakup screen review package.
+   originally written by: Kirk Reiser and Andy Berdan.
+
+  extensively modified by David Borowski.
+
+    Copyright (C ) 1998  Kirk Reiser.
+    Copyright (C ) 2003  David Borowski.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option ) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef __SPEAKUP_PRIVATE_H
+#define __SPEAKUP_PRIVATE_H
+
+#define KERNEL
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <asm/io.h>		/* for inb_p, outb_p, inb, outb, etc... */
+#include <linux/delay.h>
+#include <linux/wait.h>		/* for wait_queue */
+#include <linux/init.h> /* for __init */
+#include <linux/module.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+#include <linux/speakup.h>
+#include "keyinfo.h"
+
+#define SHIFT_TBL_SIZE 64
+/* proc permissions */
+#define USER_R ( S_IFREG|S_IRUGO )
+#define USER_W ( S_IFREG|S_IWUGO )
+#define USER_RW ( S_IFREG|S_IRUGO|S_IWUGO )
+#define ROOT_W ( S_IFREG|S_IRUGO|S_IWUSR )
+
+#define V_LAST_STRING { -1, 0 }
+#define V_LAST_NUM { -1, 0, 0, 0, 0, 0, 0, 0 }
+#define TOGGLE_0 0, 0, 0, 1, 0, 0, 0
+#define TOGGLE_1 0, 1, 0, 1, 0, 0, 0
+#define MAXVARLEN 15
+#define TAB 0x9
+#define SPACE 0x20
+#define CAP_A 'A'
+#define CAP_Z 'Z'
+#define SYNTH_OK 0x0001
+#define B_ALPHA 0x0002
+#define ALPHA 0x0003
+#define B_CAP 0x0004
+#define A_CAP 0x0007
+#define B_NUM 0x0008
+#define NUM 0x0009
+#define ALPHANUM ( B_ALPHA|B_NUM )
+#define SOME 0x0010
+#define MOST 0x0020
+#define PUNC 0x0040
+#define A_PUNC 0x0041
+#define B_WDLM 0x0080
+#define WDLM 0x0081
+#define B_EXNUM 0x0100
+#define CH_RPT 0x0200
+#define B_CTL 0x0400
+#define A_CTL B_CTL+SYNTH_OK
+#define B_SYM 0x0800
+#define B_CAPSYM B_CAP|B_SYM
+#define IS_WDLM( x ) ( spk_chartab[( ( u_char )x )]&B_WDLM )
+#define IS_CHAR( x, type ) ( spk_chartab[( ( u_char )x )]&type )
+#define SET_DEFAULT -4
+#define E_RANGE -3
+#define E_TOOLONG -2
+#define E_UNDEF -1
+enum { VAR_NUM = 0, VAR_TIME, VAR_STRING, VAR_PROC };
+enum { E_DEFAULT = 0, E_SET, E_INC, E_DEC };
+
+#define PROC_READ_PROTOTYPE char *page, char **start, off_t off, \
+			int count, int *eof, void *data
+#define PROC_WRITE_PROTOTYPE struct file *file, const char *buffer, \
+		u_long count, void *data
+
+#ifndef MIN
+#define MIN( a, b ) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )
+#endif
+
+typedef int (*special_func)( struct vc_data *vc, u_char type, u_char ch, u_short key );
+typedef struct st_var_header var_header;
+typedef struct st_num_var num_var;
+typedef struct st_string_var string_var;
+typedef struct st_proc_var proc_var;
+
+struct st_var_header {
+	char *name;
+	short var_id, var_type, proc_mode;
+	void *proc_entry;
+	void *p_val; /* ptr to programs variable to store value */
+	void *data; /* ptr to the vars data */
+};
+
+/* next are data for different var types */
+struct st_num_var {
+	short var_id;
+	char *synth_fmt;
+	short default_val, low, high;
+	short offset, multiplier; /* for fiddling rates etc. */
+	char *out_str; /* if synth needs char representation of number */
+	short value; /* current value */
+};
+struct st_string_var {
+	short var_id;
+	char *default_val;
+};
+struct st_proc_var {
+	short var_id;
+	int ( *read_proc )( PROC_READ_PROTOTYPE );
+	int ( *write_proc )( PROC_WRITE_PROTOTYPE );
+	short value;
+};
+
+typedef struct st_bits_data bits_data;
+struct st_bits_data { /* punc, repeats, word delim bits */
+	char *name;
+	char *value;
+	short mask;
+};
+
+extern var_header *var_ptrs[MAXVARS];
+extern proc_var spk_proc_vars[];
+char *xlate( char * );
+char *speakup_s2i( char *, short * );
+int speakup_register_var( num_var *var );
+void speakup_unregister_var( short var_id );
+extern var_header *get_var_header( short var_id );
+extern int set_num_var( short val, var_header *var, int how );
+
+#define COLOR_BUFFER_SIZE 160
+struct spk_highlight_color_track{
+	unsigned int bgcount[8];	// Count of each background color
+	char highbuf[8][COLOR_BUFFER_SIZE];	// Buffer for characters drawn with each background color
+	unsigned int highsize[8];	// Current index into highbuf
+	u_long rpos[8],rx[8],ry[8];	// Reading Position for each color
+	ulong cy;			// Real Cursor Y Position
+};
+
+/* let's develop a structure for keeping our goodies in. */
+typedef struct st_spk_t spk_t;
+#define spk_size (sizeof( spk_t))
+struct st_spk_t {
+	u_long reading_x, cursor_x;
+	u_long reading_y, cursor_y;
+	u_long reading_pos, cursor_pos;
+	u_long go_x, go_pos;
+	u_long w_top, w_bottom, w_left, w_right;
+	u_char w_start, w_enabled;
+	u_char reading_attr, old_attr;
+	char parked, shut_up;
+	struct spk_highlight_color_track ht;
+};
+
+/*struct spk_screen_buf {
+	unsigned int rows;
+	unsigned int cols;
+	char *scrbuff;
+	unsigned int bgcolors[8];
+	char *diffbuff;
+	unsigned int diffcolors[8];
+	unsigned int diffindex[8];
+};*/
+
+/* now some defines to make these easier to use. */
+#define spk_shut_up speakup_console[vc->vc_num]->shut_up
+#define spk_killed ( speakup_console[vc->vc_num]->shut_up & 0x40 )
+#define spk_x speakup_console[vc->vc_num]->reading_x
+#define spk_cx speakup_console[vc->vc_num]->cursor_x
+#define spk_y speakup_console[vc->vc_num]->reading_y
+#define spk_cy speakup_console[vc->vc_num]->cursor_y
+#define spk_pos ( speakup_console[vc->vc_num]->reading_pos )
+#define spk_cp speakup_console[vc->vc_num]->cursor_pos
+#define goto_pos ( speakup_console[vc->vc_num]->go_pos )
+#define goto_x ( speakup_console[vc->vc_num]->go_x )
+#define win_top ( speakup_console[vc->vc_num]->w_top )
+#define win_bottom ( speakup_console[vc->vc_num]->w_bottom )
+#define win_left ( speakup_console[vc->vc_num]->w_left )
+#define win_right ( speakup_console[vc->vc_num]->w_right )
+#define win_start ( speakup_console[vc->vc_num]->w_start )
+#define win_enabled ( speakup_console[vc->vc_num]->w_enabled )
+#define spk_attr speakup_console[vc->vc_num]->reading_attr
+#define spk_old_attr speakup_console[vc->vc_num]->old_attr
+#define spk_parked speakup_console[vc->vc_num]->parked
+#define SYNTH_CHECK 20030716 /* today's date ought to do for check value */
+/* synth flags, for odd synths */
+#define SF_DEC 1 /* to fiddle puncs in alpha strings so it doesn't spell */
+
+struct synth_indexing {
+	char *command;
+	unsigned char lowindex;
+	unsigned char highindex;
+	unsigned char currindex;
+
+};
+
+struct spk_synth {
+	const char *name;
+	const char *version;
+	const char *long_name;
+	const char *init;
+	short delay, trigger, jiffies, full, flush_wait, flags;
+	const int checkval; /* for validating a proper synth module */
+	string_var *string_vars;
+	num_var *num_vars;
+	int ( *probe )( void );
+	void ( *release )( void );
+	const char *( *synth_immediate )( const char *buff );
+	void ( *catch_up )( u_long data );
+	void ( *start )( void );
+	void ( *flush )( void );
+	int ( *is_alive )( void );
+	int ( *synth_adjust )( var_header *var );
+	void ( *read_buff_add )(u_char);
+	unsigned char ( *get_index )( void );
+	struct synth_indexing indexing;
+};
+
+extern struct spk_synth *synth;
+int synth_request_region( u_long, u_long );
+int synth_release_region( u_long, u_long );
+void spk_serial_release( void );
+extern int synth_port_tts, synth_port_forced;
+extern volatile int synth_timer_active;
+#define declare_timer( name ) struct timer_list name;
+#define start_timer( name ) if ( ! name.entry.prev ) add_timer ( & name )
+#define stop_timer( name ) del_timer ( & name ); name.entry.prev = NULL
+#define declare_sleeper( name ) wait_queue_head_t name
+#define init_sleeper( name ) 	init_waitqueue_head ( &name )
+extern declare_sleeper( synth_sleeping_list );
+extern declare_timer( synth_timer );
+extern char str_caps_start[], str_caps_stop[];
+extern short no_intr, say_ctrl, say_word_ctl, punc_level;
+extern short reading_punc, attrib_bleep, bleeps;
+extern short bleep_time, bell_pos;
+extern short spell_delay, key_echo, punc_mask;
+extern short synth_jiffy_delta, synth_delay_time;
+extern short synth_trigger_time, synth_full_time;
+extern short cursor_timeout, pitch_shift, synth_flags;
+extern int synth_alive;
+extern u_char synth_buffer[];  /* guess what this is for! */
+extern u_char *buffer_highwater;
+extern volatile u_char *synth_buff_in, *synth_buff_out;
+int synth_init( char *name );
+int do_synth_init( struct spk_synth *in_synth );
+void synth_release( void );
+void synth_add( struct spk_synth *in_synth );
+void synth_remove( struct spk_synth *in_synth );
+struct serial_state * spk_serial_init( int index );
+void synth_delay( int ms );
+void synth_stop_timer( void );
+int synth_done( void );
+void do_flush( void );
+void synth_buffer_add( char ch );
+void synth_write( const char *buf, size_t count );
+void synth_write_string( const char *buf );
+void synth_write_msg( const char *buf );
+void synth_write_immedita( const char *buf );
+void speakup_register_devsynth ( void );
+void start_serial_interrupt( int );
+void stop_serial_interrupt( void );
+int synth_supports_indexing( void );
+
+#ifndef pr_info
+#define pr_info(fmt,arg...) printk(KERN_INFO fmt,##arg)
+#endif
+#ifndef pr_warn
+#define pr_warn(fmt,arg...) printk(KERN_WARNING fmt,##arg)
+#endif
+
+#endif
diff --git a/drivers/char/speakup/synthlist.h b/drivers/char/speakup/synthlist.h
new file mode 100644
index 0000000000..c89df9b058
--- /dev/null
+++ b/drivers/char/speakup/synthlist.h
@@ -0,0 +1,51 @@
+/* this is included two times */
+#if defined(PASS2)
+/* table of built in synths */
+#define SYNTH_DECL(who) &synth_##who,
+#else
+/* declare extern built in synths */
+#define SYNTH_DECL(who) extern struct spk_synth synth_##who;
+#define PASS2
+#endif
+
+#ifdef CONFIG_SPEAKUP_ACNTPC
+SYNTH_DECL(acntpc)
+#endif
+#ifdef CONFIG_SPEAKUP_ACNTSA
+SYNTH_DECL(acntsa)
+#endif
+#ifdef CONFIG_SPEAKUP_APOLLO
+SYNTH_DECL(apollo)
+#endif
+#ifdef CONFIG_SPEAKUP_AUDPTR
+SYNTH_DECL(audptr)
+#endif
+#ifdef CONFIG_SPEAKUP_BNS
+SYNTH_DECL(bns)
+#endif
+#ifdef CONFIG_SPEAKUP_DECEXT
+SYNTH_DECL(decext)
+#endif
+#ifdef CONFIG_SPEAKUP_DECTLK
+SYNTH_DECL(dectlk)
+#endif
+#ifdef CONFIG_SPEAKUP_DTLK
+SYNTH_DECL(dtlk)
+#endif
+#ifdef CONFIG_SPEAKUP_KEYPC
+SYNTH_DECL(keypc)
+#endif
+#ifdef CONFIG_SPEAKUP_LTLK
+SYNTH_DECL(ltlk)
+#endif
+#ifdef CONFIG_SPEAKUP_SFTSYN
+SYNTH_DECL(sftsyn)
+#endif
+#ifdef CONFIG_SPEAKUP_SPKOUT
+SYNTH_DECL(spkout)
+#endif
+#ifdef CONFIG_SPEAKUP_TXPRT
+SYNTH_DECL(txprt)
+#endif
+
+#undef SYNTH_DECL
diff --git a/drivers/char/vt.c b/drivers/char/vt.c
index 0900d1dbee..a232682902 100644
--- a/drivers/char/vt.c
+++ b/drivers/char/vt.c
@@ -98,6 +98,10 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
+#include <linux/speakup.h>
+#ifdef CONFIG_SPEAKUP_MODULE
+#include "speakup/spk_con_module.h"
+#endif
 
 const struct consw *conswitchp;
 
@@ -725,6 +729,7 @@ int vc_allocate(unsigned int currcons)	/* return 0 on success */
 	    }
 	    vc->vc_kmalloced = 1;
 	    vc_init(vc, vc->vc_rows, vc->vc_cols, 1);
+	    speakup_allocate(vc);
 	}
 	return 0;
 }
@@ -978,6 +983,7 @@ static void lf(struct vc_data *vc)
 		vc->vc_pos += vc->vc_size_row;
 	}
 	vc->vc_need_wrap = 0;
+	speakup_con_write(vc, "\n",1);
 }
 
 static void ri(struct vc_data *vc)
@@ -1006,6 +1012,7 @@ static inline void bs(struct vc_data *vc)
 		vc->vc_pos -= 2;
 		vc->vc_x--;
 		vc->vc_need_wrap = 0;
+		speakup_bs(vc);
 	}
 }
 
@@ -1543,6 +1550,7 @@ static void do_con_trol(struct tty_struct *tty, struct vc_data *vc, int c)
 				break;
 		}
 		vc->vc_pos += (vc->vc_x << 1);
+		speakup_con_write(vc, " ", 1);
 		return;
 	case 10: case 11: case 12:
 		lf(vc);
@@ -2073,6 +2081,7 @@ static int do_con_write(struct tty_struct *tty, const unsigned char *buf, int co
 			}
 			if (vc->vc_decim)
 				insert_char(vc, 1);
+			speakup_con_write(vc, (char *) &tc, 1);
 			scr_writew(himask ?
 				     ((vc->vc_attr << 8) & ~himask) + ((tc & 0x100) ? himask : 0) + (tc & 0xff) :
 				     (vc->vc_attr << 8) + tc,
@@ -2098,6 +2107,7 @@ static int do_con_write(struct tty_struct *tty, const unsigned char *buf, int co
 	release_console_sem();
 
 out:
+	speakup_con_update(vc);
 	return n;
 #undef FLUSH
 }
@@ -2123,6 +2133,7 @@ static void console_callback(void *ignored)
 			/* we only changed when the console had already
 			   been allocated - a new console is not created
 			   in an interrupt routine */
+			speakup_con_update(vc_cons[want_console].d);
 		}
 		want_console = -1;
 	}
@@ -2141,6 +2152,7 @@ static void console_callback(void *ignored)
 		do_blank_screen(0);
 		blank_timer_expired = 0;
 	}
+	speakup_con_update(vc_cons[fg_console].d);
 
 	release_console_sem();
 }
@@ -2186,6 +2198,7 @@ static void vt_console_print(struct console *co, const char *b, unsigned count)
 		/* printk("vt_console_print: tty %d not allocated ??\n", currcons+1); */
 		goto quit;
 	}
+	speakup_con_update(vc_cons[fg_console].d);
 
 	if (vc->vc_mode != KD_TEXT)
 		goto quit;
@@ -2198,6 +2211,7 @@ static void vt_console_print(struct console *co, const char *b, unsigned count)
 
 	/* Contrived structure to try to emulate original need_wrap behaviour
 	 * Problems caused when we have need_wrap set on '\n' character */
+	speakup_con_write(vc, b, count);
 	while (count--) {
 		c = *b++;
 		if (c == 10 || c == 13 || c == 8 || vc->vc_need_wrap) {
@@ -2242,6 +2256,7 @@ static void vt_console_print(struct console *co, const char *b, unsigned count)
 		}
 	}
 	set_cursor(vc);
+	speakup_con_update(vc);
 
 quit:
 	clear_bit(0, &printing);
@@ -2587,6 +2602,7 @@ static int __init con_init(void)
 	master_display_fg = vc = vc_cons[currcons].d;
 	set_origin(vc);
 	save_screen(vc);
+	speakup_init(vc);
 	gotoxy(vc, vc->vc_x, vc->vc_y);
 	csi_J(vc, 0);
 	update_screen(vc);
@@ -3253,3 +3269,4 @@ EXPORT_SYMBOL(vc_cons);
 EXPORT_SYMBOL(take_over_console);
 EXPORT_SYMBOL(give_up_console);
 #endif
+EXPORT_SYMBOL(screen_glyph);
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 4fe3da3c66..2c6ce62c7a 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -284,19 +284,19 @@ static struct input_device_id *input_match_device(struct input_device_id *id, st
 	for (; id->flags || id->driver_info; id++) {
 
 		if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
-			if (id->id.bustype != dev->id.bustype)
+			if (id->bustype != dev->id.bustype)
 				continue;
 
 		if (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)
-			if (id->id.vendor != dev->id.vendor)
+			if (id->vendor != dev->id.vendor)
 				continue;
 
 		if (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)
-			if (id->id.product != dev->id.product)
+			if (id->product != dev->id.product)
 				continue;
 
 		if (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)
-			if (id->id.version != dev->id.version)
+			if (id->version != dev->id.version)
 				continue;
 
 		MATCH_BIT(evbit,  EV_MAX);
diff --git a/drivers/md/Kconfig b/drivers/md/Kconfig
index ac43f98062..9a7bbb2157 100644
--- a/drivers/md/Kconfig
+++ b/drivers/md/Kconfig
@@ -236,5 +236,16 @@ config DM_MULTIPATH_EMC
 	---help---
 	  Multipath support for EMC CX/AX series hardware.
 
+config BLK_DEV_DM_BBR
+	tristate "Bad Block Relocation Device Target (EXPERIMENTAL)"
+	depends on BLK_DEV_DM && EXPERIMENTAL
+	---help---
+	  Support for devices with software-based bad-block-relocation.
+
+	  To compile this as a module, choose M here: the module will be
+	  called dm-bbr.
+
+	  If unsure, say N.
+
 endmenu
 
diff --git a/drivers/md/Makefile b/drivers/md/Makefile
index d3efedf6a6..84c4ed7c3e 100644
--- a/drivers/md/Makefile
+++ b/drivers/md/Makefile
@@ -37,6 +37,7 @@ obj-$(CONFIG_DM_MULTIPATH_EMC)	+= dm-emc.o
 obj-$(CONFIG_DM_SNAPSHOT)	+= dm-snapshot.o
 obj-$(CONFIG_DM_MIRROR)		+= dm-mirror.o
 obj-$(CONFIG_DM_ZERO)		+= dm-zero.o
+obj-$(CONFIG_BLK_DEV_DM_BBR)	+= dm-bbr.o
 
 quiet_cmd_unroll = UNROLL  $@
       cmd_unroll = $(PERL) $(srctree)/$(src)/unroll.pl $(UNROLL) \
diff --git a/drivers/md/dm-bbr.c b/drivers/md/dm-bbr.c
new file mode 100644
index 0000000000..81aed5b26c
--- /dev/null
+++ b/drivers/md/dm-bbr.c
@@ -0,0 +1,1003 @@
+/*
+ *   (C) Copyright IBM Corp. 2002, 2004
+ *
+ *   This program is free software;  you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program;  if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * linux/drivers/md/dm-bbr.c
+ *
+ * Bad-block-relocation (BBR) target for device-mapper.
+ *
+ * The BBR target is designed to remap I/O write failures to another safe
+ * location on disk. Note that most disk drives have BBR built into them,
+ * this means that our software BBR will be only activated when all hardware
+ * BBR replacement sectors have been used.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/bio.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/mempool.h>
+#include <linux/workqueue.h>
+#include <linux/vmalloc.h>
+
+#include "dm.h"
+#include "dm-bio-list.h"
+#include "dm-bio-record.h"
+#include "dm-bbr.h"
+#include "dm-io.h"
+
+#define SECTOR_SIZE (1 << SECTOR_SHIFT)
+
+static struct workqueue_struct *dm_bbr_wq = NULL;
+static void bbr_remap_handler(void *data);
+static kmem_cache_t *bbr_remap_cache;
+static kmem_cache_t *bbr_io_cache;
+static mempool_t *bbr_io_pool;
+
+/**
+ * bbr_binary_tree_destroy
+ *
+ * Destroy the binary tree.
+ **/
+static void bbr_binary_tree_destroy(struct bbr_runtime_remap *root)
+{
+	struct bbr_runtime_remap **link = NULL;
+	struct bbr_runtime_remap *node = root;
+
+	while (node) {
+		if (node->left) {
+			link = &(node->left);
+			node = node->left;
+			continue;
+		}
+		if (node->right) {
+			link = &(node->right);
+			node = node->right;
+			continue;
+		}
+
+		kmem_cache_free(bbr_remap_cache, node);
+		if (node == root) {
+			/* If root is deleted, we're done. */
+			break;
+		}
+
+		/* Back to root. */
+		node = root;
+		*link = NULL;
+	}
+}
+
+static void bbr_free_remap(struct bbr_private *bbr_id)
+{
+	spin_lock_irq(&bbr_id->remap_root_lock);
+	bbr_binary_tree_destroy(bbr_id->remap_root);
+	bbr_id->remap_root = NULL;
+	spin_unlock_irq(&bbr_id->remap_root_lock);
+}
+
+static struct bbr_private *bbr_alloc_private(void)
+{
+	struct bbr_private *bbr_id;
+
+	bbr_id = kmalloc(sizeof(*bbr_id), GFP_KERNEL);
+	if (bbr_id) {
+		memset(bbr_id, 0, sizeof(*bbr_id));
+		INIT_WORK(&bbr_id->remap_work, bbr_remap_handler, bbr_id);
+		bbr_id->remap_root_lock = SPIN_LOCK_UNLOCKED;
+		bbr_id->remap_ios_lock = SPIN_LOCK_UNLOCKED;
+		bbr_id->in_use_replacement_blks = (atomic_t)ATOMIC_INIT(0);
+	}
+
+	return bbr_id;
+}
+
+static void bbr_free_private(struct bbr_private *bbr_id)
+{
+	if (bbr_id->bbr_table) {
+		vfree(bbr_id->bbr_table);
+	}
+	bbr_free_remap(bbr_id);
+	kfree(bbr_id);
+}
+
+static u32 crc_table[256];
+static u32 crc_table_built = 0;
+
+static void build_crc_table(void)
+{
+	u32 i, j, crc;
+
+	for (i = 0; i <= 255; i++) {
+		crc = i;
+		for (j = 8; j > 0; j--) {
+			if (crc & 1)
+				crc = (crc >> 1) ^ CRC_POLYNOMIAL;
+			else
+				crc >>= 1;
+		}
+		crc_table[i] = crc;
+	}
+	crc_table_built = 1;
+}
+
+static u32 calculate_crc(u32 crc, void *buffer, u32 buffersize)
+{
+	unsigned char *current_byte;
+	u32 temp1, temp2, i;
+
+	current_byte = (unsigned char *) buffer;
+	/* Make sure the crc table is available */
+	if (!crc_table_built)
+		build_crc_table();
+	/* Process each byte in the buffer. */
+	for (i = 0; i < buffersize; i++) {
+		temp1 = (crc >> 8) & 0x00FFFFFF;
+		temp2 = crc_table[(crc ^ (u32) * current_byte) &
+				  (u32) 0xff];
+		current_byte++;
+		crc = temp1 ^ temp2;
+	}
+	return crc;
+}
+
+/**
+ * le_bbr_table_sector_to_cpu
+ *
+ * Convert bbr meta data from on-disk (LE) format
+ * to the native cpu endian format.
+ **/
+static void le_bbr_table_sector_to_cpu(struct bbr_table *p)
+{
+	int i;
+	p->signature		= le32_to_cpup(&p->signature);
+	p->crc			= le32_to_cpup(&p->crc);
+	p->sequence_number	= le32_to_cpup(&p->sequence_number);
+	p->in_use_cnt		= le32_to_cpup(&p->in_use_cnt);
+	for (i = 0; i < BBR_ENTRIES_PER_SECT; i++) {
+		p->entries[i].bad_sect =
+			le64_to_cpup(&p->entries[i].bad_sect);
+		p->entries[i].replacement_sect =
+			le64_to_cpup(&p->entries[i].replacement_sect);
+	}
+}
+
+/**
+ * cpu_bbr_table_sector_to_le
+ *
+ * Convert bbr meta data from cpu endian format to on-disk (LE) format
+ **/
+static void cpu_bbr_table_sector_to_le(struct bbr_table *p,
+				       struct bbr_table *le)
+{
+	int i;
+	le->signature		= cpu_to_le32p(&p->signature);
+	le->crc			= cpu_to_le32p(&p->crc);
+	le->sequence_number	= cpu_to_le32p(&p->sequence_number);
+	le->in_use_cnt		= cpu_to_le32p(&p->in_use_cnt);
+	for (i = 0; i < BBR_ENTRIES_PER_SECT; i++) {
+		le->entries[i].bad_sect =
+			cpu_to_le64p(&p->entries[i].bad_sect);
+		le->entries[i].replacement_sect =
+			cpu_to_le64p(&p->entries[i].replacement_sect);
+	}
+}
+
+/**
+ * validate_bbr_table_sector
+ *
+ * Check the specified BBR table sector for a valid signature and CRC. If it's
+ * valid, endian-convert the table sector.
+ **/
+static int validate_bbr_table_sector(struct bbr_table *p)
+{
+	int rc = 0;
+	int org_crc, final_crc;
+
+	if (le32_to_cpup(&p->signature) != BBR_TABLE_SIGNATURE) {
+		DMERR("dm-bbr: BBR table signature doesn't match!");
+		DMERR("dm-bbr: Found 0x%x. Expecting 0x%x",
+		      le32_to_cpup(&p->signature), BBR_TABLE_SIGNATURE);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	if (!p->crc) {
+		DMERR("dm-bbr: BBR table sector has no CRC!");
+		rc = -EINVAL;
+		goto out;
+	}
+
+	org_crc = le32_to_cpup(&p->crc);
+	p->crc = 0;
+	final_crc = calculate_crc(INITIAL_CRC, (void *)p, sizeof(*p));
+	if (final_crc != org_crc) {
+		DMERR("dm-bbr: CRC failed!");
+		DMERR("dm-bbr: Found 0x%x. Expecting 0x%x",
+		      org_crc, final_crc);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	p->crc = cpu_to_le32p(&org_crc);
+	le_bbr_table_sector_to_cpu(p);
+
+out:
+	return rc;
+}
+
+/**
+ * bbr_binary_tree_insert
+ *
+ * Insert a node into the binary tree.
+ **/
+static void bbr_binary_tree_insert(struct bbr_runtime_remap **root,
+				   struct bbr_runtime_remap *newnode)
+{
+	struct bbr_runtime_remap **node = root;
+	while (node && *node) {
+		if (newnode->remap.bad_sect > (*node)->remap.bad_sect) {
+			node = &((*node)->right);
+		} else {
+			node = &((*node)->left);
+		}
+	}
+
+	newnode->left = newnode->right = NULL;
+	*node = newnode;
+}
+
+/**
+ * bbr_binary_search
+ *
+ * Search for a node that contains bad_sect == lsn.
+ **/
+static struct bbr_runtime_remap *bbr_binary_search(
+	struct bbr_runtime_remap *root,
+	u64 lsn)
+{
+	struct bbr_runtime_remap *node = root;
+	while (node) {
+		if (node->remap.bad_sect == lsn) {
+			break;
+		}
+		if (lsn > node->remap.bad_sect) {
+			node = node->right;
+		} else {
+			node = node->left;
+		}
+	}
+	return node;
+}
+
+/**
+ * bbr_insert_remap_entry
+ *
+ * Create a new remap entry and add it to the binary tree for this node.
+ **/
+static int bbr_insert_remap_entry(struct bbr_private *bbr_id,
+				  struct bbr_table_entry *new_bbr_entry)
+{
+	struct bbr_runtime_remap *newnode;
+
+	newnode = kmem_cache_alloc(bbr_remap_cache, GFP_NOIO);
+	if (!newnode) {
+		DMERR("dm-bbr: Could not allocate from remap cache!");
+		return -ENOMEM;
+	}
+	newnode->remap.bad_sect  = new_bbr_entry->bad_sect;
+	newnode->remap.replacement_sect = new_bbr_entry->replacement_sect;
+	spin_lock_irq(&bbr_id->remap_root_lock);
+	bbr_binary_tree_insert(&bbr_id->remap_root, newnode);
+	spin_unlock_irq(&bbr_id->remap_root_lock);
+	return 0;
+}
+
+/**
+ * bbr_table_to_remap_list
+ *
+ * The on-disk bbr table is sorted by the replacement sector LBA. In order to
+ * improve run time performance, the in memory remap list must be sorted by
+ * the bad sector LBA. This function is called at discovery time to initialize
+ * the remap list. This function assumes that at least one copy of meta data
+ * is valid.
+ **/
+static u32 bbr_table_to_remap_list(struct bbr_private *bbr_id)
+{
+	u32 in_use_blks = 0;
+	int i, j;
+	struct bbr_table *p;
+
+	for (i = 0, p = bbr_id->bbr_table;
+	     i < bbr_id->nr_sects_bbr_table;
+	     i++, p++) {
+		if (!p->in_use_cnt) {
+			break;
+		}
+		in_use_blks += p->in_use_cnt;
+		for (j = 0; j < p->in_use_cnt; j++) {
+			bbr_insert_remap_entry(bbr_id, &p->entries[j]);
+		}
+	}
+	if (in_use_blks) {
+		char b[32];
+		DMWARN("dm-bbr: There are %u BBR entries for device %s",
+		       in_use_blks, format_dev_t(b, bbr_id->dev->bdev->bd_dev));
+	}
+
+	return in_use_blks;
+}
+
+/**
+ * bbr_search_remap_entry
+ *
+ * Search remap entry for the specified sector. If found, return a pointer to
+ * the table entry. Otherwise, return NULL.
+ **/
+static struct bbr_table_entry *bbr_search_remap_entry(
+	struct bbr_private *bbr_id,
+	u64 lsn)
+{
+	struct bbr_runtime_remap *p;
+
+	spin_lock_irq(&bbr_id->remap_root_lock);
+	p = bbr_binary_search(bbr_id->remap_root, lsn);
+	spin_unlock_irq(&bbr_id->remap_root_lock);
+	if (p) {
+		return (&p->remap);
+	} else {
+		return NULL;
+	}
+}
+
+/**
+ * bbr_remap
+ *
+ * If *lsn is in the remap table, return TRUE and modify *lsn,
+ * else, return FALSE.
+ **/
+static inline int bbr_remap(struct bbr_private *bbr_id,
+			    u64 *lsn)
+{
+	struct bbr_table_entry *e;
+
+	if (atomic_read(&bbr_id->in_use_replacement_blks)) {
+		e = bbr_search_remap_entry(bbr_id, *lsn);
+		if (e) {
+			*lsn = e->replacement_sect;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/**
+ * bbr_remap_probe
+ *
+ * If any of the sectors in the range [lsn, lsn+nr_sects] are in the remap
+ * table return TRUE, Else, return FALSE.
+ **/
+static inline int bbr_remap_probe(struct bbr_private *bbr_id,
+				  u64 lsn, u64 nr_sects)
+{
+	u64 tmp, cnt;
+
+	if (atomic_read(&bbr_id->in_use_replacement_blks)) {
+		for (cnt = 0, tmp = lsn;
+		     cnt < nr_sects;
+		     cnt += bbr_id->blksize_in_sects, tmp = lsn + cnt) {
+			if (bbr_remap(bbr_id,&tmp)) {
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+/**
+ * bbr_setup
+ *
+ * Read the remap tables from disk and set up the initial remap tree.
+ **/
+static int bbr_setup(struct bbr_private *bbr_id)
+{
+	struct bbr_table *table = bbr_id->bbr_table;
+	struct io_region job;
+	unsigned long error;
+	int i, rc = 0;
+
+	job.bdev = bbr_id->dev->bdev;
+	job.count = 1;
+
+	/* Read and verify each BBR table sector individually. */
+	for (i = 0; i < bbr_id->nr_sects_bbr_table; i++, table++) {
+		job.sector = bbr_id->lba_table1 + i;
+		rc = dm_io_sync_vm(1, &job, READ, table, &error);
+		if (rc && bbr_id->lba_table2) {
+			job.sector = bbr_id->lba_table2 + i;
+			rc = dm_io_sync_vm(1, &job, READ, table, &error);
+		}
+		if (rc) {
+			goto out;
+		}
+
+		rc = validate_bbr_table_sector(table);
+		if (rc) {
+			goto out;
+		}
+	}
+	atomic_set(&bbr_id->in_use_replacement_blks,
+		   bbr_table_to_remap_list(bbr_id));
+
+out:
+	if (rc) {
+		DMERR("dm-bbr: error during device setup: %d", rc);
+	}
+	return rc;
+}
+
+/**
+ * bbr_io_remap_error
+ * @bbr_id:		Private data for the BBR node.
+ * @rw:			READ or WRITE.
+ * @starting_lsn:	Starting sector of request to remap.
+ * @count:		Number of sectors in the request.
+ * @page:		Page containing the data for the request.
+ * @offset:		Byte-offset of the data within the page.
+ *
+ * For the requested range, try to write each sector individually. For each
+ * sector that fails, find the next available remap location and write the
+ * data to that new location. Then update the table and write both copies
+ * of the table to disk. Finally, update the in-memory mapping and do any
+ * other necessary bookkeeping.
+ **/
+static int bbr_io_remap_error(struct bbr_private *bbr_id,
+			      int rw,
+			      u64 starting_lsn,
+			      u64 count,
+			      struct page *page,
+			      unsigned int offset)
+{
+	struct bbr_table *bbr_table;
+	struct io_region job;
+	struct page_list pl;
+	unsigned long table_sector_index;
+	unsigned long table_sector_offset;
+	unsigned long index;
+	unsigned long error;
+	u64 lsn, new_lsn;
+	char b[32];
+	int rc;
+
+	job.bdev = bbr_id->dev->bdev;
+	job.count = 1;
+	pl.page = page;
+	pl.next = NULL;
+
+	/* For each sector in the request. */
+	for (lsn = 0; lsn < count; lsn++, offset += SECTOR_SIZE) {
+		job.sector = starting_lsn + lsn;
+		rc = dm_io_sync(1, &job, rw, &pl, offset, &error);
+		while (rc) {
+			/* Find the next available relocation sector. */
+			new_lsn = atomic_read(&bbr_id->in_use_replacement_blks);
+			if (new_lsn >= bbr_id->nr_replacement_blks) {
+				/* No more replacement sectors available. */
+				return -EIO;
+			}
+			new_lsn += bbr_id->start_replacement_sect;
+
+			/* Write the data to its new location. */
+			DMWARN("dm-bbr: device %s: Trying to remap bad sector "PFU64" to sector "PFU64,
+			       format_dev_t(b, bbr_id->dev->bdev->bd_dev),
+			       starting_lsn + lsn, new_lsn);
+			job.sector = new_lsn;
+			rc = dm_io_sync(1, &job, rw, &pl, offset, &error);
+			if (rc) {
+				/* This replacement sector is bad.
+				 * Try the next one.
+				 */
+				DMERR("dm-bbr: device %s: replacement sector "PFU64" is bad. Skipping.",
+				      format_dev_t(b, bbr_id->dev->bdev->bd_dev), new_lsn);
+				atomic_inc(&bbr_id->in_use_replacement_blks);
+				continue;
+			}
+
+			/* Add this new entry to the on-disk table. */
+			table_sector_index = new_lsn -
+					     bbr_id->start_replacement_sect;
+			table_sector_offset = table_sector_index /
+					      BBR_ENTRIES_PER_SECT;
+			index = table_sector_index % BBR_ENTRIES_PER_SECT;
+
+			bbr_table = &bbr_id->bbr_table[table_sector_offset];
+			bbr_table->entries[index].bad_sect = starting_lsn + lsn;
+			bbr_table->entries[index].replacement_sect = new_lsn;
+			bbr_table->in_use_cnt++;
+			bbr_table->sequence_number++;
+			bbr_table->crc = 0;
+			bbr_table->crc = calculate_crc(INITIAL_CRC,
+						       bbr_table,
+						       sizeof(struct bbr_table));
+
+			/* Write the table to disk. */
+			cpu_bbr_table_sector_to_le(bbr_table, bbr_table);
+			if (bbr_id->lba_table1) {
+				job.sector = bbr_id->lba_table1 + table_sector_offset;
+				rc = dm_io_sync_vm(1, &job, WRITE, bbr_table, &error);
+			}
+			if (bbr_id->lba_table2) {
+				job.sector = bbr_id->lba_table2 + table_sector_offset;
+				rc |= dm_io_sync_vm(1, &job, WRITE, bbr_table, &error);
+			}
+			le_bbr_table_sector_to_cpu(bbr_table);
+
+			if (rc) {
+				/* Error writing one of the tables to disk. */
+				DMERR("dm-bbr: device %s: error updating BBR tables on disk.",
+				      format_dev_t(b, bbr_id->dev->bdev->bd_dev));
+				return rc;
+			}
+
+			/* Insert a new entry in the remapping binary-tree. */
+			rc = bbr_insert_remap_entry(bbr_id,
+						    &bbr_table->entries[index]);
+			if (rc) {
+				DMERR("dm-bbr: device %s: error adding new entry to remap tree.",
+				      format_dev_t(b, bbr_id->dev->bdev->bd_dev));
+				return rc;
+			}
+
+			atomic_inc(&bbr_id->in_use_replacement_blks);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * bbr_io_process_request
+ *
+ * For each sector in this request, check if the sector has already
+ * been remapped. If so, process all previous sectors in the request,
+ * followed by the remapped sector. Then reset the starting lsn and
+ * count, and keep going with the rest of the request as if it were
+ * a whole new request. If any of the sync_io's return an error,
+ * call the remapper to relocate the bad sector(s).
+ *
+ * 2.5 Note: When switching over to bio's for the I/O path, we have made
+ * the assumption that the I/O request described by the bio is one
+ * virtually contiguous piece of memory (even though the bio vector
+ * describes it using a series of physical page addresses).
+ **/
+static int bbr_io_process_request(struct bbr_private *bbr_id,
+				  struct bio *bio)
+{
+	struct io_region job;
+	u64 starting_lsn = bio->bi_sector;
+	u64 count, lsn, remapped_lsn;
+	struct page_list pl;
+	unsigned int offset;
+	unsigned long error;
+	int i, rw = bio_data_dir(bio);
+	int rc = 0;
+
+	job.bdev = bbr_id->dev->bdev;
+	pl.next = NULL;
+
+	/* Each bio can contain multiple vectors, each with a different page.
+	 * Treat each vector as a separate request.
+	 */
+	/* KMC: Is this the right way to walk the bvec list? */
+	for (i = 0;
+	     i < bio->bi_vcnt;
+	     i++, bio->bi_idx++, starting_lsn += count) {
+
+		/* Bvec info: number of sectors, page,
+		 * and byte-offset within page.
+		 */
+		count = bio_iovec(bio)->bv_len >> SECTOR_SHIFT;
+		pl.page = bio_iovec(bio)->bv_page;
+		offset = bio_iovec(bio)->bv_offset;
+
+		/* For each sector in this bvec, check if the sector has
+		 * already been remapped. If so, process all previous sectors
+		 * in this request, followed by the remapped sector. Then reset
+		 * the starting lsn and count and keep going with the rest of
+		 * the request as if it were a whole new request.
+		 */
+		for (lsn = 0; lsn < count; lsn++) {
+			remapped_lsn = starting_lsn + lsn;
+			rc = bbr_remap(bbr_id, &remapped_lsn);
+			if (!rc) {
+				/* This sector is fine. */
+				continue;
+			}
+
+			/* Process all sectors in the request up to this one. */
+			if (lsn > 0) {
+				job.sector = starting_lsn;
+				job.count = lsn;
+				rc = dm_io_sync(1, &job, rw, &pl,
+						offset, &error);
+				if (rc) {
+					/* If this I/O failed, then one of the
+					 * sectors in this request needs to be
+					 * relocated.
+					 */
+					rc = bbr_io_remap_error(bbr_id, rw,
+								starting_lsn,
+								lsn, pl.page,
+								offset);
+					if (rc) {
+						/* KMC: Return? Or continue to next bvec? */
+						return rc;
+					}
+				}
+				offset += (lsn << SECTOR_SHIFT);
+			}
+
+			/* Process the remapped sector. */
+			job.sector = remapped_lsn;
+			job.count = 1;
+			rc = dm_io_sync(1, &job, rw, &pl, offset, &error);
+			if (rc) {
+				/* BUGBUG - Need more processing if this caused
+				 * an error. If this I/O failed, then the
+				 * existing remap is now bad, and we need to
+				 * find a new remap. Can't use
+				 * bbr_io_remap_error(), because the existing
+				 * map entry needs to be changed, not added
+				 * again, and the original table entry also
+				 * needs to be changed.
+				 */
+				return rc;
+			}
+
+			starting_lsn	+= (lsn + 1);
+			count		-= (lsn + 1);
+			lsn		= -1;
+			offset		+= SECTOR_SIZE;
+		}
+
+		/* Check for any remaining sectors after the last split. This
+		 * could potentially be the whole request, but that should be a
+		 * rare case because requests should only be processed by the
+		 * thread if we know an error occurred or they contained one or
+		 * more remapped sectors.
+		 */
+		if (count) {
+			job.sector = starting_lsn;
+			job.count = count;
+			rc = dm_io_sync(1, &job, rw, &pl, offset, &error);
+			if (rc) {
+				/* If this I/O failed, then one of the sectors
+				 * in this request needs to be relocated.
+				 */
+				rc = bbr_io_remap_error(bbr_id, rw, starting_lsn,
+							count, pl.page, offset);
+				if (rc) {
+					/* KMC: Return? Or continue to next bvec? */
+					return rc;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void bbr_io_process_requests(struct bbr_private *bbr_id,
+				    struct bio *bio)
+{
+	struct bio *next;
+	int rc;
+
+	while (bio) {
+		next = bio->bi_next;
+		bio->bi_next = NULL;
+
+		rc = bbr_io_process_request(bbr_id, bio);
+
+		bio_endio(bio, bio->bi_size, rc);
+
+		bio = next;
+	}
+}
+
+/**
+ * bbr_remap_handler
+ *
+ * This is the handler for the bbr work-queue.
+ *
+ * I/O requests should only be sent to this handler if we know that:
+ * a) the request contains at least one remapped sector.
+ *   or
+ * b) the request caused an error on the normal I/O path.
+ *
+ * This function uses synchronous I/O, so sending a request to this
+ * thread that doesn't need special processing will cause severe
+ * performance degredation.
+ **/
+static void bbr_remap_handler(void *data)
+{
+	struct bbr_private *bbr_id = data;
+	struct bio *bio;
+	unsigned long flags;
+
+	spin_lock_irqsave(&bbr_id->remap_ios_lock, flags);
+	bio = bio_list_get(&bbr_id->remap_ios);
+	spin_unlock_irqrestore(&bbr_id->remap_ios_lock, flags);
+
+	bbr_io_process_requests(bbr_id, bio);
+}
+
+/**
+ * bbr_endio
+ *
+ * This is the callback for normal write requests. Check for an error
+ * during the I/O, and send to the thread for processing if necessary.
+ **/
+static int bbr_endio(struct dm_target *ti, struct bio *bio,
+		     int error, union map_info *map_context)
+{
+	struct bbr_private *bbr_id = ti->private;
+	struct dm_bio_details *bbr_io = map_context->ptr;
+
+	if (error && bbr_io) {
+		unsigned long flags;
+		char b[32];
+
+		dm_bio_restore(bbr_io, bio);
+		map_context->ptr = NULL;
+
+		DMERR("dm-bbr: device %s: I/O failure on sector %lu. "
+		      "Scheduling for retry.",
+		      format_dev_t(b, bbr_id->dev->bdev->bd_dev),
+		      (unsigned long)bio->bi_sector);
+
+		spin_lock_irqsave(&bbr_id->remap_ios_lock, flags);
+		bio_list_add(&bbr_id->remap_ios, bio);
+		spin_unlock_irqrestore(&bbr_id->remap_ios_lock, flags);
+
+		queue_work(dm_bbr_wq, &bbr_id->remap_work);
+
+		error = 1;
+	}
+
+	if (bbr_io)
+		mempool_free(bbr_io, bbr_io_pool);
+
+	return error;
+}
+
+/**
+ * Construct a bbr mapping
+ **/
+static int bbr_ctr(struct dm_target *ti, unsigned int argc, char **argv)
+{
+	struct bbr_private *bbr_id;
+	unsigned long block_size;
+	char *end;
+	int rc = -EINVAL;
+
+	if (argc != 8) {
+		ti->error = "dm-bbr requires exactly 8 arguments: "
+			    "device offset table1_lsn table2_lsn table_size start_replacement nr_replacement_blks block_size";
+		goto out1;
+	}
+
+	bbr_id = bbr_alloc_private();
+	if (!bbr_id) {
+		ti->error = "dm-bbr: Error allocating bbr private data.";
+		goto out1;
+	}
+
+	bbr_id->offset = simple_strtoull(argv[1], &end, 10);
+	bbr_id->lba_table1 = simple_strtoull(argv[2], &end, 10);
+	bbr_id->lba_table2 = simple_strtoull(argv[3], &end, 10);
+	bbr_id->nr_sects_bbr_table = simple_strtoull(argv[4], &end, 10);
+	bbr_id->start_replacement_sect = simple_strtoull(argv[5], &end, 10);
+	bbr_id->nr_replacement_blks = simple_strtoull(argv[6], &end, 10);
+	block_size = simple_strtoul(argv[7], &end, 10);
+	bbr_id->blksize_in_sects = (block_size >> SECTOR_SHIFT);
+
+	bbr_id->bbr_table = vmalloc(bbr_id->nr_sects_bbr_table << SECTOR_SHIFT);
+	if (!bbr_id->bbr_table) {
+		ti->error = "dm-bbr: Error allocating bbr table.";
+		goto out2;
+	}
+
+	if (dm_get_device(ti, argv[0], 0, ti->len,
+			  dm_table_get_mode(ti->table), &bbr_id->dev)) {
+		ti->error = "dm-bbr: Device lookup failed";
+		goto out2;
+	}
+
+	rc = bbr_setup(bbr_id);
+	if (rc) {
+		ti->error = "dm-bbr: Device setup failed";
+		goto out3;
+	}
+
+	ti->private = bbr_id;
+	return 0;
+
+out3:
+	dm_put_device(ti, bbr_id->dev);
+out2:
+	bbr_free_private(bbr_id);
+out1:
+	return rc;
+}
+
+static void bbr_dtr(struct dm_target *ti)
+{
+	struct bbr_private *bbr_id = ti->private;
+
+	dm_put_device(ti, bbr_id->dev);
+	bbr_free_private(bbr_id);
+}
+
+static int bbr_map(struct dm_target *ti, struct bio *bio,
+		   union map_info *map_context)
+{
+	struct bbr_private *bbr_id = ti->private;
+	struct dm_bio_details *bbr_io;
+	unsigned long flags;
+	int rc = 1;
+
+	bio->bi_sector += bbr_id->offset;
+
+	if (atomic_read(&bbr_id->in_use_replacement_blks) == 0 ||
+	    !bbr_remap_probe(bbr_id, bio->bi_sector, bio_sectors(bio))) {
+		/* No existing remaps or this request doesn't
+		 * contain any remapped sectors.
+		 */
+		bio->bi_bdev = bbr_id->dev->bdev;
+
+		bbr_io = mempool_alloc(bbr_io_pool, GFP_NOIO);
+		dm_bio_record(bbr_io, bio);
+		map_context->ptr = bbr_io;
+	} else {
+		/* This request has at least one remapped sector.
+		 * Give it to the work-queue for processing.
+		 */
+		map_context->ptr = NULL;
+		spin_lock_irqsave(&bbr_id->remap_ios_lock, flags);
+		bio_list_add(&bbr_id->remap_ios, bio);
+		spin_unlock_irqrestore(&bbr_id->remap_ios_lock, flags);
+
+		queue_work(dm_bbr_wq, &bbr_id->remap_work);
+		rc = 0;
+	}
+
+	return rc;
+}
+
+static int bbr_status(struct dm_target *ti, status_type_t type,
+		      char *result, unsigned int maxlen)
+{
+	struct bbr_private *bbr_id = ti->private;
+	char b[BDEVNAME_SIZE];
+
+	switch (type) {
+	case STATUSTYPE_INFO:
+		result[0] = '\0';
+		break;
+
+	case STATUSTYPE_TABLE:
+		snprintf(result, maxlen, "%s "PFU64" "PFU64" "PFU64" "PFU64" "PFU64" "PFU64" %u",
+			 format_dev_t(b, bbr_id->dev->bdev->bd_dev),
+			 bbr_id->offset, bbr_id->lba_table1, bbr_id->lba_table2,
+			 bbr_id->nr_sects_bbr_table,
+			 bbr_id->start_replacement_sect,
+			 bbr_id->nr_replacement_blks,
+			 bbr_id->blksize_in_sects << SECTOR_SHIFT);
+		 break;
+	}
+	return 0;
+}
+
+static struct target_type bbr_target = {
+	.name	= "bbr",
+	.version= {1, 0, 1},
+	.module	= THIS_MODULE,
+	.ctr	= bbr_ctr,
+	.dtr	= bbr_dtr,
+	.map	= bbr_map,
+	.end_io	= bbr_endio,
+	.status	= bbr_status,
+};
+
+int __init dm_bbr_init(void)
+{
+	int rc;
+
+	rc = dm_register_target(&bbr_target);
+	if (rc) {
+		DMERR("dm-bbr: error registering target.");
+		goto err1;
+	}
+
+	bbr_remap_cache = kmem_cache_create("bbr-remap",
+					    sizeof(struct bbr_runtime_remap),
+					    0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (!bbr_remap_cache) {
+		DMERR("dm-bbr: error creating remap cache.");
+		rc = ENOMEM;
+		goto err2;
+	}
+
+	bbr_io_cache = kmem_cache_create("bbr-io", sizeof(struct dm_bio_details),
+					 0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (!bbr_io_cache) {
+		DMERR("dm-bbr: error creating io cache.");
+		rc = ENOMEM;
+		goto err3;
+	}
+
+	bbr_io_pool = mempool_create(256, mempool_alloc_slab,
+				     mempool_free_slab, bbr_io_cache);
+	if (!bbr_io_pool) {
+		DMERR("dm-bbr: error creating io mempool.");
+		rc = ENOMEM;
+		goto err4;
+	}
+
+	dm_bbr_wq = create_workqueue("dm-bbr");
+	if (!dm_bbr_wq) {
+		DMERR("dm-bbr: error creating work-queue.");
+		rc = ENOMEM;
+		goto err5;
+	}
+
+	rc = dm_io_get(1);
+	if (rc) {
+		DMERR("dm-bbr: error initializing I/O service.");
+		goto err6;
+	}
+
+	return 0;
+
+err6:
+	destroy_workqueue(dm_bbr_wq);
+err5:
+	mempool_destroy(bbr_io_pool);
+err4:
+	kmem_cache_destroy(bbr_io_cache);
+err3:
+	kmem_cache_destroy(bbr_remap_cache);
+err2:
+	dm_unregister_target(&bbr_target);
+err1:
+	return rc;
+}
+
+void __exit dm_bbr_exit(void)
+{
+	dm_io_put(1);
+	destroy_workqueue(dm_bbr_wq);
+	mempool_destroy(bbr_io_pool);
+	kmem_cache_destroy(bbr_io_cache);
+	kmem_cache_destroy(bbr_remap_cache);
+	dm_unregister_target(&bbr_target);
+}
+
+module_init(dm_bbr_init);
+module_exit(dm_bbr_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/md/dm-bbr.h b/drivers/md/dm-bbr.h
new file mode 100644
index 0000000000..9c5aa33ffc
--- /dev/null
+++ b/drivers/md/dm-bbr.h
@@ -0,0 +1,125 @@
+/*
+ *   (C) Copyright IBM Corp. 2002, 2004
+ *
+ *   This program is free software;  you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program;  if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * linux/drivers/md/dm-bbr.h
+ *
+ * Bad-block-relocation (BBR) target for device-mapper.
+ *
+ * The BBR target is designed to remap I/O write failures to another safe
+ * location on disk. Note that most disk drives have BBR built into them,
+ * this means that our software BBR will be only activated when all hardware
+ * BBR replacement sectors have been used.
+ */
+
+#define BBR_TABLE_SIGNATURE		0x42627254 /* BbrT */
+#define BBR_ENTRIES_PER_SECT		31
+#define INITIAL_CRC			0xFFFFFFFF
+#define CRC_POLYNOMIAL			0xEDB88320L
+
+/**
+ * Macros to cleanly print 64-bit numbers on both 32-bit and 64-bit machines.
+ * Use these in place of %Ld, %Lu, and %Lx.
+ **/
+#if BITS_PER_LONG > 32
+#define PFU64 "%lu"
+#else
+#define PFU64 "%Lu"
+#endif
+
+/**
+ * struct bbr_table_entry
+ * @bad_sect:		LBA of bad location.
+ * @replacement_sect:	LBA of new location.
+ *
+ * Structure to describe one BBR remap.
+ **/
+struct bbr_table_entry {
+	u64 bad_sect;
+	u64 replacement_sect;
+};
+
+/**
+ * struct bbr_table
+ * @signature:		Signature on each BBR table sector.
+ * @crc:		CRC for this table sector.
+ * @sequence_number:	Used to resolve conflicts when primary and secondary
+ *			tables do not match.
+ * @in_use_cnt:		Number of in-use table entries.
+ * @entries:		Actual table of remaps.
+ *
+ * Structure to describe each sector of the metadata table. Each sector in this
+ * table can describe 31 remapped sectors.
+ **/
+struct bbr_table {
+	u32			signature;
+	u32			crc;
+	u32			sequence_number;
+	u32			in_use_cnt;
+	struct bbr_table_entry	entries[BBR_ENTRIES_PER_SECT];
+};
+
+/**
+ * struct bbr_runtime_remap
+ *
+ * Node in the binary tree used to keep track of remaps.
+ **/
+struct bbr_runtime_remap {
+	struct bbr_table_entry		remap;
+	struct bbr_runtime_remap	*left;
+	struct bbr_runtime_remap	*right;
+};
+
+/**
+ * struct bbr_private
+ * @dev:			Info about underlying device.
+ * @bbr_table:			Copy of metadata table.
+ * @remap_root:			Binary tree containing all remaps.
+ * @remap_root_lock:		Lock for the binary tree.
+ * @remap_work:			For adding work items to the work-queue.
+ * @remap_ios:			List of I/Os for the work-queue to handle.
+ * @remap_ios_lock:		Lock for the remap_ios list.
+ * @offset:			LBA of data area.
+ * @lba_table1:			LBA of primary BBR table.
+ * @lba_table2:			LBA of secondary BBR table.
+ * @nr_sects_bbr_table:		Size of each BBR table.
+ * @nr_replacement_blks:	Number of replacement blocks.
+ * @start_replacement_sect:	LBA of start of replacement blocks.
+ * @blksize_in_sects:		Size of each block.
+ * @in_use_replacement_blks:	Current number of remapped blocks.
+ *
+ * Private data for each BBR target.
+ **/
+struct bbr_private {
+	struct dm_dev			*dev;
+	struct bbr_table		*bbr_table;
+	struct bbr_runtime_remap	*remap_root;
+	spinlock_t			remap_root_lock;
+
+	struct work_struct		remap_work;
+	struct bio_list			remap_ios;
+	spinlock_t			remap_ios_lock;
+
+	u64				offset;
+	u64				lba_table1;
+	u64				lba_table2;
+	u64				nr_sects_bbr_table;
+	u64				start_replacement_sect;
+	u64				nr_replacement_blks;
+	u32				blksize_in_sects;
+	atomic_t			in_use_replacement_blks;
+};
+
diff --git a/drivers/media/common/Kconfig b/drivers/media/common/Kconfig
index 6a901a0268..f33e5d9734 100644
--- a/drivers/media/common/Kconfig
+++ b/drivers/media/common/Kconfig
@@ -1,6 +1,6 @@
 config VIDEO_SAA7146
 	tristate
-	select I2C
+	depends on I2C
 
 config VIDEO_SAA7146_VV
 	tristate
diff --git a/drivers/media/dvb/Kconfig b/drivers/media/dvb/Kconfig
index 3f0ec6be03..a97c8f5e9a 100644
--- a/drivers/media/dvb/Kconfig
+++ b/drivers/media/dvb/Kconfig
@@ -22,26 +22,26 @@ config DVB
 source "drivers/media/dvb/dvb-core/Kconfig"
 
 comment "Supported SAA7146 based PCI Adapters"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 source "drivers/media/dvb/ttpci/Kconfig"
 
 comment "Supported USB Adapters"
-	depends on DVB_CORE && USB
+	depends on DVB_CORE && USB && I2C
 source "drivers/media/dvb/dvb-usb/Kconfig"
 source "drivers/media/dvb/ttusb-budget/Kconfig"
 source "drivers/media/dvb/ttusb-dec/Kconfig"
 source "drivers/media/dvb/cinergyT2/Kconfig"
 
 comment "Supported FlexCopII (B2C2) Adapters"
-	depends on DVB_CORE && (PCI || USB)
+	depends on DVB_CORE && (PCI || USB) && I2C
 source "drivers/media/dvb/b2c2/Kconfig"
 
 comment "Supported BT878 Adapters"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 source "drivers/media/dvb/bt8xx/Kconfig"
 
 comment "Supported Pluto2 Adapters"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 source "drivers/media/dvb/pluto2/Kconfig"
 
 comment "Supported DVB Frontends"
diff --git a/drivers/media/dvb/b2c2/Kconfig b/drivers/media/dvb/b2c2/Kconfig
index 2963605c0e..d7f1fd5b7b 100644
--- a/drivers/media/dvb/b2c2/Kconfig
+++ b/drivers/media/dvb/b2c2/Kconfig
@@ -1,6 +1,6 @@
 config DVB_B2C2_FLEXCOP
 	tristate "Technisat/B2C2 FlexCopII(b) and FlexCopIII adapters"
-	depends on DVB_CORE
+	depends on DVB_CORE && I2C
 	select DVB_STV0299
 	select DVB_MT352
 	select DVB_MT312
@@ -16,7 +16,7 @@ config DVB_B2C2_FLEXCOP
 
 config DVB_B2C2_FLEXCOP_PCI
 	tristate "Technisat/B2C2 Air/Sky/Cable2PC PCI"
-	depends on DVB_B2C2_FLEXCOP && PCI
+	depends on DVB_B2C2_FLEXCOP && PCI && I2C
 	help
 	  Support for the Air/Sky/CableStar2 PCI card (DVB/ATSC) by Technisat/B2C2.
 
@@ -24,7 +24,7 @@ config DVB_B2C2_FLEXCOP_PCI
 
 config DVB_B2C2_FLEXCOP_USB
 	tristate "Technisat/B2C2 Air/Sky/Cable2PC USB"
-	depends on DVB_B2C2_FLEXCOP && USB
+	depends on DVB_B2C2_FLEXCOP && USB && I2C
 	help
 	  Support for the Air/Sky/Cable2PC USB1.1 box (DVB/ATSC) by Technisat/B2C2,
 
diff --git a/drivers/media/dvb/bt8xx/Kconfig b/drivers/media/dvb/bt8xx/Kconfig
index 2337b41714..7d0470b0a8 100644
--- a/drivers/media/dvb/bt8xx/Kconfig
+++ b/drivers/media/dvb/bt8xx/Kconfig
@@ -1,6 +1,6 @@
 config DVB_BT8XX
 	tristate "BT8xx based PCI cards"
-	depends on DVB_CORE && PCI && VIDEO_BT848
+	depends on DVB_CORE && PCI && I2C && VIDEO_BT848
 	select DVB_MT352
 	select DVB_SP887X
 	select DVB_NXT6000
diff --git a/drivers/media/dvb/dvb-usb/Kconfig b/drivers/media/dvb/dvb-usb/Kconfig
index d3df12039b..e388fb1567 100644
--- a/drivers/media/dvb/dvb-usb/Kconfig
+++ b/drivers/media/dvb/dvb-usb/Kconfig
@@ -1,6 +1,6 @@
 config DVB_USB
 	tristate "Support for various USB DVB devices"
-	depends on DVB_CORE && USB
+	depends on DVB_CORE && USB && I2C
 	select FW_LOADER
 	help
 	  By enabling this you will be able to choose the various supported
diff --git a/drivers/media/dvb/pluto2/Kconfig b/drivers/media/dvb/pluto2/Kconfig
index 84f8f9f528..7d8e6e87bd 100644
--- a/drivers/media/dvb/pluto2/Kconfig
+++ b/drivers/media/dvb/pluto2/Kconfig
@@ -1,7 +1,6 @@
 config DVB_PLUTO2
 	tristate "Pluto2 cards"
-	depends on DVB_CORE && PCI
-	select I2C
+	depends on DVB_CORE && PCI && I2C
 	select I2C_ALGOBIT
 	select DVB_TDA1004X
 	help
diff --git a/drivers/media/dvb/ttpci/Kconfig b/drivers/media/dvb/ttpci/Kconfig
index 5b2aadb838..ba3359f4b0 100644
--- a/drivers/media/dvb/ttpci/Kconfig
+++ b/drivers/media/dvb/ttpci/Kconfig
@@ -1,6 +1,6 @@
 config DVB_AV7110
 	tristate "AV7110 cards"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 	select FW_LOADER
 	select VIDEO_DEV
 	select VIDEO_SAA7146_VV
@@ -59,7 +59,7 @@ config DVB_AV7110_OSD
 
 config DVB_BUDGET
 	tristate "Budget cards"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 	select VIDEO_SAA7146
 	select DVB_STV0299
 	select DVB_VES1X93
@@ -80,7 +80,7 @@ config DVB_BUDGET
 
 config DVB_BUDGET_CI
 	tristate "Budget cards with onboard CI connector"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 	select VIDEO_SAA7146
 	select DVB_STV0297
 	select DVB_STV0299
@@ -100,7 +100,7 @@ config DVB_BUDGET_CI
 
 config DVB_BUDGET_AV
 	tristate "Budget cards with analog video inputs"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE && PCI && I2C
 	select VIDEO_DEV
 	select VIDEO_SAA7146_VV
 	select DVB_STV0299
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index a1294e02ab..8531b59009 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2059,9 +2059,13 @@ config SKY2
 	  will be called sky2.  This is recommended.
 
 config SK98LIN
-	tristate "Marvell Yukon Chipset / SysKonnect SK-98xx Support"
+	tristate "Marvell Yukon Chipset / SysKonnect SK-98xx Support (DEPRECATED)"
 	depends on PCI
 	---help---
+	  This driver has been marked deprecated for Gentoo users, as it seems
+	  problematic and the new skge driver (CONFIG_SKGE) works much better.
+	  If you do not rely on features of this driver, please use SKGE instead.
+
 	  Say Y here if you have a Marvell Yukon or SysKonnect SK-98xx/SK-95xx
 	  compliant Gigabit Ethernet Adapter.
 
diff --git a/drivers/net/skge.c b/drivers/net/skge.c
index f808a35fd1..859b1f0794 100644
--- a/drivers/net/skge.c
+++ b/drivers/net/skge.c
@@ -44,7 +44,7 @@
 #include "skge.h"
 
 #define DRV_NAME		"skge"
-#define DRV_VERSION		"1.3"
+#define DRV_VERSION		"1.5"
 #define PFX			DRV_NAME " "
 
 #define DEFAULT_TX_RING_SIZE	128
@@ -78,6 +78,7 @@ static const struct pci_device_id skge_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, PCI_DEVICE_ID_SYSKONNECT_GE) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, PCI_DEVICE_ID_SYSKONNECT_YU) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, PCI_DEVICE_ID_DLINK_DGE510T), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, 0x4b01) },	/* DGE-530T */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4320) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x5005) }, /* Belkin */
 	{ PCI_DEVICE(PCI_VENDOR_ID_CNET, PCI_DEVICE_ID_CNET_GIGACARD) },
@@ -104,7 +105,6 @@ static const int txqaddr[] = { Q_XA1, Q_XA2 };
 static const int rxqaddr[] = { Q_R1, Q_R2 };
 static const u32 rxirqmask[] = { IS_R1_F, IS_R2_F };
 static const u32 txirqmask[] = { IS_XA1_F, IS_XA2_F };
-static const u32 portirqmask[] = { IS_PORT_1, IS_PORT_2 };
 
 static int skge_get_regs_len(struct net_device *dev)
 {
@@ -358,7 +358,7 @@ static struct net_device_stats *skge_get_stats(struct net_device *dev)
 	skge->net_stats.rx_bytes = data[1];
 	skge->net_stats.tx_packets = data[2] + data[4] + data[6];
 	skge->net_stats.rx_packets = data[3] + data[5] + data[7];
-	skge->net_stats.multicast = data[5] + data[7];
+	skge->net_stats.multicast = data[3] + data[5];
 	skge->net_stats.collisions = data[10];
 	skge->net_stats.tx_aborted_errors = data[12];
 
@@ -728,19 +728,18 @@ static struct ethtool_ops skge_ethtool_ops = {
  * Allocate ring elements and chain them together
  * One-to-one association of board descriptors with ring elements
  */
-static int skge_ring_alloc(struct skge_ring *ring, void *vaddr, u64 base)
+static int skge_ring_alloc(struct skge_ring *ring, void *vaddr, u32 base)
 {
 	struct skge_tx_desc *d;
 	struct skge_element *e;
 	int i;
 
-	ring->start = kmalloc(sizeof(*e)*ring->count, GFP_KERNEL);
+	ring->start = kcalloc(sizeof(*e), ring->count, GFP_KERNEL);
 	if (!ring->start)
 		return -ENOMEM;
 
 	for (i = 0, e = ring->start, d = vaddr; i < ring->count; i++, e++, d++) {
 		e->desc = d;
-		e->skb = NULL;
 		if (i == ring->count - 1) {
 			e->next = ring->start;
 			d->next_offset = base;
@@ -783,7 +782,7 @@ static void skge_rx_setup(struct skge_port *skge, struct skge_element *e,
  * Note: DMA address is not changed by chip.
  * 	 MTU not changed while receiver active.
  */
-static void skge_rx_reuse(struct skge_element *e, unsigned int size)
+static inline void skge_rx_reuse(struct skge_element *e, unsigned int size)
 {
 	struct skge_rx_desc *rd = e->desc;
 
@@ -831,7 +830,7 @@ static int skge_rx_fill(struct skge_port *skge)
 	do {
 		struct sk_buff *skb;
 
-		skb = dev_alloc_skb(skge->rx_buf_size + NET_IP_ALIGN);
+		skb = alloc_skb(skge->rx_buf_size + NET_IP_ALIGN, GFP_KERNEL);
 		if (!skb)
 			return -ENOMEM;
 
@@ -849,8 +848,7 @@ static void skge_link_up(struct skge_port *skge)
 		    LED_BLK_OFF|LED_SYNC_OFF|LED_ON);
 
 	netif_carrier_on(skge->netdev);
-	if (skge->tx_avail > MAX_SKB_FRAGS + 1)
-		netif_wake_queue(skge->netdev);
+	netif_wake_queue(skge->netdev);
 
 	if (netif_msg_link(skge))
 		printk(KERN_INFO PFX
@@ -2157,7 +2155,7 @@ static int skge_up(struct net_device *dev)
 		printk(KERN_INFO PFX "%s: enabling interface\n", dev->name);
 
 	if (dev->mtu > RX_BUF_SIZE)
-		skge->rx_buf_size = dev->mtu + ETH_HLEN + NET_IP_ALIGN;
+		skge->rx_buf_size = dev->mtu + ETH_HLEN;
 	else
 		skge->rx_buf_size = RX_BUF_SIZE;
 
@@ -2169,27 +2167,29 @@ static int skge_up(struct net_device *dev)
 	if (!skge->mem)
 		return -ENOMEM;
 
+	BUG_ON(skge->dma & 7);
+
+	if ((u64)skge->dma >> 32 != ((u64) skge->dma + skge->mem_size) >> 32) {
+		printk(KERN_ERR PFX "pci_alloc_consistent region crosses 4G boundary\n");
+		err = -EINVAL;
+		goto free_pci_mem;
+	}
+
 	memset(skge->mem, 0, skge->mem_size);
 
-	if ((err = skge_ring_alloc(&skge->rx_ring, skge->mem, skge->dma)))
+	err = skge_ring_alloc(&skge->rx_ring, skge->mem, skge->dma);
+	if (err)
 		goto free_pci_mem;
 
 	err = skge_rx_fill(skge);
 	if (err)
 		goto free_rx_ring;
 
-	if ((err = skge_ring_alloc(&skge->tx_ring, skge->mem + rx_size,
-				   skge->dma + rx_size)))
+	err = skge_ring_alloc(&skge->tx_ring, skge->mem + rx_size,
+			      skge->dma + rx_size);
+	if (err)
 		goto free_rx_ring;
 
-	skge->tx_avail = skge->tx_ring.count - 1;
-
-	/* Enable IRQ from port */
-	spin_lock_irq(&hw->hw_lock);
-	hw->intr_mask |= portirqmask[port];
-	skge_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock_irq(&hw->hw_lock);
-
 	/* Initialize MAC */
 	spin_lock_bh(&hw->phy_lock);
 	if (hw->chip_id == CHIP_ID_GENESIS)
@@ -2247,11 +2247,6 @@ static int skge_down(struct net_device *dev)
 	else
 		yukon_stop(skge);
 
-	spin_lock_irq(&hw->hw_lock);
-	hw->intr_mask &= ~portirqmask[skge->port];
-	skge_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock_irq(&hw->hw_lock);
-
 	/* Stop transmitter */
 	skge_write8(hw, Q_ADDR(txqaddr[port], Q_CSR), CSR_STOP);
 	skge_write32(hw, RB_ADDR(txqaddr[port], RB_CTRL),
@@ -2298,6 +2293,12 @@ static int skge_down(struct net_device *dev)
 	return 0;
 }
 
+static inline int skge_avail(const struct skge_ring *ring)
+{
+	return ((ring->to_clean > ring->to_use) ? 0 : ring->count)
+		+ (ring->to_clean - ring->to_use) - 1;
+}
+
 static int skge_xmit_frame(struct sk_buff *skb, struct net_device *dev)
 {
 	struct skge_port *skge = netdev_priv(dev);
@@ -2308,27 +2309,24 @@ static int skge_xmit_frame(struct sk_buff *skb, struct net_device *dev)
 	int i;
 	u32 control, len;
 	u64 map;
-	unsigned long flags;
 
 	skb = skb_padto(skb, ETH_ZLEN);
 	if (!skb)
 		return NETDEV_TX_OK;
 
-	local_irq_save(flags);
 	if (!spin_trylock(&skge->tx_lock)) {
- 		/* Collision - tell upper layer to requeue */
- 		local_irq_restore(flags);
- 		return NETDEV_TX_LOCKED;
- 	}
+		/* Collision - tell upper layer to requeue */
+		return NETDEV_TX_LOCKED;
+	}
 
-	if (unlikely(skge->tx_avail < skb_shinfo(skb)->nr_frags +1)) {
+	if (unlikely(skge_avail(&skge->tx_ring) < skb_shinfo(skb)->nr_frags + 1)) {
 		if (!netif_queue_stopped(dev)) {
 			netif_stop_queue(dev);
 
 			printk(KERN_WARNING PFX "%s: ring full when queue awake!\n",
 			       dev->name);
 		}
-		spin_unlock_irqrestore(&skge->tx_lock, flags);
+		spin_unlock(&skge->tx_lock);
 		return NETDEV_TX_BUSY;
 	}
 
@@ -2397,49 +2395,51 @@ static int skge_xmit_frame(struct sk_buff *skb, struct net_device *dev)
 		       dev->name, e - ring->start, skb->len);
 
 	ring->to_use = e->next;
-	skge->tx_avail -= skb_shinfo(skb)->nr_frags + 1;
-	if (skge->tx_avail <= MAX_SKB_FRAGS + 1) {
+	if (skge_avail(&skge->tx_ring) <= MAX_SKB_FRAGS + 1) {
 		pr_debug("%s: transmit queue full\n", dev->name);
 		netif_stop_queue(dev);
 	}
 
+	mmiowb();
+	spin_unlock(&skge->tx_lock);
+
 	dev->trans_start = jiffies;
-	spin_unlock_irqrestore(&skge->tx_lock, flags);
 
 	return NETDEV_TX_OK;
 }
 
-static inline void skge_tx_free(struct skge_hw *hw, struct skge_element *e)
+static void skge_tx_complete(struct skge_port *skge, struct skge_element *last)
 {
-	/* This ring element can be skb or fragment */
-	if (e->skb) {
-		pci_unmap_single(hw->pdev,
-			       pci_unmap_addr(e, mapaddr),
-			       pci_unmap_len(e, maplen),
-			       PCI_DMA_TODEVICE);
-		dev_kfree_skb_any(e->skb);
+	struct pci_dev *pdev = skge->hw->pdev;
+	struct skge_element *e;
+
+	for (e = skge->tx_ring.to_clean; e != last; e = e->next) {
+		struct sk_buff *skb = e->skb;
+		int i;
+
 		e->skb = NULL;
-	} else {
-		pci_unmap_page(hw->pdev,
-			       pci_unmap_addr(e, mapaddr),
-			       pci_unmap_len(e, maplen),
-			       PCI_DMA_TODEVICE);
+		pci_unmap_single(pdev, pci_unmap_addr(e, mapaddr),
+				 skb_headlen(skb), PCI_DMA_TODEVICE);
+
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			e = e->next;
+			pci_unmap_page(pdev, pci_unmap_addr(e, mapaddr),
+				       skb_shinfo(skb)->frags[i].size,
+				       PCI_DMA_TODEVICE);
+		}
+
+		dev_kfree_skb(skb);
 	}
+	skge->tx_ring.to_clean = e;
 }
 
 static void skge_tx_clean(struct skge_port *skge)
 {
-	struct skge_ring *ring = &skge->tx_ring;
-	struct skge_element *e;
-	unsigned long flags;
 
-	spin_lock_irqsave(&skge->tx_lock, flags);
-	for (e = ring->to_clean; e != ring->to_use; e = e->next) {
-		++skge->tx_avail;
-		skge_tx_free(skge->hw, e);
-	}
-	ring->to_clean = e;
-	spin_unlock_irqrestore(&skge->tx_lock, flags);
+	spin_lock_bh(&skge->tx_lock);
+	skge_tx_complete(skge, skge->tx_ring.to_use);
+	netif_wake_queue(skge->netdev);
+	spin_unlock_bh(&skge->tx_lock);
 }
 
 static void skge_tx_timeout(struct net_device *dev)
@@ -2598,7 +2598,7 @@ static inline struct sk_buff *skge_rx_get(struct skge_port *skge,
 		goto error;
 
 	if (len < RX_COPY_THRESHOLD) {
-		skb = dev_alloc_skb(len + 2);
+		skb = alloc_skb(len + 2, GFP_ATOMIC);
 		if (!skb)
 			goto resubmit;
 
@@ -2613,10 +2613,11 @@ static inline struct sk_buff *skge_rx_get(struct skge_port *skge,
 		skge_rx_reuse(e, skge->rx_buf_size);
 	} else {
 		struct sk_buff *nskb;
-		nskb = dev_alloc_skb(skge->rx_buf_size + NET_IP_ALIGN);
+		nskb = alloc_skb(skge->rx_buf_size + NET_IP_ALIGN, GFP_ATOMIC);
 		if (!nskb)
 			goto resubmit;
 
+		skb_reserve(nskb, NET_IP_ALIGN);
 		pci_unmap_single(skge->hw->pdev,
 				 pci_unmap_addr(e, mapaddr),
 				 pci_unmap_len(e, maplen),
@@ -2664,6 +2665,36 @@ resubmit:
 	return NULL;
 }
 
+static void skge_tx_done(struct skge_port *skge)
+{
+	struct skge_ring *ring = &skge->tx_ring;
+	struct skge_element *e, *last;
+
+	spin_lock(&skge->tx_lock);
+	last = ring->to_clean;
+	for (e = ring->to_clean; e != ring->to_use; e = e->next) {
+		struct skge_tx_desc *td = e->desc;
+
+		if (td->control & BMU_OWN)
+			break;
+
+		if (td->control & BMU_EOF) {
+			last = e->next;
+			if (unlikely(netif_msg_tx_done(skge)))
+				printk(KERN_DEBUG PFX "%s: tx done slot %td\n",
+				       skge->netdev->name, e - ring->start);
+		}
+	}
+
+	skge_tx_complete(skge, last);
+
+	skge_write8(skge->hw, Q_ADDR(txqaddr[skge->port], Q_CSR), CSR_IRQ_CL_F);
+
+	if (skge_avail(&skge->tx_ring) > MAX_SKB_FRAGS + 1)
+		netif_wake_queue(skge->netdev);
+
+	spin_unlock(&skge->tx_lock);
+}
 
 static int skge_poll(struct net_device *dev, int *budget)
 {
@@ -2671,8 +2702,10 @@ static int skge_poll(struct net_device *dev, int *budget)
 	struct skge_hw *hw = skge->hw;
 	struct skge_ring *ring = &skge->rx_ring;
 	struct skge_element *e;
-	unsigned int to_do = min(dev->quota, *budget);
-	unsigned int work_done = 0;
+	int to_do = min(dev->quota, *budget);
+	int work_done = 0;
+
+	skge_tx_done(skge);
 
 	for (e = ring->to_clean; prefetch(e->next), work_done < to_do; e = e->next) {
 		struct skge_rx_desc *rd = e->desc;
@@ -2684,15 +2717,14 @@ static int skge_poll(struct net_device *dev, int *budget)
 		if (control & BMU_OWN)
 			break;
 
- 		skb = skge_rx_get(skge, e, control, rd->status,
- 				  le16_to_cpu(rd->csum2));
+		skb = skge_rx_get(skge, e, control, rd->status,
+				  le16_to_cpu(rd->csum2));
 		if (likely(skb)) {
 			dev->last_rx = jiffies;
 			netif_receive_skb(skb);
 
 			++work_done;
-		} else
-			skge_rx_reuse(e, skge->rx_buf_size);
+		}
 	}
 	ring->to_clean = e;
 
@@ -2706,49 +2738,15 @@ static int skge_poll(struct net_device *dev, int *budget)
 	if (work_done >=  to_do)
 		return 1; /* not done */
 
-	spin_lock_irq(&hw->hw_lock);
-	__netif_rx_complete(dev);
-  	hw->intr_mask |= portirqmask[skge->port];
+	netif_rx_complete(dev);
+	mmiowb();
+
+  	hw->intr_mask |= skge->port == 0 ? (IS_R1_F|IS_XA1_F) : (IS_R2_F|IS_XA2_F);
   	skge_write32(hw, B0_IMSK, hw->intr_mask);
- 	spin_unlock_irq(&hw->hw_lock);
 
 	return 0;
 }
 
-static inline void skge_tx_intr(struct net_device *dev)
-{
-	struct skge_port *skge = netdev_priv(dev);
-	struct skge_hw *hw = skge->hw;
-	struct skge_ring *ring = &skge->tx_ring;
-	struct skge_element *e;
-
-	spin_lock(&skge->tx_lock);
-	for (e = ring->to_clean; prefetch(e->next), e != ring->to_use; e = e->next) {
-		struct skge_tx_desc *td = e->desc;
-		u32 control;
-
-		rmb();
-		control = td->control;
-		if (control & BMU_OWN)
-			break;
-
-		if (unlikely(netif_msg_tx_done(skge)))
-			printk(KERN_DEBUG PFX "%s: tx done slot %td status 0x%x\n",
-			       dev->name, e - ring->start, td->status);
-
-		skge_tx_free(hw, e);
-		e->skb = NULL;
-		++skge->tx_avail;
-	}
-	ring->to_clean = e;
-	skge_write8(hw, Q_ADDR(txqaddr[skge->port], Q_CSR), CSR_IRQ_CL_F);
-
-	if (skge->tx_avail > MAX_SKB_FRAGS + 1)
-		netif_wake_queue(dev);
-
-	spin_unlock(&skge->tx_lock);
-}
-
 /* Parity errors seem to happen when Genesis is connected to a switch
  * with no other ports present. Heartbeat error??
  */
@@ -2771,17 +2769,6 @@ static void skge_mac_parity(struct skge_hw *hw, int port)
 			    ? GMF_CLI_TX_FC : GMF_CLI_TX_PE);
 }
 
-static void skge_pci_clear(struct skge_hw *hw)
-{
-	u16 status;
-
-	pci_read_config_word(hw->pdev, PCI_STATUS, &status);
-	skge_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-	pci_write_config_word(hw->pdev, PCI_STATUS,
-			      status | PCI_STATUS_ERROR_BITS);
-	skge_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
-}
-
 static void skge_mac_intr(struct skge_hw *hw, int port)
 {
 	if (hw->chip_id == CHIP_ID_GENESIS)
@@ -2823,23 +2810,39 @@ static void skge_error_irq(struct skge_hw *hw)
 	if (hwstatus & IS_M2_PAR_ERR)
 		skge_mac_parity(hw, 1);
 
-	if (hwstatus & IS_R1_PAR_ERR)
+	if (hwstatus & IS_R1_PAR_ERR) {
+		printk(KERN_ERR PFX "%s: receive queue parity error\n",
+		       hw->dev[0]->name);
 		skge_write32(hw, B0_R1_CSR, CSR_IRQ_CL_P);
+	}
 
-	if (hwstatus & IS_R2_PAR_ERR)
+	if (hwstatus & IS_R2_PAR_ERR) {
+		printk(KERN_ERR PFX "%s: receive queue parity error\n",
+		       hw->dev[1]->name);
 		skge_write32(hw, B0_R2_CSR, CSR_IRQ_CL_P);
+	}
 
 	if (hwstatus & (IS_IRQ_MST_ERR|IS_IRQ_STAT)) {
-		printk(KERN_ERR PFX "hardware error detected (status 0x%x)\n",
-		       hwstatus);
+		u16 pci_status, pci_cmd;
 
-		skge_pci_clear(hw);
+		pci_read_config_word(hw->pdev, PCI_COMMAND, &pci_cmd);
+		pci_read_config_word(hw->pdev, PCI_STATUS, &pci_status);
+
+		printk(KERN_ERR PFX "%s: PCI error cmd=%#x status=%#x\n",
+			       pci_name(hw->pdev), pci_cmd, pci_status);
+
+		/* Write the error bits back to clear them. */
+		pci_status &= PCI_STATUS_ERROR_BITS;
+		skge_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+		pci_write_config_word(hw->pdev, PCI_COMMAND,
+				      pci_cmd | PCI_COMMAND_SERR | PCI_COMMAND_PARITY);
+		pci_write_config_word(hw->pdev, PCI_STATUS, pci_status);
+		skge_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
 		/* if error still set then just ignore it */
 		hwstatus = skge_read32(hw, B0_HWE_ISRC);
 		if (hwstatus & IS_IRQ_STAT) {
-			pr_debug("IRQ status %x: still set ignoring hardware errors\n",
-			       hwstatus);
+			printk(KERN_INFO PFX "unable to clear error (so ignoring them)\n");
 			hw->intr_mask &= ~IS_HW_ERR;
 		}
 	}
@@ -2856,12 +2859,11 @@ static void skge_extirq(unsigned long data)
 	int port;
 
 	spin_lock(&hw->phy_lock);
-	for (port = 0; port < 2; port++) {
+	for (port = 0; port < hw->ports; port++) {
 		struct net_device *dev = hw->dev[port];
+		struct skge_port *skge = netdev_priv(dev);
 
-		if (dev && netif_running(dev)) {
-			struct skge_port *skge = netdev_priv(dev);
-
+		if (netif_running(dev)) {
 			if (hw->chip_id != CHIP_ID_GENESIS)
 				yukon_phy_intr(skge);
 			else
@@ -2870,38 +2872,39 @@ static void skge_extirq(unsigned long data)
 	}
 	spin_unlock(&hw->phy_lock);
 
-	spin_lock_irq(&hw->hw_lock);
 	hw->intr_mask |= IS_EXT_REG;
 	skge_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock_irq(&hw->hw_lock);
 }
 
 static irqreturn_t skge_intr(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct skge_hw *hw = dev_id;
-	u32 status = skge_read32(hw, B0_SP_ISRC);
+	u32 status;
 
-	if (status == 0 || status == ~0) /* hotplug or shared irq */
+	/* Reading this register masks IRQ */
+	status = skge_read32(hw, B0_SP_ISRC);
+	if (status == 0)
 		return IRQ_NONE;
 
-	spin_lock(&hw->hw_lock);
-	if (status & IS_R1_F) {
+	if (status & IS_EXT_REG) {
+		hw->intr_mask &= ~IS_EXT_REG;
+		tasklet_schedule(&hw->ext_tasklet);
+	}
+
+	if (status & (IS_R1_F|IS_XA1_F)) {
 		skge_write8(hw, Q_ADDR(Q_R1, Q_CSR), CSR_IRQ_CL_F);
-		hw->intr_mask &= ~IS_R1_F;
+		hw->intr_mask &= ~(IS_R1_F|IS_XA1_F);
 		netif_rx_schedule(hw->dev[0]);
 	}
 
-	if (status & IS_R2_F) {
+	if (status & (IS_R2_F|IS_XA2_F)) {
 		skge_write8(hw, Q_ADDR(Q_R2, Q_CSR), CSR_IRQ_CL_F);
-		hw->intr_mask &= ~IS_R2_F;
+		hw->intr_mask &= ~(IS_R2_F|IS_XA2_F);
 		netif_rx_schedule(hw->dev[1]);
 	}
 
-	if (status & IS_XA1_F)
-		skge_tx_intr(hw->dev[0]);
-
-	if (status & IS_XA2_F)
-		skge_tx_intr(hw->dev[1]);
+	if (likely((status & hw->intr_mask) == 0))
+		return IRQ_HANDLED;
 
 	if (status & IS_PA_TO_RX1) {
 		struct skge_port *skge = netdev_priv(hw->dev[0]);
@@ -2930,13 +2933,7 @@ static irqreturn_t skge_intr(int irq, void *dev_id, struct pt_regs *regs)
 	if (status & IS_HW_ERR)
 		skge_error_irq(hw);
 
-	if (status & IS_EXT_REG) {
-		hw->intr_mask &= ~IS_EXT_REG;
-		tasklet_schedule(&hw->ext_tasklet);
-	}
-
 	skge_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock(&hw->hw_lock);
 
 	return IRQ_HANDLED;
 }
@@ -3011,7 +3008,7 @@ static const char *skge_board_name(const struct skge_hw *hw)
 static int skge_reset(struct skge_hw *hw)
 {
 	u32 reg;
-	u16 ctst;
+	u16 ctst, pci_status;
 	u8 t8, mac_cfg, pmd_type, phy_type;
 	int i;
 
@@ -3022,8 +3019,13 @@ static int skge_reset(struct skge_hw *hw)
 	skge_write8(hw, B0_CTST, CS_RST_CLR);
 
 	/* clear PCI errors, if any */
-	skge_pci_clear(hw);
+	skge_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+	skge_write8(hw, B2_TST_CTRL2, 0);
 
+	pci_read_config_word(hw->pdev, PCI_STATUS, &pci_status);
+	pci_write_config_word(hw->pdev, PCI_STATUS,
+			      pci_status | PCI_STATUS_ERROR_BITS);
+	skge_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 	skge_write8(hw, B0_CTST, CS_MRST_CLR);
 
 	/* restore CLK_RUN bits (for Yukon-Lite) */
@@ -3082,7 +3084,10 @@ static int skge_reset(struct skge_hw *hw)
 	else
 		hw->ram_size = t8 * 4096;
 
-	hw->intr_mask = IS_HW_ERR | IS_EXT_REG;
+	hw->intr_mask = IS_HW_ERR | IS_EXT_REG | IS_PORT_1;
+	if (hw->ports > 1)
+		hw->intr_mask |= IS_PORT_2;
+
 	if (hw->chip_id == CHIP_ID_GENESIS)
 		genesis_init(hw);
 	else {
@@ -3252,13 +3257,15 @@ static int __devinit skge_probe(struct pci_dev *pdev,
 	struct skge_hw *hw;
 	int err, using_dac = 0;
 
-	if ((err = pci_enable_device(pdev))) {
+	err = pci_enable_device(pdev);
+	if (err) {
 		printk(KERN_ERR PFX "%s cannot enable PCI device\n",
 		       pci_name(pdev));
 		goto err_out;
 	}
 
-	if ((err = pci_request_regions(pdev, DRV_NAME))) {
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err) {
 		printk(KERN_ERR PFX "%s cannot obtain PCI resources\n",
 		       pci_name(pdev));
 		goto err_out_disable_pdev;
@@ -3266,22 +3273,18 @@ static int __devinit skge_probe(struct pci_dev *pdev,
 
 	pci_set_master(pdev);
 
-	if (sizeof(dma_addr_t) > sizeof(u32) &&
-	    !(err = pci_set_dma_mask(pdev, DMA_64BIT_MASK))) {
+	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK)) {
 		using_dac = 1;
 		err = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK);
-		if (err < 0) {
-			printk(KERN_ERR PFX "%s unable to obtain 64 bit DMA "
-			       "for consistent allocations\n", pci_name(pdev));
-			goto err_out_free_regions;
-		}
-	} else {
-		err = pci_set_dma_mask(pdev, DMA_32BIT_MASK);
-		if (err) {
-			printk(KERN_ERR PFX "%s no usable DMA configuration\n",
-			       pci_name(pdev));
-			goto err_out_free_regions;
-		}
+	} else if (!(err = pci_set_dma_mask(pdev, DMA_32BIT_MASK))) {
+		using_dac = 0;
+		err = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+	}
+
+	if (err) {
+		printk(KERN_ERR PFX "%s no usable DMA configuration\n",
+		       pci_name(pdev));
+		goto err_out_free_regions;
 	}
 
 #ifdef __BIG_ENDIAN
@@ -3305,7 +3308,6 @@ static int __devinit skge_probe(struct pci_dev *pdev,
 
 	hw->pdev = pdev;
 	spin_lock_init(&hw->phy_lock);
-	spin_lock_init(&hw->hw_lock);
 	tasklet_init(&hw->ext_tasklet, skge_extirq, (unsigned long) hw);
 
 	hw->regs = ioremap_nocache(pci_resource_start(pdev, 0), 0x4000);
@@ -3315,7 +3317,8 @@ static int __devinit skge_probe(struct pci_dev *pdev,
 		goto err_out_free_hw;
 	}
 
-	if ((err = request_irq(pdev->irq, skge_intr, SA_SHIRQ, DRV_NAME, hw))) {
+	err = request_irq(pdev->irq, skge_intr, SA_SHIRQ, DRV_NAME, hw);
+	if (err) {
 		printk(KERN_ERR PFX "%s: cannot assign irq %d\n",
 		       pci_name(pdev), pdev->irq);
 		goto err_out_iounmap;
@@ -3333,7 +3336,8 @@ static int __devinit skge_probe(struct pci_dev *pdev,
 	if ((dev = skge_devinit(hw, 0, using_dac)) == NULL)
 		goto err_out_led_off;
 
-	if ((err = register_netdev(dev))) {
+	err = register_netdev(dev);
+	if (err) {
 		printk(KERN_ERR PFX "%s: cannot register net device\n",
 		       pci_name(pdev));
 		goto err_out_free_netdev;
@@ -3388,7 +3392,6 @@ static void __devexit skge_remove(struct pci_dev *pdev)
 
 	skge_write32(hw, B0_IMSK, 0);
 	skge_write16(hw, B0_LED, LED_STAT_OFF);
-	skge_pci_clear(hw);
 	skge_write8(hw, B0_CTST, CS_RST_SET);
 
 	tasklet_kill(&hw->ext_tasklet);
diff --git a/drivers/net/skge.h b/drivers/net/skge.h
index 941f12a333..1f1ce88c81 100644
--- a/drivers/net/skge.h
+++ b/drivers/net/skge.h
@@ -2402,7 +2402,6 @@ struct skge_hw {
 
 	struct tasklet_struct ext_tasklet;
 	spinlock_t	     phy_lock;
-	spinlock_t	     hw_lock;
 };
 
 enum {
@@ -2419,7 +2418,6 @@ struct skge_port {
 	int		     port;
 
 	spinlock_t	     tx_lock;
-	u32		     tx_avail;
 	struct skge_ring     tx_ring;
 	struct skge_ring     rx_ring;
 
diff --git a/drivers/net/sky2.c b/drivers/net/sky2.c
index e01191a693..fc3eb2dafe 100644
--- a/drivers/net/sky2.c
+++ b/drivers/net/sky2.c
@@ -51,7 +51,7 @@
 #include "sky2.h"
 
 #define DRV_NAME		"sky2"
-#define DRV_VERSION		"0.15.1"
+#define DRV_VERSION		"1.4"
 #define PFX			DRV_NAME " "
 
 /*
@@ -61,10 +61,6 @@
  * a receive requires one (or two if using 64 bit dma).
  */
 
-#define is_ec_a1(hw) \
-	unlikely((hw)->chip_id == CHIP_ID_YUKON_EC && \
-		 (hw)->chip_rev == CHIP_REV_YU_EC_A1)
-
 #define RX_LE_SIZE	    	512
 #define RX_LE_BYTES		(RX_LE_SIZE*sizeof(struct sky2_rx_le))
 #define RX_MAX_PENDING		(RX_LE_SIZE/2 - 2)
@@ -83,6 +79,8 @@
 #define NAPI_WEIGHT		64
 #define PHY_RETRIES		1000
 
+#define RING_NEXT(x,s)	(((x)+1) & ((s)-1))
+
 static const u32 default_msg =
     NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK
     | NETIF_MSG_TIMER | NETIF_MSG_TX_ERR | NETIF_MSG_RX_ERR
@@ -96,6 +94,14 @@ static int copybreak __read_mostly = 256;
 module_param(copybreak, int, 0);
 MODULE_PARM_DESC(copybreak, "Receive copy threshold");
 
+static int disable_msi = 0;
+module_param(disable_msi, int, 0);
+MODULE_PARM_DESC(disable_msi, "Disable Message Signaled Interrupt (MSI)");
+
+static int idle_timeout = 100;
+module_param(idle_timeout, int, 0);
+MODULE_PARM_DESC(idle_timeout, "Idle timeout workaround for lost interrupts (ms)");
+
 static const struct pci_device_id sky2_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, 0x9000) }, /* SK-9Sxx */
 	{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, 0x9E00) }, /* SK-9Exx */
@@ -134,6 +140,7 @@ MODULE_DEVICE_TABLE(pci, sky2_id_table);
 /* Avoid conditionals by using array */
 static const unsigned txqaddr[] = { Q_XA1, Q_XA2 };
 static const unsigned rxqaddr[] = { Q_R1, Q_R2 };
+static const u32 portirq_msk[] = { Y2_IS_PORT_1, Y2_IS_PORT_2 };
 
 /* This driver supports yukon2 chipset only */
 static const char *yukon2_name[] = {
@@ -240,6 +247,7 @@ static int sky2_set_power_state(struct sky2_hw *hw, pci_power_t state)
 		}
 
 		if (hw->chip_id == CHIP_ID_YUKON_EC_U) {
+			sky2_write16(hw, B0_CTST, Y2_HW_WOL_ON);
 			sky2_pci_write32(hw, PCI_DEV_REG3, 0);
 			reg1 = sky2_pci_read32(hw, PCI_DEV_REG4);
 			reg1 &= P_ASPM_CONTROL_MSK;
@@ -310,7 +318,8 @@ static void sky2_phy_init(struct sky2_hw *hw, unsigned port)
 	struct sky2_port *sky2 = netdev_priv(hw->dev[port]);
 	u16 ctrl, ct1000, adv, pg, ledctrl, ledover;
 
-	if (sky2->autoneg == AUTONEG_ENABLE && hw->chip_id != CHIP_ID_YUKON_XL) {
+	if (sky2->autoneg == AUTONEG_ENABLE &&
+	    !(hw->chip_id == CHIP_ID_YUKON_XL || hw->chip_id == CHIP_ID_YUKON_EC_U)) {
 		u16 ectrl = gm_phy_read(hw, port, PHY_MARV_EXT_CTRL);
 
 		ectrl &= ~(PHY_M_EC_M_DSC_MSK | PHY_M_EC_S_DSC_MSK |
@@ -338,7 +347,7 @@ static void sky2_phy_init(struct sky2_hw *hw, unsigned port)
 			ctrl |= PHY_M_PC_MDI_XMODE(PHY_M_PC_ENA_AUTO);
 
 			if (sky2->autoneg == AUTONEG_ENABLE &&
-			    hw->chip_id == CHIP_ID_YUKON_XL) {
+			    (hw->chip_id == CHIP_ID_YUKON_XL || hw->chip_id == CHIP_ID_YUKON_EC_U)) {
 				ctrl &= ~PHY_M_PC_DSC_MSK;
 				ctrl |= PHY_M_PC_DSC(2) | PHY_M_PC_DOWN_S_ENA;
 			}
@@ -470,10 +479,11 @@ static void sky2_phy_init(struct sky2_hw *hw, unsigned port)
 		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);
 
 		/* set LED Function Control register */
-		gm_phy_write(hw, port, PHY_MARV_PHY_CTRL, (PHY_M_LEDC_LOS_CTRL(1) |	/* LINK/ACT */
-							   PHY_M_LEDC_INIT_CTRL(7) |	/* 10 Mbps */
-							   PHY_M_LEDC_STA1_CTRL(7) |	/* 100 Mbps */
-							   PHY_M_LEDC_STA0_CTRL(7)));	/* 1000 Mbps */
+		gm_phy_write(hw, port, PHY_MARV_PHY_CTRL,
+			     (PHY_M_LEDC_LOS_CTRL(1) |	/* LINK/ACT */
+			      PHY_M_LEDC_INIT_CTRL(7) |	/* 10 Mbps */
+			      PHY_M_LEDC_STA1_CTRL(7) |	/* 100 Mbps */
+			      PHY_M_LEDC_STA0_CTRL(7)));	/* 1000 Mbps */
 
 		/* set Polarity Control register */
 		gm_phy_write(hw, port, PHY_MARV_PHY_STAT,
@@ -487,6 +497,25 @@ static void sky2_phy_init(struct sky2_hw *hw, unsigned port)
 		/* restore page register */
 		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);
 		break;
+	case CHIP_ID_YUKON_EC_U:
+		pg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);
+
+		/* select page 3 to access LED control register */
+		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);
+
+		/* set LED Function Control register */
+		gm_phy_write(hw, port, PHY_MARV_PHY_CTRL,
+			     (PHY_M_LEDC_LOS_CTRL(1) |	/* LINK/ACT */
+			      PHY_M_LEDC_INIT_CTRL(8) |	/* 10 Mbps */
+			      PHY_M_LEDC_STA1_CTRL(7) |	/* 100 Mbps */
+			      PHY_M_LEDC_STA0_CTRL(7)));/* 1000 Mbps */
+
+		/* set Blink Rate in LED Timer Control Register */
+		gm_phy_write(hw, port, PHY_MARV_INT_MASK,
+			     ledctrl | PHY_M_LED_BLINK_RT(BLINK_84MS));
+		/* restore page register */
+		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);
+		break;
 
 	default:
 		/* set Tx LED (LED_TX) to blink mode on Rx OR Tx activity */
@@ -495,19 +524,21 @@ static void sky2_phy_init(struct sky2_hw *hw, unsigned port)
 		ledover |= PHY_M_LED_MO_RX(MO_LED_OFF);
 	}
 
-	if (hw->chip_id == CHIP_ID_YUKON_EC_U && hw->chip_rev >= 2) {
+	if (hw->chip_id == CHIP_ID_YUKON_EC_U && hw->chip_rev == CHIP_REV_YU_EC_A1) {
 		/* apply fixes in PHY AFE */
-		gm_phy_write(hw, port, 22, 255);
+		pg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);
+		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, 255);
+
 		/* increase differential signal amplitude in 10BASE-T */
-		gm_phy_write(hw, port, 24, 0xaa99);
-		gm_phy_write(hw, port, 23, 0x2011);
+		gm_phy_write(hw, port, 0x18, 0xaa99);
+		gm_phy_write(hw, port, 0x17, 0x2011);
 
 		/* fix for IEEE A/B Symmetry failure in 1000BASE-T */
-		gm_phy_write(hw, port, 24, 0xa204);
-		gm_phy_write(hw, port, 23, 0x2002);
+		gm_phy_write(hw, port, 0x18, 0xa204);
+		gm_phy_write(hw, port, 0x17, 0x2002);
 
 		/* set page register to 0 */
-		gm_phy_write(hw, port, 22, 0);
+		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);
 	} else {
 		gm_phy_write(hw, port, PHY_MARV_LED_CTRL, ledctrl);
 
@@ -530,9 +561,9 @@ static void sky2_phy_init(struct sky2_hw *hw, unsigned port)
 /* Force a renegotiation */
 static void sky2_phy_reinit(struct sky2_port *sky2)
 {
-	down(&sky2->phy_sema);
+	spin_lock_bh(&sky2->phy_lock);
 	sky2_phy_init(sky2->hw, sky2->port);
-	up(&sky2->phy_sema);
+	spin_unlock_bh(&sky2->phy_lock);
 }
 
 static void sky2_mac_init(struct sky2_hw *hw, unsigned port)
@@ -581,6 +612,11 @@ static void sky2_mac_init(struct sky2_hw *hw, unsigned port)
 
 		if (sky2->duplex == DUPLEX_FULL)
 			reg |= GM_GPCR_DUP_FULL;
+
+		/* turn off pause in 10/100mbps half duplex */
+		else if (sky2->speed != SPEED_1000 &&
+			 hw->chip_id != CHIP_ID_YUKON_EC_U)
+			sky2->tx_pause = sky2->rx_pause = 0;
 	} else
 		reg = GM_GPCR_SPEED_1000 | GM_GPCR_SPEED_100 | GM_GPCR_DUP_FULL;
 
@@ -597,9 +633,9 @@ static void sky2_mac_init(struct sky2_hw *hw, unsigned port)
 
 	sky2_read16(hw, SK_REG(port, GMAC_IRQ_SRC));
 
-	down(&sky2->phy_sema);
+	spin_lock_bh(&sky2->phy_lock);
 	sky2_phy_init(hw, port);
-	up(&sky2->phy_sema);
+	spin_unlock_bh(&sky2->phy_lock);
 
 	/* MIB clear */
 	reg = gma_read16(hw, port, GM_PHY_ADDR);
@@ -747,41 +783,15 @@ static inline struct sky2_tx_le *get_tx_le(struct sky2_port *sky2)
 {
 	struct sky2_tx_le *le = sky2->tx_le + sky2->tx_prod;
 
-	sky2->tx_prod = (sky2->tx_prod + 1) % TX_RING_SIZE;
+	sky2->tx_prod = RING_NEXT(sky2->tx_prod, TX_RING_SIZE);
 	return le;
 }
 
-/*
- * This is a workaround code taken from SysKonnect sk98lin driver
- * to deal with chip bug on Yukon EC rev 0 in the wraparound case.
- */
-static void sky2_put_idx(struct sky2_hw *hw, unsigned q,
-				u16 idx, u16 *last, u16 size)
+/* Update chip's next pointer */
+static inline void sky2_put_idx(struct sky2_hw *hw, unsigned q, u16 idx)
 {
 	wmb();
-	if (is_ec_a1(hw) && idx < *last) {
-		u16 hwget = sky2_read16(hw, Y2_QADDR(q, PREF_UNIT_GET_IDX));
-
-		if (hwget == 0) {
-			/* Start prefetching again */
-			sky2_write8(hw, Y2_QADDR(q, PREF_UNIT_FIFO_WM), 0xe0);
-			goto setnew;
-		}
-
-		if (hwget == size - 1) {
-			/* set watermark to one list element */
-			sky2_write8(hw, Y2_QADDR(q, PREF_UNIT_FIFO_WM), 8);
-
-			/* set put index to first list element */
-			sky2_write16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX), 0);
-		} else		/* have hardware go to end of list */
-			sky2_write16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX),
-				     size - 1);
-	} else {
-setnew:
-		sky2_write16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX), idx);
-	}
-	*last = idx;
+	sky2_write16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX), idx);
 	mmiowb();
 }
 
@@ -789,7 +799,7 @@ setnew:
 static inline struct sky2_rx_le *sky2_next_rx(struct sky2_port *sky2)
 {
 	struct sky2_rx_le *le = sky2->rx_le + sky2->rx_put;
-	sky2->rx_put = (sky2->rx_put + 1) % RX_LE_SIZE;
+	sky2->rx_put = RING_NEXT(sky2->rx_put, RX_LE_SIZE);
 	return le;
 }
 
@@ -904,7 +914,7 @@ static int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	if (!netif_running(dev))
 		return -ENODEV;	/* Phy still in reset */
 
-	switch(cmd) {
+	switch (cmd) {
 	case SIOCGMIIPHY:
 		data->phy_id = PHY_ADDR_MARV;
 
@@ -912,9 +922,9 @@ static int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIREG: {
 		u16 val = 0;
 
-		down(&sky2->phy_sema);
+		spin_lock_bh(&sky2->phy_lock);
 		err = __gm_phy_read(hw, sky2->port, data->reg_num & 0x1f, &val);
-		up(&sky2->phy_sema);
+		spin_unlock_bh(&sky2->phy_lock);
 
 		data->val_out = val;
 		break;
@@ -924,10 +934,10 @@ static int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 
-		down(&sky2->phy_sema);
+		spin_lock_bh(&sky2->phy_lock);
 		err = gm_phy_write(hw, sky2->port, data->reg_num & 0x1f,
 				   data->val_in);
-		up(&sky2->phy_sema);
+		spin_unlock_bh(&sky2->phy_lock);
 		break;
 	}
 	return err;
@@ -979,8 +989,7 @@ static inline struct sk_buff *sky2_alloc_skb(unsigned int size, gfp_t gfp_mask)
 	skb = __dev_alloc_skb(size + RX_SKB_ALIGN, gfp_mask);
 	if (likely(skb)) {
 		unsigned long p	= (unsigned long) skb->data;
-		skb_reserve(skb,
-			((p + RX_SKB_ALIGN - 1) & ~(RX_SKB_ALIGN - 1)) - p);
+		skb_reserve(skb, ALIGN(p, RX_SKB_ALIGN) - p);
 	}
 
 	return skb;
@@ -997,6 +1006,7 @@ static int sky2_rx_start(struct sky2_port *sky2)
 	struct sky2_hw *hw = sky2->hw;
 	unsigned rxq = rxqaddr[sky2->port];
 	int i;
+	unsigned thresh;
 
 	sky2->rx_put = sky2->rx_next = 0;
 	sky2_qset(hw, rxq);
@@ -1021,13 +1031,24 @@ static int sky2_rx_start(struct sky2_port *sky2)
 		sky2_rx_add(sky2, re->mapaddr);
 	}
 
- 	/* Truncate oversize frames */
- 	sky2_write16(hw, SK_REG(sky2->port, RX_GMF_TR_THR), sky2->rx_bufsize - 8);
- 	sky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_ON);
+
+	/*
+	 * The receiver hangs if it receives frames larger than the
+	 * packet buffer. As a workaround, truncate oversize frames, but
+	 * the register is limited to 9 bits, so if you do frames > 2052
+	 * you better get the MTU right!
+	 */
+	thresh = (sky2->rx_bufsize - 8) / sizeof(u32);
+	if (thresh > 0x1ff)
+		sky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_OFF);
+	else {
+		sky2_write16(hw, SK_REG(sky2->port, RX_GMF_TR_THR), thresh);
+		sky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_ON);
+	}
+
 
 	/* Tell chip about available buffers */
 	sky2_write16(hw, Y2_QADDR(rxq, PREF_UNIT_PUT_IDX), sky2->rx_put);
-	sky2->rx_last_put = sky2_read16(hw, Y2_QADDR(rxq, PREF_UNIT_PUT_IDX));
 	return 0;
 nomem:
 	sky2_rx_clean(sky2);
@@ -1040,7 +1061,7 @@ static int sky2_up(struct net_device *dev)
 	struct sky2_port *sky2 = netdev_priv(dev);
 	struct sky2_hw *hw = sky2->hw;
 	unsigned port = sky2->port;
-	u32 ramsize, rxspace;
+	u32 ramsize, rxspace, imask;
 	int cap, err = -ENOMEM;
 	struct net_device *otherdev = hw->dev[sky2->port^1];
 
@@ -1121,10 +1142,10 @@ static int sky2_up(struct net_device *dev)
 		goto err_out;
 
 	/* Enable interrupts from phy/mac for port */
-	spin_lock_irq(&hw->hw_lock);
-	hw->intr_mask |= (port == 0) ? Y2_IS_PORT_1 : Y2_IS_PORT_2;
-	sky2_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock_irq(&hw->hw_lock);
+	imask = sky2_read32(hw, B0_IMSK);
+	imask |= portirq_msk[port];
+	sky2_write32(hw, B0_IMSK, imask);
+
 	return 0;
 
 err_out:
@@ -1150,7 +1171,7 @@ err_out:
 /* Modular subtraction in ring */
 static inline int tx_dist(unsigned tail, unsigned head)
 {
-	return (head - tail) % TX_RING_SIZE;
+	return (head - tail) & (TX_RING_SIZE - 1);
 }
 
 /* Number of list elements available for next tx */
@@ -1244,7 +1265,7 @@ static int sky2_xmit_frame(struct sk_buff *skb, struct net_device *dev)
 		/* just drop the packet if non-linear expansion fails */
 		if (skb_header_cloned(skb) &&
 		    pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
-			dev_kfree_skb_any(skb);
+			dev_kfree_skb(skb);
 			goto out_unlock;
 		}
 
@@ -1327,7 +1348,7 @@ static int sky2_xmit_frame(struct sk_buff *skb, struct net_device *dev)
 		le->opcode = OP_BUFFER | HW_OWNER;
 
 		fre = sky2->tx_ring
-		    + ((re - sky2->tx_ring) + i + 1) % TX_RING_SIZE;
+		    + RING_NEXT((re - sky2->tx_ring) + i, TX_RING_SIZE);
 		pci_unmap_addr_set(fre, mapaddr, mapping);
 	}
 
@@ -1341,8 +1362,7 @@ static int sky2_xmit_frame(struct sk_buff *skb, struct net_device *dev)
 			netif_stop_queue(dev);
 	}
 
-	sky2_put_idx(hw, txqaddr[sky2->port], sky2->tx_prod,
-		     &sky2->tx_last_put, TX_RING_SIZE);
+	sky2_put_idx(hw, txqaddr[sky2->port], sky2->tx_prod);
 
 out_unlock:
 	spin_unlock(&sky2->tx_lock);
@@ -1374,7 +1394,7 @@ static void sky2_tx_complete(struct sky2_port *sky2, u16 done)
 		struct tx_ring_info *re = sky2->tx_ring + put;
 		struct sk_buff *skb = re->skb;
 
-  		nxt = re->idx;
+		nxt = re->idx;
 		BUG_ON(nxt >= TX_RING_SIZE);
 		prefetch(sky2->tx_ring + nxt);
 
@@ -1388,17 +1408,17 @@ static void sky2_tx_complete(struct sky2_port *sky2, u16 done)
 
 		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 			struct tx_ring_info *fre;
-			fre = sky2->tx_ring + (put + i + 1) % TX_RING_SIZE;
+			fre = sky2->tx_ring + RING_NEXT(put + i, TX_RING_SIZE);
 			pci_unmap_page(pdev, pci_unmap_addr(fre, mapaddr),
-  				       skb_shinfo(skb)->frags[i].size,
+				       skb_shinfo(skb)->frags[i].size,
 				       PCI_DMA_TODEVICE);
 		}
 
-		dev_kfree_skb_any(skb);
+		dev_kfree_skb(skb);
 	}
 
 	sky2->tx_cons = put;
-	if (netif_queue_stopped(dev) && tx_avail(sky2) > MAX_SKB_TX_LE)
+	if (tx_avail(sky2) > MAX_SKB_TX_LE)
 		netif_wake_queue(dev);
 }
 
@@ -1417,6 +1437,7 @@ static int sky2_down(struct net_device *dev)
 	struct sky2_hw *hw = sky2->hw;
 	unsigned port = sky2->port;
 	u16 ctrl;
+	u32 imask;
 
 	/* Never really got started! */
 	if (!sky2->tx_le)
@@ -1436,14 +1457,6 @@ static int sky2_down(struct net_device *dev)
  	if (sky2->port == 0 && hw->ports > 1)
  		netif_poll_enable(dev);
 
-	/* Disable port IRQ */
-	spin_lock_irq(&hw->hw_lock);
-	hw->intr_mask &= ~((sky2->port == 0) ? Y2_IS_IRQ_PHY1 : Y2_IS_IRQ_PHY2);
-	sky2_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock_irq(&hw->hw_lock);
-
-	flush_scheduled_work();
-
 	sky2_phy_reset(hw, port);
 
 	/* Stop transmitter */
@@ -1487,6 +1500,11 @@ static int sky2_down(struct net_device *dev)
 	sky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_SET);
 	sky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_RST_SET);
 
+	/* Disable port IRQ */
+	imask = sky2_read32(hw, B0_IMSK);
+	imask &= ~portirq_msk[port];
+	sky2_write32(hw, B0_IMSK, imask);
+
 	/* turn off LED's */
 	sky2_write16(hw, B0_Y2LED, LED_STAT_OFF);
 
@@ -1581,17 +1599,26 @@ static void sky2_link_up(struct sky2_port *sky2)
 	sky2_write8(hw, SK_REG(port, LNK_LED_REG),
 		    LINKLED_ON | LINKLED_BLINK_OFF | LINKLED_LINKSYNC_OFF);
 
-	if (hw->chip_id == CHIP_ID_YUKON_XL) {
+	if (hw->chip_id == CHIP_ID_YUKON_XL || hw->chip_id == CHIP_ID_YUKON_EC_U) {
 		u16 pg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);
+		u16 led = PHY_M_LEDC_LOS_CTRL(1);	/* link active */
+
+		switch(sky2->speed) {
+		case SPEED_10:
+			led |= PHY_M_LEDC_INIT_CTRL(7);
+			break;
+
+		case SPEED_100:
+			led |= PHY_M_LEDC_STA1_CTRL(7);
+			break;
+
+		case SPEED_1000:
+			led |= PHY_M_LEDC_STA0_CTRL(7);
+			break;
+		}
 
 		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);
-		gm_phy_write(hw, port, PHY_MARV_PHY_CTRL, PHY_M_LEDC_LOS_CTRL(1) |	/* LINK/ACT */
-			     PHY_M_LEDC_INIT_CTRL(sky2->speed ==
-						  SPEED_10 ? 7 : 0) |
-			     PHY_M_LEDC_STA1_CTRL(sky2->speed ==
-						  SPEED_100 ? 7 : 0) |
-			     PHY_M_LEDC_STA0_CTRL(sky2->speed ==
-						  SPEED_1000 ? 7 : 0));
+		gm_phy_write(hw, port, PHY_MARV_PHY_CTRL, led);
 		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);
 	}
 
@@ -1666,7 +1693,7 @@ static int sky2_autoneg_done(struct sky2_port *sky2, u16 aux)
 	sky2->speed = sky2_phy_speed(hw, aux);
 
 	/* Pause bits are offset (9..8) */
-	if (hw->chip_id == CHIP_ID_YUKON_XL)
+	if (hw->chip_id == CHIP_ID_YUKON_XL || hw->chip_id == CHIP_ID_YUKON_EC_U)
 		aux >>= 6;
 
 	sky2->rx_pause = (aux & PHY_M_PS_RX_P_EN) != 0;
@@ -1681,20 +1708,19 @@ static int sky2_autoneg_done(struct sky2_port *sky2, u16 aux)
 	return 0;
 }
 
-/*
- * Interrupt from PHY are handled outside of interrupt context
- * because accessing phy registers requires spin wait which might
- * cause excess interrupt latency.
- */
-static void sky2_phy_task(void *arg)
+/* Interrupt from PHY */
+static void sky2_phy_intr(struct sky2_hw *hw, unsigned port)
 {
-	struct sky2_port *sky2 = arg;
-	struct sky2_hw *hw = sky2->hw;
+	struct net_device *dev = hw->dev[port];
+	struct sky2_port *sky2 = netdev_priv(dev);
 	u16 istatus, phystat;
 
-	down(&sky2->phy_sema);
-	istatus = gm_phy_read(hw, sky2->port, PHY_MARV_INT_STAT);
-	phystat = gm_phy_read(hw, sky2->port, PHY_MARV_PHY_STAT);
+	spin_lock(&sky2->phy_lock);
+	istatus = gm_phy_read(hw, port, PHY_MARV_INT_STAT);
+	phystat = gm_phy_read(hw, port, PHY_MARV_PHY_STAT);
+
+	if (!netif_running(dev))
+		goto out;
 
 	if (netif_msg_intr(sky2))
 		printk(KERN_INFO PFX "%s: phy interrupt status 0x%x 0x%x\n",
@@ -1720,12 +1746,7 @@ static void sky2_phy_task(void *arg)
 			sky2_link_down(sky2);
 	}
 out:
-	up(&sky2->phy_sema);
-
-	spin_lock_irq(&hw->hw_lock);
-	hw->intr_mask |= (sky2->port == 0) ? Y2_IS_IRQ_PHY1 : Y2_IS_IRQ_PHY2;
-	sky2_write32(hw, B0_IMSK, hw->intr_mask);
-	spin_unlock_irq(&hw->hw_lock);
+	spin_unlock(&sky2->phy_lock);
 }
 
 
@@ -1737,41 +1758,49 @@ static void sky2_tx_timeout(struct net_device *dev)
 	struct sky2_port *sky2 = netdev_priv(dev);
 	struct sky2_hw *hw = sky2->hw;
 	unsigned txq = txqaddr[sky2->port];
-	u16 ridx;
-
-	/* Maybe we just missed an status interrupt */
-	spin_lock(&sky2->tx_lock);
-	ridx = sky2_read16(hw,
-			   sky2->port == 0 ? STAT_TXA1_RIDX : STAT_TXA2_RIDX);
-	sky2_tx_complete(sky2, ridx);
-	spin_unlock(&sky2->tx_lock);
-
-	if (!netif_queue_stopped(dev)) {
-		if (net_ratelimit())
-			pr_info(PFX "transmit interrupt missed? recovered\n");
-		return;
-	}
+	u16 report, done;
 
 	if (netif_msg_timer(sky2))
 		printk(KERN_ERR PFX "%s: tx timeout\n", dev->name);
 
-	sky2_write32(hw, Q_ADDR(txq, Q_CSR), BMU_STOP);
-	sky2_write32(hw, Y2_QADDR(txq, PREF_UNIT_CTRL), PREF_UNIT_RST_SET);
+	report = sky2_read16(hw, sky2->port == 0 ? STAT_TXA1_RIDX : STAT_TXA2_RIDX);
+	done = sky2_read16(hw, Q_ADDR(txq, Q_DONE));
 
-	sky2_tx_clean(sky2);
+	printk(KERN_DEBUG PFX "%s: transmit ring %u .. %u report=%u done=%u\n",
+	       dev->name,
+	       sky2->tx_cons, sky2->tx_prod, report, done);
+
+	if (report != done) {
+		printk(KERN_INFO PFX "status burst pending (irq moderation?)\n");
+
+		sky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_STOP);
+		sky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_START);
+	} else if (report != sky2->tx_cons) {
+		printk(KERN_INFO PFX "status report lost?\n");
+
+		spin_lock_bh(&sky2->tx_lock);
+		sky2_tx_complete(sky2, report);
+		spin_unlock_bh(&sky2->tx_lock);
+	} else {
+		printk(KERN_INFO PFX "hardware hung? flushing\n");
 
-	sky2_qset(hw, txq);
-	sky2_prefetch_init(hw, txq, sky2->tx_le_map, TX_RING_SIZE - 1);
+		sky2_write32(hw, Q_ADDR(txq, Q_CSR), BMU_STOP);
+		sky2_write32(hw, Y2_QADDR(txq, PREF_UNIT_CTRL), PREF_UNIT_RST_SET);
+
+		sky2_tx_clean(sky2);
+
+		sky2_qset(hw, txq);
+		sky2_prefetch_init(hw, txq, sky2->tx_le_map, TX_RING_SIZE - 1);
+	}
 }
 
 
-#define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
 /* Want receive buffer size to be multiple of 64 bits
  * and incl room for vlan and truncation
  */
 static inline unsigned sky2_buf_size(int mtu)
 {
-	return roundup(mtu + ETH_HLEN + VLAN_HLEN, 8) + 8;
+	return ALIGN(mtu + ETH_HLEN + VLAN_HLEN, 8) + 8;
 }
 
 static int sky2_change_mtu(struct net_device *dev, int new_mtu)
@@ -1780,6 +1809,7 @@ static int sky2_change_mtu(struct net_device *dev, int new_mtu)
 	struct sky2_hw *hw = sky2->hw;
 	int err;
 	u16 ctl, mode;
+	u32 imask;
 
 	if (new_mtu < ETH_ZLEN || new_mtu > ETH_JUMBO_MTU)
 		return -EINVAL;
@@ -1792,12 +1822,15 @@ static int sky2_change_mtu(struct net_device *dev, int new_mtu)
 		return 0;
 	}
 
+	imask = sky2_read32(hw, B0_IMSK);
 	sky2_write32(hw, B0_IMSK, 0);
 
 	dev->trans_start = jiffies;	/* prevent tx timeout */
 	netif_stop_queue(dev);
 	netif_poll_disable(hw->dev[0]);
 
+	synchronize_irq(hw->pdev->irq);
+
 	ctl = gma_read16(hw, sky2->port, GM_GP_CTRL);
 	gma_write16(hw, sky2->port, GM_GP_CTRL, ctl & ~GM_GPCR_RX_ENA);
 	sky2_rx_stop(sky2);
@@ -1816,7 +1849,7 @@ static int sky2_change_mtu(struct net_device *dev, int new_mtu)
 	sky2_write8(hw, RB_ADDR(rxqaddr[sky2->port], RB_CTRL), RB_ENA_OP_MD);
 
 	err = sky2_rx_start(sky2);
-	sky2_write32(hw, B0_IMSK, hw->intr_mask);
+	sky2_write32(hw, B0_IMSK, imask);
 
 	if (err)
 		dev_close(dev);
@@ -1893,8 +1926,7 @@ resubmit:
 	sky2_rx_add(sky2, re->mapaddr);
 
 	/* Tell receiver about new buffers. */
-	sky2_put_idx(sky2->hw, rxqaddr[sky2->port], sky2->rx_put,
-		     &sky2->rx_last_put, RX_LE_SIZE);
+	sky2_put_idx(sky2->hw, rxqaddr[sky2->port], sky2->rx_put);
 
 	return skb;
 
@@ -1921,55 +1953,33 @@ error:
 	goto resubmit;
 }
 
-/*
- * Check for transmit complete
- */
-#define TX_NO_STATUS	0xffff
-
-static void sky2_tx_check(struct sky2_hw *hw, int port, u16 last)
+/* Transmit complete */
+static inline void sky2_tx_done(struct net_device *dev, u16 last)
 {
-	if (last != TX_NO_STATUS) {
-		struct net_device *dev = hw->dev[port];
-		if (dev && netif_running(dev)) {
-			struct sky2_port *sky2 = netdev_priv(dev);
+	struct sky2_port *sky2 = netdev_priv(dev);
 
-			spin_lock(&sky2->tx_lock);
-			sky2_tx_complete(sky2, last);
-			spin_unlock(&sky2->tx_lock);
-		}
+	if (netif_running(dev)) {
+		spin_lock(&sky2->tx_lock);
+		sky2_tx_complete(sky2, last);
+		spin_unlock(&sky2->tx_lock);
 	}
 }
 
-/*
- * Both ports share the same status interrupt, therefore there is only
- * one poll routine.
- */
-static int sky2_poll(struct net_device *dev0, int *budget)
+/* Is status ring empty or is there more to do? */
+static inline int sky2_more_work(const struct sky2_hw *hw)
 {
-	struct sky2_hw *hw = ((struct sky2_port *) netdev_priv(dev0))->hw;
-	unsigned int to_do = min(dev0->quota, *budget);
-	unsigned int work_done = 0;
-	u16 hwidx;
-	u16 tx_done[2] = { TX_NO_STATUS, TX_NO_STATUS };
-
-	sky2_write32(hw, STAT_CTRL, SC_STAT_CLR_IRQ);
+	return (hw->st_idx != sky2_read16(hw, STAT_PUT_IDX));
+}
 
-	/*
-	 * Kick the STAT_LEV_TIMER_CTRL timer.
-	 * This fixes my hangs on Yukon-EC (0xb6) rev 1.
-	 * The if clause is there to start the timer only if it has been
-	 * configured correctly and not been disabled via ethtool.
-	 */
-	if (sky2_read8(hw, STAT_LEV_TIMER_CTRL) == TIM_START) {
-		sky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_STOP);
-		sky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_START);
-	}
+/* Process status response ring */
+static int sky2_status_intr(struct sky2_hw *hw, int to_do)
+{
+	int work_done = 0;
+	u16 hwidx = sky2_read16(hw, STAT_PUT_IDX);
 
-	hwidx = sky2_read16(hw, STAT_PUT_IDX);
-	BUG_ON(hwidx >= STATUS_RING_SIZE);
 	rmb();
 
-	while (hwidx != hw->st_idx) {
+	while (hw->st_idx != hwidx) {
 		struct sky2_status_le *le  = hw->st_le + hw->st_idx;
 		struct net_device *dev;
 		struct sky2_port *sky2;
@@ -1977,18 +1987,14 @@ static int sky2_poll(struct net_device *dev0, int *budget)
 		u32 status;
 		u16 length;
 
-		le = hw->st_le + hw->st_idx;
-		hw->st_idx = (hw->st_idx + 1) % STATUS_RING_SIZE;
-		prefetch(hw->st_le + hw->st_idx);
+		hw->st_idx = RING_NEXT(hw->st_idx, STATUS_RING_SIZE);
 
 		BUG_ON(le->link >= 2);
 		dev = hw->dev[le->link];
-		if (dev == NULL || !netif_running(dev))
-			continue;
 
 		sky2 = netdev_priv(dev);
-		status = le32_to_cpu(le->status);
-		length = le16_to_cpu(le->length);
+		length = le->length;
+		status = le->status;
 
 		switch (le->opcode & ~HW_OWNER) {
 		case OP_RXSTAT:
@@ -2030,42 +2036,24 @@ static int sky2_poll(struct net_device *dev0, int *budget)
 
 		case OP_TXINDEXLE:
 			/* TX index reports status for both ports */
-			tx_done[0] = status & 0xffff;
-			tx_done[1] = ((status >> 24) & 0xff)
-				| (u16)(length & 0xf) << 8;
+			BUILD_BUG_ON(TX_RING_SIZE > 0x1000);
+			sky2_tx_done(hw->dev[0], status & 0xfff);
+			if (hw->dev[1])
+				sky2_tx_done(hw->dev[1],
+				     ((status >> 24) & 0xff)
+					     | (u16)(length & 0xf) << 8);
 			break;
 
 		default:
 			if (net_ratelimit())
 				printk(KERN_WARNING PFX
 				       "unknown status opcode 0x%x\n", le->opcode);
-			break;
+			goto exit_loop;
 		}
 	}
 
 exit_loop:
-	sky2_tx_check(hw, 0, tx_done[0]);
-	sky2_tx_check(hw, 1, tx_done[1]);
-
-	if (sky2_read8(hw, STAT_TX_TIMER_CTRL) == TIM_START) {
-		sky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_STOP);
-		sky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_START);
-	}
-
-	if (likely(work_done < to_do)) {
-		spin_lock_irq(&hw->hw_lock);
-		__netif_rx_complete(dev0);
-
-		hw->intr_mask |= Y2_IS_STAT_BMU;
-		sky2_write32(hw, B0_IMSK, hw->intr_mask);
-		spin_unlock_irq(&hw->hw_lock);
-
-		return 0;
-	} else {
-		*budget -= work_done;
-		dev0->quota -= work_done;
-		return 1;
-	}
+	return work_done;
 }
 
 static void sky2_hw_error(struct sky2_hw *hw, unsigned port, u32 status)
@@ -2184,41 +2172,52 @@ static void sky2_mac_intr(struct sky2_hw *hw, unsigned port)
 	}
 }
 
-static void sky2_phy_intr(struct sky2_hw *hw, unsigned port)
+/* This should never happen it is a fatal situation */
+static void sky2_descriptor_error(struct sky2_hw *hw, unsigned port,
+				  const char *rxtx, u32 mask)
 {
 	struct net_device *dev = hw->dev[port];
 	struct sky2_port *sky2 = netdev_priv(dev);
+	u32 imask;
 
-	hw->intr_mask &= ~(port == 0 ? Y2_IS_IRQ_PHY1 : Y2_IS_IRQ_PHY2);
-	sky2_write32(hw, B0_IMSK, hw->intr_mask);
+	printk(KERN_ERR PFX "%s: %s descriptor error (hardware problem)\n",
+	       dev ? dev->name : "<not registered>", rxtx);
 
-	schedule_work(&sky2->phy_task);
+	imask = sky2_read32(hw, B0_IMSK);
+	imask &= ~mask;
+	sky2_write32(hw, B0_IMSK, imask);
+
+	if (dev) {
+		spin_lock(&sky2->phy_lock);
+		sky2_link_down(sky2);
+		spin_unlock(&sky2->phy_lock);
+	}
 }
 
-static irqreturn_t sky2_intr(int irq, void *dev_id, struct pt_regs *regs)
+/* If idle then force a fake soft NAPI poll once a second
+ * to work around cases where sharing an edge triggered interrupt.
+ */
+static void sky2_idle(unsigned long arg)
 {
-	struct sky2_hw *hw = dev_id;
-	struct net_device *dev0 = hw->dev[0];
-	u32 status;
+	struct sky2_hw *hw = (struct sky2_hw *) arg;
+	struct net_device *dev = hw->dev[0];
 
-	status = sky2_read32(hw, B0_Y2_SP_ISRC2);
-	if (status == 0 || status == ~0)
-		return IRQ_NONE;
+	if (__netif_rx_schedule_prep(dev))
+		__netif_rx_schedule(dev);
 
-	spin_lock(&hw->hw_lock);
-	if (status & Y2_IS_HW_ERR)
-		sky2_hw_intr(hw);
+	mod_timer(&hw->idle_timer, jiffies + msecs_to_jiffies(idle_timeout));
+}
 
-	/* Do NAPI for Rx and Tx status */
-	if (status & Y2_IS_STAT_BMU) {
-		hw->intr_mask &= ~Y2_IS_STAT_BMU;
-		sky2_write32(hw, B0_IMSK, hw->intr_mask);
 
-		if (likely(__netif_rx_schedule_prep(dev0))) {
-			prefetch(&hw->st_le[hw->st_idx]);
-			__netif_rx_schedule(dev0);
-		}
-	}
+static int sky2_poll(struct net_device *dev0, int *budget)
+{
+	struct sky2_hw *hw = ((struct sky2_port *) netdev_priv(dev0))->hw;
+	int work_limit = min(dev0->quota, *budget);
+	int work_done = 0;
+	u32 status = sky2_read32(hw, B0_Y2_SP_EISR);
+
+	if (status & Y2_IS_HW_ERR)
+		sky2_hw_intr(hw);
 
 	if (status & Y2_IS_IRQ_PHY1)
 		sky2_phy_intr(hw, 0);
@@ -2232,9 +2231,48 @@ static irqreturn_t sky2_intr(int irq, void *dev_id, struct pt_regs *regs)
 	if (status & Y2_IS_IRQ_MAC2)
 		sky2_mac_intr(hw, 1);
 
-	sky2_write32(hw, B0_Y2_SP_ICR, 2);
+	if (status & Y2_IS_CHK_RX1)
+		sky2_descriptor_error(hw, 0, "receive", Y2_IS_CHK_RX1);
+
+	if (status & Y2_IS_CHK_RX2)
+		sky2_descriptor_error(hw, 1, "receive", Y2_IS_CHK_RX2);
+
+	if (status & Y2_IS_CHK_TXA1)
+		sky2_descriptor_error(hw, 0, "transmit", Y2_IS_CHK_TXA1);
+
+	if (status & Y2_IS_CHK_TXA2)
+		sky2_descriptor_error(hw, 1, "transmit", Y2_IS_CHK_TXA2);
+
+	work_done = sky2_status_intr(hw, work_limit);
+	*budget -= work_done;
+	dev0->quota -= work_done;
+
+	if (status & Y2_IS_STAT_BMU)
+		sky2_write32(hw, STAT_CTRL, SC_STAT_CLR_IRQ);
+
+	if (sky2_more_work(hw))
+		return 1;
+
+	netif_rx_complete(dev0);
+
+	sky2_read32(hw, B0_Y2_SP_LISR);
+	return 0;
+}
+
+static irqreturn_t sky2_intr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct sky2_hw *hw = dev_id;
+	struct net_device *dev0 = hw->dev[0];
+	u32 status;
+
+	/* Reading this mask interrupts as side effect */
+	status = sky2_read32(hw, B0_Y2_SP_ISRC2);
+	if (status == 0 || status == ~0)
+		return IRQ_NONE;
 
-	spin_unlock(&hw->hw_lock);
+	prefetch(&hw->st_le[hw->st_idx]);
+	if (likely(__netif_rx_schedule_prep(dev0)))
+		__netif_rx_schedule(dev0);
 
 	return IRQ_HANDLED;
 }
@@ -2273,7 +2311,7 @@ static inline u32 sky2_clk2us(const struct sky2_hw *hw, u32 clk)
 }
 
 
-static int sky2_reset(struct sky2_hw *hw)
+static int __devinit sky2_reset(struct sky2_hw *hw)
 {
 	u16 status;
 	u8 t8;
@@ -2292,6 +2330,16 @@ static int sky2_reset(struct sky2_hw *hw)
 	if (hw->chip_id == CHIP_ID_YUKON_EC_U)
 		sky2_pci_write32(hw, PCI_DEV_REG3, 0);
 
+	hw->chip_rev = (sky2_read8(hw, B2_MAC_CFG) & CFG_CHIP_R_MSK) >> 4;
+
+	/* This rev is really old, and requires untested workarounds */
+	if (hw->chip_id == CHIP_ID_YUKON_EC && hw->chip_rev == CHIP_REV_YU_EC_A1) {
+		printk(KERN_ERR PFX "%s: unsupported revision Yukon-%s (0x%x) rev %d\n",
+		       pci_name(hw->pdev), yukon2_name[hw->chip_id - CHIP_ID_YUKON_XL],
+		       hw->chip_id, hw->chip_rev);
+		return -EOPNOTSUPP;
+	}
+
 	/* disable ASF */
 	if (hw->chip_id <= CHIP_ID_YUKON_EC) {
 		sky2_write8(hw, B28_Y2_ASF_STAT_CMD, Y2_ASF_RESET);
@@ -2312,7 +2360,7 @@ static int sky2_reset(struct sky2_hw *hw)
 	sky2_write8(hw, B0_CTST, CS_MRST_CLR);
 
 	/* clear any PEX errors */
-	if (pci_find_capability(hw->pdev, PCI_CAP_ID_EXP)) 
+	if (pci_find_capability(hw->pdev, PCI_CAP_ID_EXP))
 		sky2_pci_write32(hw, PEX_UNC_ERR_STAT, 0xffffffffUL);
 
 
@@ -2323,7 +2371,6 @@ static int sky2_reset(struct sky2_hw *hw)
 		if (!(sky2_read8(hw, B2_Y2_CLK_GATE) & Y2_STATUS_LNK2_INAC))
 			++hw->ports;
 	}
-	hw->chip_rev = (sky2_read8(hw, B2_MAC_CFG) & CFG_CHIP_R_MSK) >> 4;
 
 	sky2_set_power_state(hw, PCI_D0);
 
@@ -2389,30 +2436,18 @@ static int sky2_reset(struct sky2_hw *hw)
 	/* Set the list last index */
 	sky2_write16(hw, STAT_LAST_IDX, STATUS_RING_SIZE - 1);
 
-	/* These status setup values are copied from SysKonnect's driver */
-	if (is_ec_a1(hw)) {
-		/* WA for dev. #4.3 */
-		sky2_write16(hw, STAT_TX_IDX_TH, 0xfff);	/* Tx Threshold */
-
-		/* set Status-FIFO watermark */
-		sky2_write8(hw, STAT_FIFO_WM, 0x21);	/* WA for dev. #4.18 */
-
-		/* set Status-FIFO ISR watermark */
-		sky2_write8(hw, STAT_FIFO_ISR_WM, 0x07);	/* WA for dev. #4.18 */
-		sky2_write32(hw, STAT_TX_TIMER_INI, sky2_us2clk(hw, 10000));
-	} else {
-		sky2_write16(hw, STAT_TX_IDX_TH, 10);
-		sky2_write8(hw, STAT_FIFO_WM, 16);
+	sky2_write16(hw, STAT_TX_IDX_TH, 10);
+	sky2_write8(hw, STAT_FIFO_WM, 16);
 
-		/* set Status-FIFO ISR watermark */
-		if (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev == 0)
-			sky2_write8(hw, STAT_FIFO_ISR_WM, 4);
-		else
-			sky2_write8(hw, STAT_FIFO_ISR_WM, 16);
+	/* set Status-FIFO ISR watermark */
+	if (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev == 0)
+		sky2_write8(hw, STAT_FIFO_ISR_WM, 4);
+	else
+		sky2_write8(hw, STAT_FIFO_ISR_WM, 16);
 
-		sky2_write32(hw, STAT_TX_TIMER_INI, sky2_us2clk(hw, 1000));
-		sky2_write32(hw, STAT_ISR_TIMER_INI, sky2_us2clk(hw, 7));
-	}
+	sky2_write32(hw, STAT_TX_TIMER_INI, sky2_us2clk(hw, 1000));
+	sky2_write32(hw, STAT_ISR_TIMER_INI, sky2_us2clk(hw, 20));
+	sky2_write32(hw, STAT_LEV_TIMER_INI, sky2_us2clk(hw, 100));
 
 	/* enable status unit */
 	sky2_write32(hw, STAT_CTRL, SC_STAT_OP_ON);
@@ -2686,7 +2721,7 @@ static struct net_device_stats *sky2_get_stats(struct net_device *dev)
 	sky2->net_stats.rx_bytes = data[1];
 	sky2->net_stats.tx_packets = data[2] + data[4] + data[6];
 	sky2->net_stats.rx_packets = data[3] + data[5] + data[7];
-	sky2->net_stats.multicast = data[5] + data[7];
+	sky2->net_stats.multicast = data[3] + data[5];
 	sky2->net_stats.collisions = data[10];
 	sky2->net_stats.tx_aborted_errors = data[12];
 
@@ -2825,7 +2860,7 @@ static int sky2_phys_id(struct net_device *dev, u32 data)
 		ms = data * 1000;
 
 	/* save initial values */
-	down(&sky2->phy_sema);
+	spin_lock_bh(&sky2->phy_lock);
 	if (hw->chip_id == CHIP_ID_YUKON_XL) {
 		u16 pg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);
 		gm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);
@@ -2841,9 +2876,9 @@ static int sky2_phys_id(struct net_device *dev, u32 data)
 		sky2_led(hw, port, onoff);
 		onoff = !onoff;
 
-		up(&sky2->phy_sema);
+		spin_unlock_bh(&sky2->phy_lock);
 		interrupted = msleep_interruptible(250);
-		down(&sky2->phy_sema);
+		spin_lock_bh(&sky2->phy_lock);
 
 		ms -= 250;
 	}
@@ -2858,7 +2893,7 @@ static int sky2_phys_id(struct net_device *dev, u32 data)
 		gm_phy_write(hw, port, PHY_MARV_LED_CTRL, ledctrl);
 		gm_phy_write(hw, port, PHY_MARV_LED_OVER, ledover);
 	}
-	up(&sky2->phy_sema);
+	spin_unlock_bh(&sky2->phy_lock);
 
 	return 0;
 }
@@ -2888,38 +2923,6 @@ static int sky2_set_pauseparam(struct net_device *dev,
 	return err;
 }
 
-#ifdef CONFIG_PM
-static void sky2_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
-{
-	struct sky2_port *sky2 = netdev_priv(dev);
-
-	wol->supported = WAKE_MAGIC;
-	wol->wolopts = sky2->wol ? WAKE_MAGIC : 0;
-}
-
-static int sky2_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
-{
-	struct sky2_port *sky2 = netdev_priv(dev);
-	struct sky2_hw *hw = sky2->hw;
-
-	if (wol->wolopts != WAKE_MAGIC && wol->wolopts != 0)
-		return -EOPNOTSUPP;
-
-	sky2->wol = wol->wolopts == WAKE_MAGIC;
-
-	if (sky2->wol) {
-		memcpy_toio(hw->regs + WOL_MAC_ADDR, dev->dev_addr, ETH_ALEN);
-
-		sky2_write16(hw, WOL_CTRL_STAT,
-			     WOL_CTL_ENA_PME_ON_MAGIC_PKT |
-			     WOL_CTL_ENA_MAGIC_PKT_UNIT);
-	} else
-		sky2_write16(hw, WOL_CTRL_STAT, WOL_CTL_DEFAULT);
-
-	return 0;
-}
-#endif
-
 static int sky2_get_coalesce(struct net_device *dev,
 			     struct ethtool_coalesce *ecmd)
 {
@@ -2960,19 +2963,11 @@ static int sky2_set_coalesce(struct net_device *dev,
 {
 	struct sky2_port *sky2 = netdev_priv(dev);
 	struct sky2_hw *hw = sky2->hw;
-	const u32 tmin = sky2_clk2us(hw, 1);
-	const u32 tmax = 5000;
+	const u32 tmax = sky2_clk2us(hw, 0x0ffffff);
 
-	if (ecmd->tx_coalesce_usecs != 0 &&
-	    (ecmd->tx_coalesce_usecs < tmin || ecmd->tx_coalesce_usecs > tmax))
-		return -EINVAL;
-
-	if (ecmd->rx_coalesce_usecs != 0 &&
-	    (ecmd->rx_coalesce_usecs < tmin || ecmd->rx_coalesce_usecs > tmax))
-		return -EINVAL;
-
-	if (ecmd->rx_coalesce_usecs_irq != 0 &&
-	    (ecmd->rx_coalesce_usecs_irq < tmin || ecmd->rx_coalesce_usecs_irq > tmax))
+	if (ecmd->tx_coalesce_usecs > tmax ||
+	    ecmd->rx_coalesce_usecs > tmax ||
+	    ecmd->rx_coalesce_usecs_irq > tmax)
 		return -EINVAL;
 
 	if (ecmd->tx_max_coalesced_frames >= TX_RING_SIZE-1)
@@ -3107,10 +3102,6 @@ static struct ethtool_ops sky2_ethtool_ops = {
 	.set_ringparam = sky2_set_ringparam,
 	.get_pauseparam = sky2_get_pauseparam,
 	.set_pauseparam = sky2_set_pauseparam,
-#ifdef CONFIG_PM
-	.get_wol = sky2_get_wol,
-	.set_wol = sky2_set_wol,
-#endif
 	.phys_id = sky2_phys_id,
 	.get_stats_count = sky2_get_stats_count,
 	.get_ethtool_stats = sky2_get_ethtool_stats,
@@ -3163,17 +3154,11 @@ static __devinit struct net_device *sky2_init_netdev(struct sky2_hw *hw,
 	sky2->duplex = -1;
 	sky2->speed = -1;
 	sky2->advertising = sky2_supported_modes(hw);
+	sky2->rx_csum = 1;
 
- 	/* Receive checksum disabled for Yukon XL
-	 * because of observed problems with incorrect
-	 * values when multiple packets are received in one interrupt
-	 */
-	sky2->rx_csum = (hw->chip_id != CHIP_ID_YUKON_XL);
-
-	INIT_WORK(&sky2->phy_task, sky2_phy_task, sky2);
-	init_MUTEX(&sky2->phy_sema);
+	spin_lock_init(&sky2->phy_lock);
 	sky2->tx_pending = TX_DEF_PENDING;
-	sky2->rx_pending = is_ec_a1(hw) ? 8 : RX_DEF_PENDING;
+	sky2->rx_pending = RX_DEF_PENDING;
 	sky2->rx_bufsize = sky2_buf_size(ETH_DATA_LEN);
 
 	hw->dev[port] = dev;
@@ -3215,6 +3200,66 @@ static void __devinit sky2_show_addr(struct net_device *dev)
 		       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
 }
 
+/* Handle software interrupt used during MSI test */
+static irqreturn_t __devinit sky2_test_intr(int irq, void *dev_id,
+					    struct pt_regs *regs)
+{
+	struct sky2_hw *hw = dev_id;
+	u32 status = sky2_read32(hw, B0_Y2_SP_ISRC2);
+
+	if (status == 0)
+		return IRQ_NONE;
+
+	if (status & Y2_IS_IRQ_SW) {
+		hw->msi_detected = 1;
+		wake_up(&hw->msi_wait);
+		sky2_write8(hw, B0_CTST, CS_CL_SW_IRQ);
+	}
+	sky2_write32(hw, B0_Y2_SP_ICR, 2);
+
+	return IRQ_HANDLED;
+}
+
+/* Test interrupt path by forcing a a software IRQ */
+static int __devinit sky2_test_msi(struct sky2_hw *hw)
+{
+	struct pci_dev *pdev = hw->pdev;
+	int err;
+
+	sky2_write32(hw, B0_IMSK, Y2_IS_IRQ_SW);
+
+	err = request_irq(pdev->irq, sky2_test_intr, SA_SHIRQ, DRV_NAME, hw);
+	if (err) {
+		printk(KERN_ERR PFX "%s: cannot assign irq %d\n",
+		       pci_name(pdev), pdev->irq);
+		return err;
+	}
+
+	init_waitqueue_head (&hw->msi_wait);
+
+	sky2_write8(hw, B0_CTST, CS_ST_SW_IRQ);
+	wmb();
+
+	wait_event_timeout(hw->msi_wait, hw->msi_detected, HZ/10);
+
+	if (!hw->msi_detected) {
+		/* MSI test failed, go back to INTx mode */
+		printk(KERN_WARNING PFX "%s: No interrupt was generated using MSI, "
+		       "switching to INTx mode. Please report this failure to "
+		       "the PCI maintainer and include system chipset information.\n",
+		       pci_name(pdev));
+
+		err = -EOPNOTSUPP;
+		sky2_write8(hw, B0_CTST, CS_CL_SW_IRQ);
+	}
+
+	sky2_write32(hw, B0_IMSK, 0);
+
+	free_irq(pdev->irq, hw);
+
+	return err;
+}
+
 static int __devinit sky2_probe(struct pci_dev *pdev,
 				const struct pci_device_id *ent)
 {
@@ -3283,7 +3328,6 @@ static int __devinit sky2_probe(struct pci_dev *pdev,
 		goto err_out_free_hw;
 	}
 	hw->pm_cap = pm_cap;
-	spin_lock_init(&hw->hw_lock);
 
 #ifdef __BIG_ENDIAN
 	/* The sk98lin vendor driver uses hardware byte swapping but
@@ -3337,21 +3381,34 @@ static int __devinit sky2_probe(struct pci_dev *pdev,
 		}
 	}
 
-	err = request_irq(pdev->irq, sky2_intr, SA_SHIRQ, DRV_NAME, hw);
+	if (!disable_msi && pci_enable_msi(pdev) == 0) {
+		err = sky2_test_msi(hw);
+		if (err == -EOPNOTSUPP)
+ 			pci_disable_msi(pdev);
+		else if (err)
+			goto err_out_unregister;
+ 	}
+
+	err = request_irq(pdev->irq,  sky2_intr, SA_SHIRQ, DRV_NAME, hw);
 	if (err) {
 		printk(KERN_ERR PFX "%s: cannot assign irq %d\n",
 		       pci_name(pdev), pdev->irq);
 		goto err_out_unregister;
 	}
 
-	hw->intr_mask = Y2_IS_BASE;
-	sky2_write32(hw, B0_IMSK, hw->intr_mask);
+	sky2_write32(hw, B0_IMSK, Y2_IS_BASE);
+
+	setup_timer(&hw->idle_timer, sky2_idle, (unsigned long) hw);
+	if (idle_timeout > 0)
+		mod_timer(&hw->idle_timer,
+			  jiffies + msecs_to_jiffies(idle_timeout));
 
 	pci_set_drvdata(pdev, hw);
 
 	return 0;
 
 err_out_unregister:
+	pci_disable_msi(pdev);
 	if (dev1) {
 		unregister_netdev(dev1);
 		free_netdev(dev1);
@@ -3381,19 +3438,24 @@ static void __devexit sky2_remove(struct pci_dev *pdev)
 	if (!hw)
 		return;
 
+	del_timer_sync(&hw->idle_timer);
+
+	sky2_write32(hw, B0_IMSK, 0);
+	synchronize_irq(hw->pdev->irq);
+
 	dev0 = hw->dev[0];
 	dev1 = hw->dev[1];
 	if (dev1)
 		unregister_netdev(dev1);
 	unregister_netdev(dev0);
 
-	sky2_write32(hw, B0_IMSK, 0);
 	sky2_set_power_state(hw, PCI_D3hot);
 	sky2_write16(hw, B0_Y2LED, LED_STAT_OFF);
 	sky2_write8(hw, B0_CTST, CS_RST_SET);
 	sky2_read8(hw, B0_CTST);
 
 	free_irq(pdev->irq, hw);
+	pci_disable_msi(pdev);
 	pci_free_consistent(pdev, STATUS_LE_BYTES, hw->st_le, hw->st_dma);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
diff --git a/drivers/net/sky2.h b/drivers/net/sky2.h
index b5163ab878..9516c1f392 100644
--- a/drivers/net/sky2.h
+++ b/drivers/net/sky2.h
@@ -214,6 +214,8 @@ enum csr_regs {
 enum {
 	Y2_VMAIN_AVAIL	= 1<<17,/* VMAIN available (YUKON-2 only) */
 	Y2_VAUX_AVAIL	= 1<<16,/* VAUX available (YUKON-2 only) */
+	Y2_HW_WOL_ON	= 1<<15,/* HW WOL On  (Yukon-EC Ultra A1 only) */
+	Y2_HW_WOL_OFF	= 1<<14,/* HW WOL On  (Yukon-EC Ultra A1 only) */
 	Y2_ASF_ENABLE	= 1<<13,/* ASF Unit Enable (YUKON-2 only) */
 	Y2_ASF_DISABLE	= 1<<12,/* ASF Unit Disable (YUKON-2 only) */
 	Y2_CLK_RUN_ENA	= 1<<11,/* CLK_RUN Enable  (YUKON-2 only) */
@@ -278,13 +280,11 @@ enum {
 	Y2_IS_CHK_TXS1	= 1<<1,		/* Descriptor error TXS 1 */
 	Y2_IS_CHK_TXA1	= 1<<0,		/* Descriptor error TXA 1 */
 
-	Y2_IS_BASE	= Y2_IS_HW_ERR | Y2_IS_STAT_BMU |
-			  Y2_IS_POLL_CHK | Y2_IS_TWSI_RDY |
-			  Y2_IS_IRQ_SW | Y2_IS_TIMINT,
-	Y2_IS_PORT_1	= Y2_IS_IRQ_PHY1 | Y2_IS_IRQ_MAC1 |
-			  Y2_IS_CHK_RX1 | Y2_IS_CHK_TXA1 | Y2_IS_CHK_TXS1,
-	Y2_IS_PORT_2	= Y2_IS_IRQ_PHY2 | Y2_IS_IRQ_MAC2 |
-			  Y2_IS_CHK_RX2 | Y2_IS_CHK_TXA2 | Y2_IS_CHK_TXS2,
+	Y2_IS_BASE	= Y2_IS_HW_ERR | Y2_IS_STAT_BMU,
+	Y2_IS_PORT_1	= Y2_IS_IRQ_PHY1 | Y2_IS_IRQ_MAC1
+		          | Y2_IS_CHK_TXA1 | Y2_IS_CHK_RX1,
+	Y2_IS_PORT_2	= Y2_IS_IRQ_PHY2 | Y2_IS_IRQ_MAC2
+			  | Y2_IS_CHK_TXA2 | Y2_IS_CHK_RX2,
 };
 
 /*	B2_IRQM_HWE_MSK	32 bit	IRQ Moderation HW Error Mask */
@@ -380,6 +380,9 @@ enum {
 	CHIP_REV_YU_EC_A1    = 0,  /* Chip Rev. for Yukon-EC A1/A0 */
 	CHIP_REV_YU_EC_A2    = 1,  /* Chip Rev. for Yukon-EC A2 */
 	CHIP_REV_YU_EC_A3    = 2,  /* Chip Rev. for Yukon-EC A3 */
+
+	CHIP_REV_YU_EC_U_A0  = 0,
+	CHIP_REV_YU_EC_U_A1  = 1,
 };
 
 /*	B2_Y2_CLK_GATE	 8 bit	Clock Gating (Yukon-2 only) */
@@ -1383,24 +1386,23 @@ enum {
 	GM_SMI_CTRL	= 0x0080,	/* 16 bit r/w	SMI Control Register */
 	GM_SMI_DATA	= 0x0084,	/* 16 bit r/w	SMI Data Register */
 	GM_PHY_ADDR	= 0x0088,	/* 16 bit r/w	GPHY Address Register */
+/* MIB Counters */
+	GM_MIB_CNT_BASE	= 0x0100,	/* Base Address of MIB Counters */
+	GM_MIB_CNT_END	= 0x025C,	/* Last MIB counter */
 };
 
-/* MIB Counters */
-#define GM_MIB_CNT_BASE	0x0100		/* Base Address of MIB Counters */
-#define GM_MIB_CNT_SIZE	44		/* Number of MIB Counters */
-#define GM_MIB_CNT_END	0x025C		/* Last MIB counter */
 
 /*
  * MIB Counters base address definitions (low word) -
  * use offset 4 for access to high word	(32 bit r/o)
  */
 enum {
-	GM_RXF_UC_OK  = GM_MIB_CNT_BASE + 0,	/* Unicast Frames Received OK */
+	GM_RXF_UC_OK    = GM_MIB_CNT_BASE + 0,	/* Unicast Frames Received OK */
 	GM_RXF_BC_OK	= GM_MIB_CNT_BASE + 8,	/* Broadcast Frames Received OK */
 	GM_RXF_MPAUSE	= GM_MIB_CNT_BASE + 16,	/* Pause MAC Ctrl Frames Received */
 	GM_RXF_MC_OK	= GM_MIB_CNT_BASE + 24,	/* Multicast Frames Received OK */
 	GM_RXF_FCS_ERR	= GM_MIB_CNT_BASE + 32,	/* Rx Frame Check Seq. Error */
-	/* GM_MIB_CNT_BASE + 40:	reserved */
+
 	GM_RXO_OK_LO	= GM_MIB_CNT_BASE + 48,	/* Octets Received OK Low */
 	GM_RXO_OK_HI	= GM_MIB_CNT_BASE + 56,	/* Octets Received OK High */
 	GM_RXO_ERR_LO	= GM_MIB_CNT_BASE + 64,	/* Octets Received Invalid Low */
@@ -1408,37 +1410,36 @@ enum {
 	GM_RXF_SHT	= GM_MIB_CNT_BASE + 80,	/* Frames <64 Byte Received OK */
 	GM_RXE_FRAG	= GM_MIB_CNT_BASE + 88,	/* Frames <64 Byte Received with FCS Err */
 	GM_RXF_64B	= GM_MIB_CNT_BASE + 96,	/* 64 Byte Rx Frame */
-	GM_RXF_127B	= GM_MIB_CNT_BASE + 104,	/* 65-127 Byte Rx Frame */
-	GM_RXF_255B	= GM_MIB_CNT_BASE + 112,	/* 128-255 Byte Rx Frame */
-	GM_RXF_511B	= GM_MIB_CNT_BASE + 120,	/* 256-511 Byte Rx Frame */
-	GM_RXF_1023B	= GM_MIB_CNT_BASE + 128,	/* 512-1023 Byte Rx Frame */
-	GM_RXF_1518B	= GM_MIB_CNT_BASE + 136,	/* 1024-1518 Byte Rx Frame */
-	GM_RXF_MAX_SZ	= GM_MIB_CNT_BASE + 144,	/* 1519-MaxSize Byte Rx Frame */
-	GM_RXF_LNG_ERR	= GM_MIB_CNT_BASE + 152,	/* Rx Frame too Long Error */
-	GM_RXF_JAB_PKT	= GM_MIB_CNT_BASE + 160,	/* Rx Jabber Packet Frame */
-	/* GM_MIB_CNT_BASE + 168:	reserved */
-	GM_RXE_FIFO_OV	= GM_MIB_CNT_BASE + 176,	/* Rx FIFO overflow Event */
-	/* GM_MIB_CNT_BASE + 184:	reserved */
-	GM_TXF_UC_OK	= GM_MIB_CNT_BASE + 192,	/* Unicast Frames Xmitted OK */
-	GM_TXF_BC_OK	= GM_MIB_CNT_BASE + 200,	/* Broadcast Frames Xmitted OK */
-	GM_TXF_MPAUSE	= GM_MIB_CNT_BASE + 208,	/* Pause MAC Ctrl Frames Xmitted */
-	GM_TXF_MC_OK	= GM_MIB_CNT_BASE + 216,	/* Multicast Frames Xmitted OK */
-	GM_TXO_OK_LO	= GM_MIB_CNT_BASE + 224,	/* Octets Transmitted OK Low */
-	GM_TXO_OK_HI	= GM_MIB_CNT_BASE + 232,	/* Octets Transmitted OK High */
-	GM_TXF_64B	= GM_MIB_CNT_BASE + 240,	/* 64 Byte Tx Frame */
-	GM_TXF_127B	= GM_MIB_CNT_BASE + 248,	/* 65-127 Byte Tx Frame */
-	GM_TXF_255B	= GM_MIB_CNT_BASE + 256,	/* 128-255 Byte Tx Frame */
-	GM_TXF_511B	= GM_MIB_CNT_BASE + 264,	/* 256-511 Byte Tx Frame */
-	GM_TXF_1023B	= GM_MIB_CNT_BASE + 272,	/* 512-1023 Byte Tx Frame */
-	GM_TXF_1518B	= GM_MIB_CNT_BASE + 280,	/* 1024-1518 Byte Tx Frame */
-	GM_TXF_MAX_SZ	= GM_MIB_CNT_BASE + 288,	/* 1519-MaxSize Byte Tx Frame */
-
-	GM_TXF_COL	= GM_MIB_CNT_BASE + 304,	/* Tx Collision */
-	GM_TXF_LAT_COL	= GM_MIB_CNT_BASE + 312,	/* Tx Late Collision */
-	GM_TXF_ABO_COL	= GM_MIB_CNT_BASE + 320,	/* Tx aborted due to Exces. Col. */
-	GM_TXF_MUL_COL	= GM_MIB_CNT_BASE + 328,	/* Tx Multiple Collision */
-	GM_TXF_SNG_COL	= GM_MIB_CNT_BASE + 336,	/* Tx Single Collision */
-	GM_TXE_FIFO_UR	= GM_MIB_CNT_BASE + 344,	/* Tx FIFO Underrun Event */
+	GM_RXF_127B	= GM_MIB_CNT_BASE + 104,/* 65-127 Byte Rx Frame */
+	GM_RXF_255B	= GM_MIB_CNT_BASE + 112,/* 128-255 Byte Rx Frame */
+	GM_RXF_511B	= GM_MIB_CNT_BASE + 120,/* 256-511 Byte Rx Frame */
+	GM_RXF_1023B	= GM_MIB_CNT_BASE + 128,/* 512-1023 Byte Rx Frame */
+	GM_RXF_1518B	= GM_MIB_CNT_BASE + 136,/* 1024-1518 Byte Rx Frame */
+	GM_RXF_MAX_SZ	= GM_MIB_CNT_BASE + 144,/* 1519-MaxSize Byte Rx Frame */
+	GM_RXF_LNG_ERR	= GM_MIB_CNT_BASE + 152,/* Rx Frame too Long Error */
+	GM_RXF_JAB_PKT	= GM_MIB_CNT_BASE + 160,/* Rx Jabber Packet Frame */
+
+	GM_RXE_FIFO_OV	= GM_MIB_CNT_BASE + 176,/* Rx FIFO overflow Event */
+	GM_TXF_UC_OK	= GM_MIB_CNT_BASE + 192,/* Unicast Frames Xmitted OK */
+	GM_TXF_BC_OK	= GM_MIB_CNT_BASE + 200,/* Broadcast Frames Xmitted OK */
+	GM_TXF_MPAUSE	= GM_MIB_CNT_BASE + 208,/* Pause MAC Ctrl Frames Xmitted */
+	GM_TXF_MC_OK	= GM_MIB_CNT_BASE + 216,/* Multicast Frames Xmitted OK */
+	GM_TXO_OK_LO	= GM_MIB_CNT_BASE + 224,/* Octets Transmitted OK Low */
+	GM_TXO_OK_HI	= GM_MIB_CNT_BASE + 232,/* Octets Transmitted OK High */
+	GM_TXF_64B	= GM_MIB_CNT_BASE + 240,/* 64 Byte Tx Frame */
+	GM_TXF_127B	= GM_MIB_CNT_BASE + 248,/* 65-127 Byte Tx Frame */
+	GM_TXF_255B	= GM_MIB_CNT_BASE + 256,/* 128-255 Byte Tx Frame */
+	GM_TXF_511B	= GM_MIB_CNT_BASE + 264,/* 256-511 Byte Tx Frame */
+	GM_TXF_1023B	= GM_MIB_CNT_BASE + 272,/* 512-1023 Byte Tx Frame */
+	GM_TXF_1518B	= GM_MIB_CNT_BASE + 280,/* 1024-1518 Byte Tx Frame */
+	GM_TXF_MAX_SZ	= GM_MIB_CNT_BASE + 288,/* 1519-MaxSize Byte Tx Frame */
+
+	GM_TXF_COL	= GM_MIB_CNT_BASE + 304,/* Tx Collision */
+	GM_TXF_LAT_COL	= GM_MIB_CNT_BASE + 312,/* Tx Late Collision */
+	GM_TXF_ABO_COL	= GM_MIB_CNT_BASE + 320,/* Tx aborted due to Exces. Col. */
+	GM_TXF_MUL_COL	= GM_MIB_CNT_BASE + 328,/* Tx Multiple Collision */
+	GM_TXF_SNG_COL	= GM_MIB_CNT_BASE + 336,/* Tx Single Collision */
+	GM_TXE_FIFO_UR	= GM_MIB_CNT_BASE + 344,/* Tx FIFO Underrun Event */
 };
 
 /* GMAC Bit Definitions */
@@ -1816,7 +1817,7 @@ struct sky2_rx_le {
 	__le16	length;
 	u8	ctrl;
 	u8	opcode;
-} __attribute((packed));;
+} __attribute((packed));
 
 struct sky2_status_le {
 	__le32	status;	/* also checksum */
@@ -1841,6 +1842,7 @@ struct sky2_port {
 	struct net_device    *netdev;
 	unsigned	     port;
 	u32		     msg_enable;
+	spinlock_t	     phy_lock;
 
 	spinlock_t	     tx_lock  ____cacheline_aligned_in_smp;
 	struct tx_ring_info  *tx_ring;
@@ -1849,7 +1851,6 @@ struct sky2_port {
 	u16		     tx_prod;		/* next le to use */
 	u32		     tx_addr64;
 	u16		     tx_pending;
-	u16		     tx_last_put;
 	u16		     tx_last_mss;
 
 	struct ring_info     *rx_ring ____cacheline_aligned_in_smp;
@@ -1858,7 +1859,6 @@ struct sky2_port {
 	u16		     rx_next;		/* next re to check */
 	u16		     rx_put;		/* next le index to use */
 	u16		     rx_pending;
-	u16		     rx_last_put;
 	u16		     rx_bufsize;
 #ifdef SKY2_VLAN_TAG_USED
 	u16		     rx_tag;
@@ -1874,20 +1874,15 @@ struct sky2_port {
 	u8		     rx_pause;
 	u8		     tx_pause;
 	u8		     rx_csum;
-	u8		     wol;
 
 	struct net_device_stats net_stats;
 
-	struct work_struct   phy_task;
-	struct semaphore     phy_sema;
 };
 
 struct sky2_hw {
 	void __iomem  	     *regs;
 	struct pci_dev	     *pdev;
 	struct net_device    *dev[2];
-	spinlock_t	     hw_lock;
-	u32		     intr_mask;
 
 	int		     pm_cap;
 	u8	     	     chip_id;
@@ -1898,6 +1893,10 @@ struct sky2_hw {
 	struct sky2_status_le *st_le;
 	u32		     st_idx;
 	dma_addr_t   	     st_dma;
+
+	struct timer_list    idle_timer;
+	int		     msi_detected;
+	wait_queue_head_t    msi_wait;
 };
 
 static inline int sky2_is_copper(const struct sky2_hw *hw)
diff --git a/drivers/net/sunhme.c b/drivers/net/sunhme.c
index 9f046cae2f..8ce5d42607 100644
--- a/drivers/net/sunhme.c
+++ b/drivers/net/sunhme.c
@@ -1996,6 +1996,7 @@ static void happy_meal_tx(struct happy_meal *hp)
 	}
 	hp->tx_old = elem;
 	TXD((">"));
+	udelay(1);
 
 	if (netif_queue_stopped(dev) &&
 	    TX_BUFFS_AVAIL(hp) > (MAX_SKB_FRAGS + 1))
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 8101657da4..42f66811d8 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -213,6 +213,19 @@ config IPW2200
           say M here and read <file:Documentation/modules.txt>.  The module
           will be called ipw2200.ko.
 
+config IPW2200_MONITOR
+        bool "Enable promiscuous mode"
+        depends on IPW2200
+        ---help---
+	  Enables promiscuous/monitor mode support for the ipw2200 driver.
+	  With this feature compiled into the driver, you can switch to 
+	  promiscuous mode via the Wireless Tool's Monitor mode.  While in this
+	  mode, no packets can be sent.
+
+config IPW_QOS
+        bool "Enable QoS support"
+        depends on IPW2200 && EXPERIMENTAL
+
 config IPW2200_DEBUG
 	bool "Enable full debugging output in IPW2200 module."
 	depends on IPW2200
diff --git a/drivers/sbus/char/bbc_i2c.c b/drivers/sbus/char/bbc_i2c.c
index 026e813d1b..e8d2d60382 100644
--- a/drivers/sbus/char/bbc_i2c.c
+++ b/drivers/sbus/char/bbc_i2c.c
@@ -441,7 +441,8 @@ static int __init bbc_i2c_init(void)
 	struct linux_ebus_device *edev = NULL;
 	int err, index = 0;
 
-	if (tlb_type != cheetah || !bbc_present())
+	if ((tlb_type != cheetah && tlb_type != cheetah_plus) ||
+	    !bbc_present())
 		return -ENODEV;
 
 	for_each_ebus(ebus) {
@@ -487,3 +488,4 @@ static void bbc_i2c_cleanup(void)
 
 module_init(bbc_i2c_init);
 module_exit(bbc_i2c_cleanup);
+MODULE_LICENSE("GPL");
diff --git a/drivers/scsi/libata-core.c b/drivers/scsi/libata-core.c
index 400e9d74ad..f1d85978ba 100644
--- a/drivers/scsi/libata-core.c
+++ b/drivers/scsi/libata-core.c
@@ -78,7 +78,7 @@ static void __ata_qc_complete(struct ata_queued_cmd *qc);
 static unsigned int ata_unique_id = 1;
 static struct workqueue_struct *ata_wq;
 
-int atapi_enabled = 0;
+int atapi_enabled = 1;
 module_param(atapi_enabled, int, 0444);
 MODULE_PARM_DESC(atapi_enabled, "Enable discovery of ATAPI devices (0=off, 1=on)");
 
@@ -4432,6 +4432,7 @@ static void ata_host_init(struct ata_port *ap, struct Scsi_Host *host,
 	ap->mwdma_mask = ent->mwdma_mask;
 	ap->udma_mask = ent->udma_mask;
 	ap->flags |= ent->host_flags;
+	ap->flags |= ent->port_flags[port_no];
 	ap->ops = ent->port_ops;
 	ap->cbl = ATA_CBL_NONE;
 	ap->active_tag = ATA_TAG_POISON;
diff --git a/drivers/scsi/sata_promise.c b/drivers/scsi/sata_promise.c
index 07172fc3b3..53f255b994 100644
--- a/drivers/scsi/sata_promise.c
+++ b/drivers/scsi/sata_promise.c
@@ -89,6 +89,7 @@ static irqreturn_t pdc_interrupt (int irq, void *dev_instance, struct pt_regs *r
 static void pdc_eng_timeout(struct ata_port *ap);
 static int pdc_port_start(struct ata_port *ap);
 static void pdc_port_stop(struct ata_port *ap);
+static void pdc_pata_cbl_detect(struct ata_port *ap);
 static void pdc_pata_phy_reset(struct ata_port *ap);
 static void pdc_sata_phy_reset(struct ata_port *ap);
 static void pdc_qc_prep(struct ata_queued_cmd *qc);
@@ -165,7 +166,7 @@ static const struct ata_port_info pdc_port_info[] = {
 	/* board_2037x */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SATA,
+		.host_flags	= PDC_COMMON_FLAGS /* | ATA_FLAG_SATA */,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
@@ -325,17 +326,34 @@ static void pdc_reset_port(struct ata_port *ap)
 static void pdc_sata_phy_reset(struct ata_port *ap)
 {
 	pdc_reset_port(ap);
-	sata_phy_reset(ap);
+	if (ap->flags & ATA_FLAG_SATA)
+		sata_phy_reset(ap);
+	else
+		pdc_pata_phy_reset(ap);
+}
+
+static void pdc_pata_cbl_detect(struct ata_port *ap)
+{
+	u8 tmp;
+	void *mmio = (void *) ap->ioaddr.cmd_addr + PDC_CTLSTAT + 0x03;
+
+	tmp = readb(mmio);
+
+	if (tmp & 0x01)
+	{
+		ap->cbl = ATA_CBL_PATA40;
+		ap->udma_mask &= ATA_UDMA_MASK_40C;
+	}
+	else
+		ap->cbl = ATA_CBL_PATA80;
 }
 
 static void pdc_pata_phy_reset(struct ata_port *ap)
 {
-	/* FIXME: add cable detect.  Don't assume 40-pin cable */
-	ap->cbl = ATA_CBL_PATA40;
-	ap->udma_mask &= ATA_UDMA_MASK_40C;
+	pdc_pata_cbl_detect(ap);
 
-	pdc_reset_port(ap);
 	ata_port_probe(ap);
+
 	ata_bus_reset(ap);
 }
 
@@ -648,6 +666,7 @@ static int pdc_ata_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	unsigned int board_idx = (unsigned int) ent->driver_data;
 	int pci_dev_busy = 0;
 	int rc;
+	u8 tmp;
 
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
@@ -707,6 +726,9 @@ static int pdc_ata_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	probe_ent->port[0].scr_addr = base + 0x400;
 	probe_ent->port[1].scr_addr = base + 0x500;
 
+	probe_ent->port_flags[0] = ATA_FLAG_SATA;
+	probe_ent->port_flags[1] = ATA_FLAG_SATA;
+
 	/* notice 4-port boards */
 	switch (board_idx) {
 	case board_20319:
@@ -717,9 +739,25 @@ static int pdc_ata_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 
 		probe_ent->port[2].scr_addr = base + 0x600;
 		probe_ent->port[3].scr_addr = base + 0x700;
+
+		probe_ent->port_flags[2] = ATA_FLAG_SATA;
+		probe_ent->port_flags[3] = ATA_FLAG_SATA;
 		break;
 	case board_2037x:
-		probe_ent->n_ports = 2;
+		/* Some boards also have a PATA port */
+		tmp = readb(mmio_base + PDC_FLASH_CTL+1);
+		if (!(tmp & 0x80))
+		{
+			probe_ent->n_ports = 3;
+
+			pdc_ata_setup_port(&probe_ent->port[2], base +0x300);
+
+			probe_ent->port_flags[2] = ATA_FLAG_SLAVE_POSS;
+
+			printk(KERN_INFO DRV_NAME " PATA port found\n");
+		}
+		else
+			probe_ent->n_ports = 2;
 		break;
 	case board_20771:
 		probe_ent->n_ports = 2;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b6aac46ec1..6ccc304469 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1158,6 +1158,7 @@ static int choose_configuration(struct usb_device *udev)
 	u16 devstatus;
 	int bus_powered;
 	int num_configs;
+	int insufficient_power = 0;
 	struct usb_host_config *c, *best;
 
 	/* If this fails, assume the device is bus-powered */
@@ -1202,8 +1203,10 @@ static int choose_configuration(struct usb_device *udev)
 		 */
 
 		/* Rule out configs that draw too much bus current */
-		if (c->desc.bMaxPower * 2 > udev->bus_mA)
+		if (c->desc.bMaxPower * 2 > udev->bus_mA) {
+			insufficient_power++;
 			continue;
+		}
 
 		/* If the first config's first interface is COMM/2/0xff
 		 * (MSFT RNDIS), rule it out unless Linux has host-side
@@ -1236,6 +1239,11 @@ static int choose_configuration(struct usb_device *udev)
 			best = c;
 	}
 
+	if (insufficient_power > 0)
+		dev_info(&udev->dev, "rejected %d configuration%s "
+			"due to insufficient available bus power\n",
+			insufficient_power, plural(insufficient_power));
+
 	if (best) {
 		i = best->desc.bConfigurationValue;
 		dev_info(&udev->dev,
diff --git a/drivers/usb/input/wacom.c b/drivers/usb/input/wacom.c
index d3e15df9e8..cf84c6096f 100644
--- a/drivers/usb/input/wacom.c
+++ b/drivers/usb/input/wacom.c
@@ -9,7 +9,7 @@
  *  Copyright (c) 2000 Daniel Egger		<egger@suse.de>
  *  Copyright (c) 2001 Frederic Lepied		<flepied@mandrakesoft.com>
  *  Copyright (c) 2004 Panagiotis Issaris	<panagiotis.issaris@mech.kuleuven.ac.be>
- *  Copyright (c) 2002-2005 Ping Cheng		<pingc@wacom.com>
+ *  Copyright (c) 2002-2006 Ping Cheng		<pingc@wacom.com>
  *
  *  ChangeLog:
  *      v0.1 (vp)  - Initial release
@@ -56,6 +56,8 @@
  *		   - Merged wacom_intuos3_irq into wacom_intuos_irq
  *	v1.44 (pc) - Added support for Graphire4, Cintiq 710, Intuos3 6x11, etc.
  *		   - Report Device IDs
+ *	v1.45 (pc) - Added support for DTF 521, Intuos3 12x12 and 12x19
+ *		   - Minor data report fix
  */
 
 /*
@@ -78,7 +80,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.44"
+#define DRIVER_VERSION "v1.45"
 #define DRIVER_AUTHOR "Vojtech Pavlik <vojtech@ucw.cz>"
 #define DRIVER_DESC "USB Wacom Graphire and Wacom Intuos tablet driver"
 #define DRIVER_LICENSE "GPL"
@@ -99,6 +101,8 @@ enum {
 	PL,
 	INTUOS,
 	INTUOS3,
+	INTUOS312,
+	INTUOS319,
 	CINTIQ,
 	MAX_TYPE
 };
@@ -127,7 +131,19 @@ struct wacom {
 	char phys[32];
 };
 
+#define USB_REQ_GET_REPORT	0x01
 #define USB_REQ_SET_REPORT	0x09
+
+static int usb_get_report(struct usb_interface *intf, unsigned char type,
+				unsigned char id, void *buf, int size)
+{
+	return usb_control_msg(interface_to_usbdev(intf),
+		usb_rcvctrlpipe(interface_to_usbdev(intf), 0),
+		USB_REQ_GET_REPORT, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+		(type << 8) + id, intf->altsetting[0].desc.bInterfaceNumber,
+		buf, size, 100);
+}
+
 static int usb_set_report(struct usb_interface *intf, unsigned char type,
 				unsigned char id, void *buf, int size)
 {
@@ -206,7 +222,8 @@ static void wacom_pl_irq(struct urb *urb, struct pt_regs *regs)
 			wacom->tool[1] = BTN_TOOL_PEN;
 			id = STYLUS_DEVICE_ID;
 		}
-		input_report_key(dev, wacom->tool[1], id); /* report in proximity for tool */
+		input_report_key(dev, wacom->tool[1], prox); /* report in proximity for tool */
+		input_report_abs(dev, ABS_MISC, id); /* report tool id */
 		input_report_abs(dev, ABS_X, data[3] | (data[2] << 7) | ((data[1] & 0x03) << 14));
 		input_report_abs(dev, ABS_Y, data[6] | (data[5] << 7) | ((data[4] & 0x03) << 14));
 		input_report_abs(dev, ABS_PRESSURE, pressure);
@@ -239,7 +256,7 @@ static void wacom_ptu_irq(struct urb *urb, struct pt_regs *regs)
 	struct wacom *wacom = urb->context;
 	unsigned char *data = wacom->data;
 	struct input_dev *dev = wacom->dev;
-	int retval;
+	int retval, id;
 
 	switch (urb->status) {
 	case 0:
@@ -263,12 +280,15 @@ static void wacom_ptu_irq(struct urb *urb, struct pt_regs *regs)
 
 	input_regs(dev, regs);
 	if (data[1] & 0x04) {
-		input_report_key(dev, BTN_TOOL_RUBBER, (data[1] & 0x20) ? ERASER_DEVICE_ID : 0);
+		input_report_key(dev, BTN_TOOL_RUBBER, data[1] & 0x20);
 		input_report_key(dev, BTN_TOUCH, data[1] & 0x08);
+		id = ERASER_DEVICE_ID;
 	} else {
-		input_report_key(dev, BTN_TOOL_PEN, (data[1] & 0x20) ? STYLUS_DEVICE_ID : 0);
+		input_report_key(dev, BTN_TOOL_PEN, data[1] & 0x20);
 		input_report_key(dev, BTN_TOUCH, data[1] & 0x01);
+		id = STYLUS_DEVICE_ID;
 	}
+	input_report_abs(dev, ABS_MISC, id); /* report tool id */
 	input_report_abs(dev, ABS_X, le16_to_cpu(*(__le16 *) &data[2]));
 	input_report_abs(dev, ABS_Y, le16_to_cpu(*(__le16 *) &data[4]));
 	input_report_abs(dev, ABS_PRESSURE, le16_to_cpu(*(__le16 *) &data[6]));
@@ -312,7 +332,8 @@ static void wacom_penpartner_irq(struct urb *urb, struct pt_regs *regs)
 	}
 
 	input_regs(dev, regs);
-	input_report_key(dev, BTN_TOOL_PEN, STYLUS_DEVICE_ID);
+	input_report_key(dev, BTN_TOOL_PEN, 1);
+	input_report_abs(dev, ABS_MISC, STYLUS_DEVICE_ID); /* report tool id */
 	input_report_abs(dev, ABS_X, le16_to_cpu(*(__le16 *) &data[1]));
 	input_report_abs(dev, ABS_Y, le16_to_cpu(*(__le16 *) &data[3]));
 	input_report_abs(dev, ABS_PRESSURE, (signed char)data[6] + 127);
@@ -350,6 +371,8 @@ static void wacom_graphire_irq(struct urb *urb, struct pt_regs *regs)
 		goto exit;
 	}
 
+	if (data[0] == 99) return; /* for Volito tablets */
+
 	if (data[0] != 2) {
 		dbg("wacom_graphire_irq: received unknown report #%d", data[0]);
 		goto exit;
@@ -374,10 +397,10 @@ static void wacom_graphire_irq(struct urb *urb, struct pt_regs *regs)
 			case 2: /* Mouse with wheel */
 				input_report_key(dev, BTN_MIDDLE, data[1] & 0x04);
 				if (wacom->features->type == WACOM_G4) {
-					rw = data[7] & 0x04 ? -(data[7] & 0x03) : (data[7] & 0x03);
-					input_report_rel(dev, REL_WHEEL, rw);
+					rw = data[7] & 0x04 ? (data[7] & 0x03)-4 : (data[7] & 0x03);
+					input_report_rel(dev, REL_WHEEL, -rw);
 				} else
-					input_report_rel(dev, REL_WHEEL, (signed char) data[6]);
+					input_report_rel(dev, REL_WHEEL, -(signed char) data[6]);
 				/* fall through */
 
 			case 3: /* Mouse without wheel */
@@ -406,39 +429,27 @@ static void wacom_graphire_irq(struct urb *urb, struct pt_regs *regs)
 		}
 	}
 
-	input_report_key(dev, wacom->tool[0], (data[1] & 0x10) ? id : 0);
+	if (data[1] & 0x10)
+		input_report_abs(dev, ABS_MISC, id); /* report tool id */
+	else
+		input_report_abs(dev, ABS_MISC, 0); /* reset tool id */
+	input_report_key(dev, wacom->tool[0], data[1] & 0x10);
 	input_sync(dev);
 
 	/* send pad data */
 	if (wacom->features->type == WACOM_G4) {
-		/* fist time sending pad data */
-		if (wacom->tool[1] != BTN_TOOL_FINGER) {
-			wacom->id[1] = 0;
-			wacom->serial[1] = (data[7] & 0x38) >> 2;
-		}
-		if (data[7] & 0xf8) {
+		if ((wacom->serial[1] & 0xc0) != (data[7] & 0xf8)) {
+			wacom->id[1] = 1;
+			wacom->serial[1] = (data[7] & 0xf8);
 			input_report_key(dev, BTN_0, (data[7] & 0x40));
 			input_report_key(dev, BTN_4, (data[7] & 0x80));
-			if (((data[7] & 0x38) >> 2) == (wacom->serial[1] & 0x0e))
-				/* alter REL_WHEEL value so X apps can get it */
-				wacom->serial[1] += (wacom->serial[1] & 0x01) ? -1 : 1;
-			else
-				 wacom->serial[1] = (data[7] & 0x38 ) >> 2;
-
-			/* don't alter the value when there is no wheel event */
-			if (wacom->serial[1] == 1)
-				wacom->serial[1] = 0;
-			rw = wacom->serial[1];
-			rw = (rw & 0x08) ? -(rw & 0x07) : (rw & 0x07);
+			rw = ((data[7] & 0x18) >> 3) - ((data[7] & 0x20) >> 3);
 			input_report_rel(dev, REL_WHEEL, rw);
-			wacom->tool[1] = BTN_TOOL_FINGER;
-			wacom->id[1] = data[7] & 0xf8;
-			input_report_key(dev, wacom->tool[1], 0xf0);
+			input_report_key(dev, BTN_TOOL_FINGER, 0xf0);
 			input_event(dev, EV_MSC, MSC_SERIAL, 0xf0);
 		} else if (wacom->id[1]) {
 			wacom->id[1] = 0;
-			wacom->serial[1] = 0;
-			input_report_key(dev, wacom->tool[1], 0);
+			input_report_key(dev, BTN_TOOL_FINGER, 0);
 			input_event(dev, EV_MSC, MSC_SERIAL, 0xf0);
 		}
 		input_sync(dev);
@@ -516,21 +527,31 @@ static int wacom_intuos_inout(struct urb *urb)
 			default: /* Unknown tool */
 				wacom->tool[idx] = BTN_TOOL_PEN;
 		}
-		input_report_key(dev, wacom->tool[idx], wacom->id[idx]);
-		input_event(dev, EV_MSC, MSC_SERIAL, wacom->serial[idx]);
-		input_sync(dev);
+		if(!((wacom->tool[idx] == BTN_TOOL_LENS) &&
+				((wacom->features->type == INTUOS312)
+					|| (wacom->features->type == INTUOS319)))) {
+			input_report_abs(dev, ABS_MISC, wacom->id[idx]); /* report tool id */
+			input_report_key(dev, wacom->tool[idx], 1);
+			input_event(dev, EV_MSC, MSC_SERIAL, wacom->serial[idx]);
+			input_sync(dev);
+		}
 		return 1;
 	}
 
 	/* Exit report */
 	if ((data[1] & 0xfe) == 0x80) {
 		input_report_key(dev, wacom->tool[idx], 0);
+		input_report_abs(dev, ABS_MISC, 0); /* reset tool id */
 		input_event(dev, EV_MSC, MSC_SERIAL, wacom->serial[idx]);
 		input_sync(dev);
 		return 1;
 	}
 
-	return 0;
+	if((wacom->tool[idx] == BTN_TOOL_LENS) && ((wacom->features->type == INTUOS312)
+			|| (wacom->features->type == INTUOS319)))
+		return 1;
+	else
+		return 0;
 }
 
 static void wacom_intuos_general(struct urb *urb)
@@ -600,10 +621,9 @@ static void wacom_intuos_irq(struct urb *urb, struct pt_regs *regs)
 	/* pad packets. Works as a second tool and is always in prox */
 	if (data[0] == 12) {
 		/* initiate the pad as a device */
-		if (wacom->tool[1] != BTN_TOOL_FINGER) {
+		if (wacom->tool[1] != BTN_TOOL_FINGER)
 			wacom->tool[1] = BTN_TOOL_FINGER;
-			input_report_key(dev, wacom->tool[1], 1);
-		}
+
 		input_report_key(dev, BTN_0, (data[5] & 0x01));
 		input_report_key(dev, BTN_1, (data[5] & 0x02));
 		input_report_key(dev, BTN_2, (data[5] & 0x04));
@@ -614,6 +634,11 @@ static void wacom_intuos_irq(struct urb *urb, struct pt_regs *regs)
 		input_report_key(dev, BTN_7, (data[6] & 0x08));
 		input_report_abs(dev, ABS_RX, ((data[1] & 0x1f) << 8) | data[2]);
 		input_report_abs(dev, ABS_RY, ((data[3] & 0x1f) << 8) | data[4]);
+
+		if((data[5] & 0x0f) | (data[6] & 0x0f) | (data[1] & 0x1f) | data[2])
+			input_report_key(dev, wacom->tool[1], 1);
+		else
+			input_report_key(dev, wacom->tool[1], 0);
 		input_event(dev, EV_MSC, MSC_SERIAL, 0xffffffff);
 		input_sync(dev);
 		goto exit;
@@ -676,8 +701,8 @@ static void wacom_intuos_irq(struct urb *urb, struct pt_regs *regs)
 			input_report_key(dev, BTN_LEFT,   data[8] & 0x04);
 			input_report_key(dev, BTN_MIDDLE, data[8] & 0x08);
 			input_report_key(dev, BTN_RIGHT,  data[8] & 0x10);
-			input_report_rel(dev, REL_WHEEL, ((data[8] & 0x02) >> 1)
-						 - (data[8] & 0x01));
+			input_report_rel(dev, REL_WHEEL, (data[8] & 0x01)
+						 - ((data[8] & 0x02) >> 1));
 
 			/* I3 2D mouse side buttons */
 			if (wacom->features->type == INTUOS3) {
@@ -695,7 +720,8 @@ static void wacom_intuos_irq(struct urb *urb, struct pt_regs *regs)
 		}
 	}
 
-	input_report_key(dev, wacom->tool[idx], wacom->id[idx]);
+	input_report_abs(dev, ABS_MISC, wacom->id[idx]); /* report tool id */
+	input_report_key(dev, wacom->tool[idx], 1);
 	input_event(dev, EV_MSC, MSC_SERIAL, wacom->serial[idx]);
 	input_sync(dev);
 
@@ -733,7 +759,8 @@ static struct wacom_features wacom_features[] = {
 	{ "Wacom PL800",         8,   7220,  5780,  511, 32, PL,         wacom_pl_irq },
 	{ "Wacom PL700",         8,   6758,  5406,  511, 32, PL,	 wacom_pl_irq },
 	{ "Wacom PL510",         8,   6282,  4762,  511, 32, PL,	 wacom_pl_irq },
-	{ "Wacom PL710",         8,  34080, 27660,  511, 32, PL,	 wacom_pl_irq },
+	{ "Wacom DTU710",        8,  34080, 27660,  511, 32, PL,	 wacom_pl_irq },
+	{ "Wacom DTF521",        8,   6282,  4762,  511, 32, PL,         wacom_pl_irq },
 	{ "Wacom DTF720",        8,   6858,  5506,  511, 32, PL,	 wacom_pl_irq },
 	{ "Wacom Cintiq Partner",8,  20480, 15360,  511, 32, PL,         wacom_ptu_irq },
 	{ "Wacom Intuos2 4x5",   10, 12700, 10600, 1023, 15, INTUOS,     wacom_intuos_irq },
@@ -744,6 +771,8 @@ static struct wacom_features wacom_features[] = {
 	{ "Wacom Intuos3 4x5",   10, 25400, 20320, 1023, 15, INTUOS3,    wacom_intuos_irq },
 	{ "Wacom Intuos3 6x8",   10, 40640, 30480, 1023, 15, INTUOS3,    wacom_intuos_irq },
 	{ "Wacom Intuos3 9x12",  10, 60960, 45720, 1023, 15, INTUOS3,    wacom_intuos_irq },
+	{ "Wacom Intuos3 12x12", 10, 60960, 60960, 1023, 15, INTUOS312,  wacom_intuos_irq },
+	{ "Wacom Intuos3 12x19", 10, 97536, 60960, 1023, 15, INTUOS319,  wacom_intuos_irq },
 	{ "Wacom Intuos3 6x11",  10, 54204, 31750, 1023, 15, INTUOS3,    wacom_intuos_irq },
 	{ "Wacom Cintiq 21UX",   10, 87200, 65600, 1023, 15, CINTIQ,     wacom_intuos_irq },
 	{ "Wacom Intuos2 6x8",   10, 20320, 16240, 1023, 15, INTUOS,     wacom_intuos_irq },
@@ -779,6 +808,7 @@ static struct usb_device_id wacom_ids[] = {
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x38) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x39) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xC0) },
+	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xC3) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x03) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x41) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x42) },
@@ -788,6 +818,8 @@ static struct usb_device_id wacom_ids[] = {
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xB0) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xB1) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xB2) },
+	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xB3) },
+	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xB4) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0xB5) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x3F) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x47) },
@@ -820,7 +852,7 @@ static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *i
 	struct usb_endpoint_descriptor *endpoint;
 	struct wacom *wacom;
 	struct input_dev *input_dev;
-	char rep_data[2] = {0x02, 0x02};
+	char rep_data[2], limit = 0;
 
 	wacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);
 	input_dev = input_allocate_device();
@@ -857,6 +889,7 @@ static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *i
 	input_set_abs_params(input_dev, ABS_X, 0, wacom->features->x_max, 4, 0);
 	input_set_abs_params(input_dev, ABS_Y, 0, wacom->features->y_max, 4, 0);
 	input_set_abs_params(input_dev, ABS_PRESSURE, 0, wacom->features->pressure_max, 0, 0);
+	input_dev->absbit[LONG(ABS_MISC)] |= BIT(ABS_MISC);
 
 	switch (wacom->features->type) {
 		case WACOM_G4:
@@ -875,6 +908,8 @@ static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *i
 			break;
 
 		case INTUOS3:
+		case INTUOS312:
+		case INTUOS319:
 		case CINTIQ:
 			input_dev->keybit[LONG(BTN_DIGI)] |= BIT(BTN_TOOL_FINGER);
 			input_dev->keybit[LONG(BTN_LEFT)] |= BIT(BTN_0) | BIT(BTN_1) | BIT(BTN_2) | BIT(BTN_3) | BIT(BTN_4) | BIT(BTN_5) | BIT(BTN_6) | BIT(BTN_7);
@@ -916,10 +951,13 @@ static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *i
 
 	input_register_device(wacom->dev);
 
-	/* ask the tablet to report tablet data */
-	usb_set_report(intf, 3, 2, rep_data, 2);
-	/* repeat once (not sure why the first call often fails) */
-	usb_set_report(intf, 3, 2, rep_data, 2);
+	/* Ask the tablet to report tablet data. Repeat until it succeeds */
+	do {
+		rep_data[0] = 2;
+		rep_data[1] = 2;
+		usb_set_report(intf, 3, 2, rep_data, 2);
+		usb_get_report(intf, 3, 2, rep_data, 2);
+	} while (rep_data[1] != 2 && limit++ < 5);
 
 	usb_set_intfdata(intf, wacom);
 	return 0;
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index f5079c78ba..407bf978bc 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -454,8 +454,8 @@ config FB_TGA
 	  cards. Say Y if you have one of those.
 
 config FB_VESA
-	bool "VESA VGA graphics support"
-	depends on (FB = y) && X86
+	tristate "VESA VGA graphics support"
+	depends on (FB = y) && (X86 || X86_64)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
@@ -465,6 +465,48 @@ config FB_VESA
 	  You will get a boot time penguin logo at no additional cost. Please
 	  read <file:Documentation/fb/vesafb.txt>. If unsure, say Y.
 
+choice
+	prompt "VESA driver type"
+	depends on FB_VESA
+	default FB_VESA_STD if X86_64
+	default FB_VESA_TNG if X86
+
+config FB_VESA_STD
+	bool "vesafb"
+	help
+	  This is the frame buffer device driver for generic VESA 2.0
+	  compliant graphic cards. The older VESA 1.2 cards are not supported.
+	  You will get a boot time penguin logo at no additional cost. Please
+	  read <file:Documentation/fb/vesafb.txt>. Choose this driver if you
+	  are experiencing problems with vesafb-tng or if you own a 64-bit system.
+
+	  Note that this driver cannot be compiled as a module.
+
+config FB_VESA_TNG
+	bool "vesafb-tng"
+	depends on !X86_64
+	select FB_MODE_HELPERS
+	help
+	  This is the frame buffer device driver for generic VESA 2.0
+	  compliant graphic cards. It is capable of taking advantage of
+	  VBE 3.0 features. With this driver you will be able to adjust
+	  the refresh rate (VBE 3.0 compliant boards only) and change
+	  the graphic mode on-the-fly.
+
+	  You will also get a boot time penguin logo at no additional cost. Please
+	  read <file:Documentation/fb/vesafb.txt>.
+
+endchoice
+
+config FB_VESA_DEFAULT_MODE
+	string "VESA default mode"
+	depends on FB_VESA_TNG
+	default "640x480@60"
+	help
+	  This option is used to determine the default mode vesafb is
+	  supposed to switch to in case no mode is provided as a kernel
+	  command line parameter.
+
 config VIDEO_SELECT
 	bool
 	depends on FB_VESA
@@ -754,7 +796,6 @@ config FB_MATROX
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
-	select FB_TILEBLITTING
 	select FB_MACMODES if PPC_PMAC
 	---help---
 	  Say Y here if you have a Matrox Millennium, Matrox Millennium II,
@@ -1458,5 +1499,15 @@ if FB && SYSFS
 	source "drivers/video/backlight/Kconfig"
 endif
 
-endmenu
+config FB_SPLASH
+	bool "Support for the framebuffer splash"
+	depends on FRAMEBUFFER_CONSOLE=y && !FB_TILEBLITTING
+	default n
+	---help---
+	  This option enables support for the Linux boot-up splash screen and
+	  graphical backgrounds on consoles. Note that you will need userspace
+	  splash utilities in order to take advantage of these features. Refer
+	  to Documentation/fb/splash.txt for more information.
 
+	  If unsure, say N.
+endmenu
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index aa434e725c..64adee07e1 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -7,6 +7,7 @@
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
 obj-$(CONFIG_SYSFS)		  += backlight/
+obj-$(CONFIG_FB_SPLASH)           += fbsplash.o cfbsplash.o
 
 obj-$(CONFIG_FB)                  += fb.o
 fb-y                              := fbmem.o fbmon.o fbcmap.o fbsysfs.o \
@@ -96,7 +97,11 @@ obj-$(CONFIG_FB_IMX)              += imxfb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 
 # Platform or fallback drivers go here
-obj-$(CONFIG_FB_VESA)             += vesafb.o
+ifeq ($(CONFIG_FB_VESA_STD),y)
+  obj-y				  += vesafb.o
+else
+  obj-$(CONFIG_FB_VESA)		  += vesafb-thread.o vesafb-tng.o
+endif
 obj-$(CONFIG_FB_VGA16)            += vga16fb.o vgastate.o
 obj-$(CONFIG_FB_OF)               += offb.o
 
diff --git a/drivers/video/cfbsplash.c b/drivers/video/cfbsplash.c
new file mode 100644
index 0000000000..d64c0efa3e
--- /dev/null
+++ b/drivers/video/cfbsplash.c
@@ -0,0 +1,472 @@
+/*
+ *  linux/drivers/video/cfbsplash.c -- Framebuffer splash render functions
+ *
+ *  Copyright (C) 2004 Michal Januszewski <spock@gentoo.org>
+ *
+ *  Code based upon "Bootsplash" (C) 2001-2003
+ *       Volker Poplawski <volker@poplawski.de>,
+ *       Stefan Reinauer <stepan@suse.de>,
+ *       Steffen Winterfeldt <snwint@suse.de>,
+ *       Michael Schroeder <mls@suse.de>,
+ *       Ken Wimer <wimer@suse.de>.
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/selection.h>
+#include <linux/vt_kern.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "console/fbcon.h"
+#include "fbsplash.h"
+
+#define parse_pixel(shift,bpp,type)						\
+	do {									\
+		if (d & (0x80 >> (shift)))					\
+			dd2[(shift)] = fgx;					\
+		else								\
+			dd2[(shift)] = transparent ? *(type *)splash_src : bgx;	\
+		splash_src += (bpp);						\
+	} while (0)								\
+
+extern int get_color(struct vc_data *vc, struct fb_info *info,
+		     u16 c, int is_fg);
+
+void fbsplash_fix_pseudo_pal(struct fb_info *info, struct vc_data *vc)
+{
+	int i, j, k;
+	int minlen = min(min(info->var.red.length, info->var.green.length),
+			     info->var.blue.length);
+	u32 col;
+
+	for (j = i = 0; i < 16; i++) {
+		k = color_table[i];
+
+		col = ((vc->vc_palette[j++]  >> (8-minlen))
+			<< info->var.red.offset);
+		col |= ((vc->vc_palette[j++] >> (8-minlen))
+			<< info->var.green.offset);
+		col |= ((vc->vc_palette[j++] >> (8-minlen))
+			<< info->var.blue.offset);
+			((u32 *)info->pseudo_palette)[k] = col;
+	}
+}
+
+void fbsplash_renderc(struct fb_info *info, int ypos, int xpos, int height,
+		      int width, u8* src, u32 fgx, u32 bgx, u8 transparent)
+{
+	unsigned int x, y;
+	u32 dd;
+	int bytespp = ((info->var.bits_per_pixel + 7) >> 3);
+	unsigned int d = ypos * info->fix.line_length + xpos * bytespp;
+	unsigned int ds = (ypos * info->var.xres + xpos) * bytespp;
+	u16 dd2[4];
+
+	u8* splash_src = (u8 *)(info->splash.data + ds);
+	u8* dst = (u8 *)(info->screen_base + d);
+
+	if ((ypos + height) > info->var.yres || (xpos + width) > info->var.xres)
+		return;
+
+	for (y = 0; y < height; y++) {
+		switch (info->var.bits_per_pixel) {
+
+		case 32:
+			for (x = 0; x < width; x++) {
+
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+					dd = fgx;
+				else
+					dd = transparent ?
+					     *(u32 *)splash_src : bgx;
+
+				d <<= 1;
+				splash_src += 4;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+			break;
+		case 24:
+			for (x = 0; x < width; x++) {
+
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+					dd = fgx;
+				else
+					dd = transparent ?
+					     (*(u32 *)splash_src & 0xffffff) : bgx;
+
+				d <<= 1;
+				splash_src += 3;
+#ifdef __LITTLE_ENDIAN
+				fb_writew(dd & 0xffff, dst);
+				dst += 2;
+				fb_writeb((dd >> 16), dst);
+#else
+				fb_writew(dd >> 8, dst);
+				dst += 2;
+				fb_writeb(dd & 0xff, dst);
+#endif
+				dst++;
+			}
+			break;
+		case 16:
+			for (x = 0; x < width; x += 2) {
+		    		if ((x & 7) == 0)
+					d = *src++;
+
+				parse_pixel(0, 2, u16);
+				parse_pixel(1, 2, u16);
+#ifdef __LITTLE_ENDIAN
+				dd = dd2[0] | (dd2[1] << 16);
+#else
+				dd = dd2[1] | (dd2[0] << 16);
+#endif
+				d <<= 2;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+			break;
+
+		case 8:
+			for (x = 0; x < width; x += 4) {
+				if ((x & 7) == 0)
+					d = *src++;
+
+				parse_pixel(0, 1, u8);
+				parse_pixel(1, 1, u8);
+				parse_pixel(2, 1, u8);
+				parse_pixel(3, 1, u8);
+
+#ifdef __LITTLE_ENDIAN
+				dd = dd2[0] | (dd2[1] << 8) | (dd2[2] << 16) | (dd2[3] << 24);
+#else
+				dd = dd2[3] | (dd2[2] << 8) | (dd2[1] << 16) | (dd2[0] << 24);
+#endif
+				d <<= 4;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+		}
+
+		dst += info->fix.line_length - width * bytespp;
+		splash_src += (info->var.xres - width) * bytespp;
+    	}
+}
+
+#define cc2cx(a) 						\
+	((info->fix.visual == FB_VISUAL_TRUECOLOR || 		\
+	  info->fix.visual == FB_VISUAL_DIRECTCOLOR) ? 		\
+	 ((u32*)info->pseudo_palette)[a] : a)
+
+void fbsplash_putcs(struct vc_data *vc, struct fb_info *info,
+		   const unsigned short *s, int count, int yy, int xx)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	struct fbcon_ops *ops = info->fbcon_par;
+	int fg_color, bg_color, transparent;
+	u8 *src;
+	u32 bgx, fgx;
+	u16 c = scr_readw(s);
+
+	fg_color = get_color(vc, info, c, 1);
+        bg_color = get_color(vc, info, c, 0);
+
+	/* Don't paint the background image if console is blanked */
+	transparent = ops->blank_state ? 0 :
+		(vc->vc_splash.bg_color == bg_color);
+
+	xx = xx * vc->vc_font.width + vc->vc_splash.tx;
+	yy = yy * vc->vc_font.height + vc->vc_splash.ty;
+
+	fgx = cc2cx(fg_color);
+	bgx = cc2cx(bg_color);
+
+	while (count--) {
+		c = scr_readw(s++);
+		src = vc->vc_font.data + (c & charmask) * vc->vc_font.height *
+		      ((vc->vc_font.width + 7) >> 3);
+
+		fbsplash_renderc(info, yy, xx, vc->vc_font.height,
+			       vc->vc_font.width, src, fgx, bgx, transparent);
+		xx += vc->vc_font.width;
+	}
+}
+
+void fbsplash_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	int i;
+	unsigned int dsize, s_pitch;
+	struct fbcon_ops *ops = info->fbcon_par;
+	struct vc_data* vc;
+	u8 *src;
+
+	/* we really don't need any cursors while the console is blanked */
+	if (info->state != FBINFO_STATE_RUNNING || ops->blank_state)
+		return;
+
+	vc = vc_cons[ops->currcon].d;
+
+	src = kmalloc(64 + sizeof(struct fb_image), GFP_ATOMIC);
+	if (!src)
+		return;
+
+	s_pitch = (cursor->image.width + 7) >> 3;
+	dsize = s_pitch * cursor->image.height;
+	if (cursor->enable) {
+		switch (cursor->rop) {
+		case ROP_XOR:
+			for (i = 0; i < dsize; i++)
+				src[i] = cursor->image.data[i] ^ cursor->mask[i];
+                        break;
+		case ROP_COPY:
+		default:
+			for (i = 0; i < dsize; i++)
+				src[i] = cursor->image.data[i] & cursor->mask[i];
+			break;
+		}
+	} else
+		memcpy(src, cursor->image.data, dsize);
+
+	fbsplash_renderc(info,
+			cursor->image.dy + vc->vc_splash.ty,
+			cursor->image.dx + vc->vc_splash.tx,
+			cursor->image.height,
+			cursor->image.width,
+			(u8*)src,
+			cc2cx(cursor->image.fg_color),
+			cc2cx(cursor->image.bg_color),
+			cursor->image.bg_color == vc->vc_splash.bg_color);
+
+	kfree(src);
+}
+
+static void splashset(u8 *dst, int height, int width, int dstbytes,
+		        u32 bgx, int bpp)
+{
+	int i;
+
+	if (bpp == 8)
+		bgx |= bgx << 8;
+	if (bpp == 16 || bpp == 8)
+		bgx |= bgx << 16;
+
+	while (height-- > 0) {
+		u8 *p = dst;
+
+		switch (bpp) {
+
+		case 32:
+			for (i=0; i < width; i++) {
+				fb_writel(bgx, p); p += 4;
+			}
+			break;
+		case 24:
+			for (i=0; i < width; i++) {
+#ifdef __LITTLE_ENDIAN
+				fb_writew((bgx & 0xffff),(u16*)p); p += 2;
+				fb_writeb((bgx >> 16),p++);
+#else
+				fb_writew((bgx >> 8),(u16*)p); p += 2;
+				fb_writeb((bgx & 0xff),p++);
+#endif
+			}
+		case 16:
+			for (i=0; i < width/4; i++) {
+				fb_writel(bgx,p); p += 4;
+				fb_writel(bgx,p); p += 4;
+			}
+			if (width & 2) {
+				fb_writel(bgx,p); p += 4;
+			}
+			if (width & 1)
+				fb_writew(bgx,(u16*)p);
+			break;
+		case 8:
+			for (i=0; i < width/4; i++) {
+				fb_writel(bgx,p); p += 4;
+			}
+
+			if (width & 2) {
+				fb_writew(bgx,p); p += 2;
+			}
+			if (width & 1)
+				fb_writeb(bgx,(u8*)p);
+			break;
+
+		}
+		dst += dstbytes;
+	}
+}
+
+void fbsplash_copy(u8 *dst, u8 *src, int height, int width, int linebytes,
+		   int srclinebytes, int bpp)
+{
+	int i;
+
+	while (height-- > 0) {
+		u32 *p = (u32 *)dst;
+		u32 *q = (u32 *)src;
+
+		switch (bpp) {
+
+		case 32:
+			for (i=0; i < width; i++)
+				fb_writel(*q++, p++);
+			break;
+		case 24:
+			for (i=0; i < (width*3/4); i++)
+				fb_writel(*q++, p++);
+			if ((width*3) % 4) {
+				if (width & 2) {
+					fb_writeb(*(u8*)q, (u8*)p);
+				} else if (width & 1) {
+					fb_writew(*(u16*)q, (u16*)p);
+					fb_writeb(*(u8*)((u16*)q+1),(u8*)((u16*)p+2));
+				}
+			}
+			break;
+		case 16:
+			for (i=0; i < width/4; i++) {
+				fb_writel(*q++, p++);
+				fb_writel(*q++, p++);
+			}
+			if (width & 2)
+				fb_writel(*q++, p++);
+			if (width & 1)
+				fb_writew(*(u16*)q, (u16*)p);
+			break;
+		case 8:
+			for (i=0; i < width/4; i++)
+				fb_writel(*q++, p++);
+
+			if (width & 2) {
+				fb_writew(*(u16*)q, (u16*)p);
+				q = (u32*) ((u16*)q + 1);
+				p = (u32*) ((u16*)p + 1);
+			}
+			if (width & 1)
+				fb_writeb(*(u8*)q, (u8*)p);
+			break;
+		}
+
+		dst += linebytes;
+		src += srclinebytes;
+	}
+}
+
+static void splashfill(struct fb_info *info, int sy, int sx, int height,
+		       int width)
+{
+	int bytespp = ((info->var.bits_per_pixel + 7) >> 3);
+	int d  = sy * info->fix.line_length + sx * bytespp;
+	int ds = (sy * info->var.xres + sx) * bytespp;
+
+	fbsplash_copy((u8 *)(info->screen_base + d), (u8 *)(info->splash.data + ds),
+		    height, width, info->fix.line_length, info->var.xres * bytespp,
+		    info->var.bits_per_pixel);
+}
+
+void fbsplash_clear(struct vc_data *vc, struct fb_info *info, int sy, int sx,
+		    int height, int width)
+{
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int bg_color = attr_bgcol_ec(bgshift, vc);
+	int transparent = vc->vc_splash.bg_color == bg_color;
+	struct fbcon_ops *ops = info->fbcon_par;
+	u8 *dst;
+
+	sy = sy * vc->vc_font.height + vc->vc_splash.ty;
+	sx = sx * vc->vc_font.width + vc->vc_splash.tx;
+	height *= vc->vc_font.height;
+	width *= vc->vc_font.width;
+
+	/* Don't paint the background image if console is blanked */
+	if (transparent && !ops->blank_state) {
+		splashfill(info, sy, sx, height, width);
+	} else {
+		dst = (u8 *)(info->screen_base + sy * info->fix.line_length +
+			     sx * ((info->var.bits_per_pixel + 7) >> 3));
+		splashset(dst, height, width, info->fix.line_length, cc2cx(bg_color),
+			  info->var.bits_per_pixel);
+	}
+}
+
+void fbsplash_clear_margins(struct vc_data *vc, struct fb_info *info,
+			    int bottom_only)
+{
+	unsigned int tw = vc->vc_cols*vc->vc_font.width;
+	unsigned int th = vc->vc_rows*vc->vc_font.height;
+
+	if (!bottom_only) {
+		/* top margin */
+		splashfill(info, 0, 0, vc->vc_splash.ty, info->var.xres);
+		/* left margin */
+		splashfill(info, vc->vc_splash.ty, 0, th, vc->vc_splash.tx);
+		/* right margin */
+		splashfill(info, vc->vc_splash.ty, vc->vc_splash.tx + tw, th,
+			   info->var.xres - vc->vc_splash.tx - tw);
+	}
+	splashfill(info, vc->vc_splash.ty + th, 0,
+		   info->var.yres - vc->vc_splash.ty - th, info->var.xres);
+}
+
+void fbsplash_bmove_redraw(struct vc_data *vc, struct fb_info *info, int y,
+			   int sx, int dx, int width)
+{
+	u16 *d = (u16 *) (vc->vc_origin + vc->vc_size_row * y + dx * 2);
+	u16 *s = d + (dx - sx);
+	u16 *start = d;
+	u16 *ls = d;
+	u16 *le = d + width;
+	u16 c;
+	int x = dx;
+	u16 attr = 1;
+
+	do {
+		c = scr_readw(d);
+		if (attr != (c & 0xff00)) {
+			attr = c & 0xff00;
+			if (d > start) {
+				fbsplash_putcs(vc, info, start, d - start, y, x);
+				x += d - start;
+				start = d;
+			}
+		}
+		if (s >= ls && s < le && c == scr_readw(s)) {
+			if (d > start) {
+				fbsplash_putcs(vc, info, start, d - start, y, x);
+				x += d - start + 1;
+				start = d + 1;
+			} else {
+				x++;
+				start++;
+			}
+		}
+		s++;
+		d++;
+	} while (d < le);
+	if (d > start)
+		fbsplash_putcs(vc, info, start, d - start, y, x);
+}
+
+void fbsplash_blank(struct vc_data *vc, struct fb_info *info, int blank)
+{
+	if (blank) {
+		splashset((u8 *)info->screen_base, info->var.yres, info->var.xres,
+			  info->fix.line_length, 0, info->var.bits_per_pixel);
+	} else {
+		update_screen(vc);
+		fbsplash_clear_margins(vc, info, 0);
+	}
+}
+
diff --git a/drivers/video/console/bitblit.c b/drivers/video/console/bitblit.c
index eea422eb1a..f7eb28874b 100644
--- a/drivers/video/console/bitblit.c
+++ b/drivers/video/console/bitblit.c
@@ -18,6 +18,7 @@
 #include <linux/console.h>
 #include <asm/types.h>
 #include "fbcon.h"
+#include "../fbsplash.h"
 
 /*
  * Accelerated handlers.
@@ -55,6 +56,13 @@ static void bit_bmove(struct vc_data *vc, struct fb_info *info, int sy,
 	area.height = height * vc->vc_font.height;
 	area.width = width * vc->vc_font.width;
 
+	if (fbsplash_active(info, vc)) {
+ 		area.sx += vc->vc_splash.tx;
+ 		area.sy += vc->vc_splash.ty;
+ 		area.dx += vc->vc_splash.tx;
+ 		area.dy += vc->vc_splash.ty;
+ 	}
+
 	info->fbops->fb_copyarea(info, &area);
 }
 
@@ -380,11 +388,15 @@ static void bit_cursor(struct vc_data *vc, struct fb_info *info, int mode,
 	cursor.image.depth = 1;
 	cursor.rop = ROP_XOR;
 
-	if (info->fbops->fb_cursor)
-		err = info->fbops->fb_cursor(info, &cursor);
+	if (fbsplash_active(info, vc)) {
+		fbsplash_cursor(info, &cursor);
+	} else {
+		if (info->fbops->fb_cursor)
+			err = info->fbops->fb_cursor(info, &cursor);
 
-	if (err)
-		soft_cursor(info, &cursor);
+		if (err)
+			soft_cursor(info, &cursor);
+	}
 
 	ops->cursor_reset = 0;
 }
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index 041d069878..8c71e321ce 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -93,6 +93,7 @@
 #endif
 
 #include "fbcon.h"
+#include "../fbsplash.h"
 
 #ifdef FBCONDEBUG
 #  define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
@@ -108,7 +109,7 @@ enum {
 
 static struct display fb_display[MAX_NR_CONSOLES];
 
-static signed char con2fb_map[MAX_NR_CONSOLES];
+signed char con2fb_map[MAX_NR_CONSOLES];
 static signed char con2fb_map_boot[MAX_NR_CONSOLES];
 static int logo_height;
 static int logo_lines;
@@ -298,7 +299,7 @@ static inline int fbcon_is_inactive(struct vc_data *vc, struct fb_info *info)
 		vc->vc_mode != KD_TEXT || ops->graphics);
 }
 
-static inline int get_color(struct vc_data *vc, struct fb_info *info,
+inline int get_color(struct vc_data *vc, struct fb_info *info,
 	      u16 c, int is_fg)
 {
 	int depth = fb_get_color_depth(&info->var, &info->fix);
@@ -404,6 +405,7 @@ static void fb_flashcursor(void *private)
 		CM_ERASE : CM_DRAW;
 	ops->cursor(vc, info, mode, softback_lines, get_color(vc, info, c, 1),
 		    get_color(vc, info, c, 0));
+
 	release_console_sem();
 }
 
@@ -568,6 +570,8 @@ static int fbcon_takeover(int show_logo)
 		info_idx = -1;
 	}
 
+	fbsplash_init();
+
 	return err;
 }
 
@@ -971,6 +975,12 @@ static const char *fbcon_startup(void)
 	rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);
 	cols /= vc->vc_font.width;
 	rows /= vc->vc_font.height;
+
+	if (fbsplash_active(info, vc)) {
+		cols = vc->vc_splash.twidth / vc->vc_font.width;
+		rows = vc->vc_splash.theight / vc->vc_font.height;
+	}
+
 	vc_resize(vc, cols, rows);
 
 	DPRINTK("mode:   %s\n", info->fix.id);
@@ -1053,7 +1063,7 @@ static void fbcon_init(struct vc_data *vc, int init)
 	cap = info->flags;
 
 	if (vc != svc || logo_shown == FBCON_LOGO_DONTSHOW ||
-	    (info->fix.type == FB_TYPE_TEXT))
+	    (info->fix.type == FB_TYPE_TEXT) || fbsplash_active(info, vc))
 		logo = 0;
 
 	if (var_to_display(p, &info->var, info))
@@ -1193,6 +1203,11 @@ static void fbcon_clear(struct vc_data *vc, int sy, int sx, int height,
 	if (!height || !width)
 		return;
 
+ 	if (fbsplash_active(info, vc)) {
+ 		fbsplash_clear(vc, info, sy, sx, height, width);
+ 		return;
+ 	}
+
 	/* Split blits that cross physical y_wrap boundary */
 
 	y_break = p->vrows - p->yscroll;
@@ -1212,10 +1227,15 @@ static void fbcon_putcs(struct vc_data *vc, const unsigned short *s,
 	struct display *p = &fb_display[vc->vc_num];
 	struct fbcon_ops *ops = info->fbcon_par;
 
-	if (!fbcon_is_inactive(vc, info))
-		ops->putcs(vc, info, s, count, real_y(p, ypos), xpos,
-			   get_color(vc, info, scr_readw(s), 1),
-			   get_color(vc, info, scr_readw(s), 0));
+	if (!fbcon_is_inactive(vc, info)) {
+
+		if (fbsplash_active(info, vc))
+			fbsplash_putcs(vc, info, s, count, ypos, xpos);
+		else
+			ops->putcs(vc, info, s, count, real_y(p, ypos), xpos,
+				   get_color(vc, info, scr_readw(s), 1),
+				   get_color(vc, info, scr_readw(s), 0));
+	}
 }
 
 static void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)
@@ -1231,8 +1251,13 @@ static void fbcon_clear_margins(struct vc_data *vc, int bottom_only)
 	struct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];
 	struct fbcon_ops *ops = info->fbcon_par;
 
-	if (!fbcon_is_inactive(vc, info))
-		ops->clear_margins(vc, info, bottom_only);
+	if (!fbcon_is_inactive(vc, info)) {
+	 	if (fbsplash_active(info, vc)) {
+	 		fbsplash_clear_margins(vc, info, bottom_only);
+ 		} else {
+			ops->clear_margins(vc, info, bottom_only);
+		}
+	}
 }
 
 static void fbcon_cursor(struct vc_data *vc, int mode)
@@ -1705,7 +1730,7 @@ static int fbcon_scroll(struct vc_data *vc, int t, int b, int dir,
 			count = vc->vc_rows;
 		if (softback_top)
 			fbcon_softback_note(vc, t, count);
-		if (logo_shown >= 0)
+		if (logo_shown >= 0 || fbsplash_active(info, vc))
 			goto redraw_up;
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
@@ -1793,6 +1818,8 @@ static int fbcon_scroll(struct vc_data *vc, int t, int b, int dir,
 			count = vc->vc_rows;
 		if (logo_shown >= 0)
 			goto redraw_down;
+		if (fbsplash_active(info, vc))
+			goto redraw_down;
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
 			ops->bmove(vc, info, t, 0, t + count, 0,
@@ -1935,6 +1962,13 @@ static void fbcon_bmove_rec(struct vc_data *vc, struct display *p, int sy, int s
 		}
 		return;
 	}
+
+	if (fbsplash_active(info, vc) && sy == dy && height == 1) {
+ 		/* must use slower redraw bmove to keep background pic intact */
+ 		fbsplash_bmove_redraw(vc, info, sy, sx, dx, width);
+ 		return;
+ 	}
+
 	ops->bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,
 		   height, width);
 }
@@ -2005,8 +2039,9 @@ static int fbcon_resize(struct vc_data *vc, unsigned int width,
 	var.yres = virt_h * virt_fh;
 	x_diff = info->var.xres - var.xres;
 	y_diff = info->var.yres - var.yres;
-	if (x_diff < 0 || x_diff > virt_fw ||
-	    y_diff < 0 || y_diff > virt_fh) {
+
+	if ((x_diff < 0 || x_diff > virt_fw ||
+	    y_diff < 0 || y_diff > virt_fh) && !vc->vc_splash.state) {
 		struct fb_videomode *mode;
 
 		DPRINTK("attempting resize %ix%i\n", var.xres, var.yres);
@@ -2042,6 +2077,25 @@ static int fbcon_switch(struct vc_data *vc)
 
 	info = registered_fb[con2fb_map[vc->vc_num]];
 	ops = info->fbcon_par;
+	prev_console = ops->currcon;
+	if (prev_console != -1)
+		old_info = registered_fb[con2fb_map[prev_console]];
+
+	if (fbsplash_active_vc(vc)) {
+		struct vc_data *vc_curr = vc_cons[prev_console].d;
+		if (!vc_curr->vc_splash.theme || strcmp(vc->vc_splash.theme, vc_curr->vc_splash.theme)) {
+			if (fbsplash_call_helper("getpic", vc->vc_num))
+				fbsplash_disable(vc, 0);
+		}
+	} else if (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+		struct vc_data *vc_curr = vc_cons[prev_console].d;
+		if (vc_curr && fbsplash_active_vc(vc_curr)) {
+			/* Clear the screen to avoid displaying funky colors during
+			 * palette updates. */
+			memset((u8*)info->screen_base + info->fix.line_length * info->var.yoffset,
+			       0, info->var.yres * info->fix.line_length);
+		}
+	}
 
 	if (softback_top) {
 		if (softback_lines)
@@ -2060,9 +2114,6 @@ static int fbcon_switch(struct vc_data *vc)
 		logo_shown = FBCON_LOGO_CANSHOW;
 	}
 
-	prev_console = ops->currcon;
-	if (prev_console != -1)
-		old_info = registered_fb[con2fb_map[prev_console]];
 	/*
 	 * FIXME: If we have multiple fbdev's loaded, we need to
 	 * update all info->currcon.  Perhaps, we can place this
@@ -2104,6 +2155,11 @@ static int fbcon_switch(struct vc_data *vc)
 		}
 	}
 
+	if (fbsplash_active_nores(info, vc) && !fbsplash_active(info, vc)) {
+		if (fbsplash_call_helper("modechange", vc->vc_num))
+			fbsplash_disable(vc, 0);
+	}
+
 	set_blitting_type(vc, info);
 	ops->cursor_reset = 1;
 
@@ -2205,8 +2261,12 @@ static int fbcon_blank(struct vc_data *vc, int blank, int mode_switch)
 			fbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);
 			ops->cursor_flash = (!blank);
 
-			if (fb_blank(info, blank))
-				fbcon_generic_blank(vc, info, blank);
+			if (fb_blank(info, blank)) {
+				if (fbsplash_active(info, vc))
+					fbsplash_blank(vc, info, blank);
+				else
+					fbcon_generic_blank(vc, info, blank);
+			}
 		}
 
 		if (!blank)
@@ -2364,13 +2424,22 @@ static int fbcon_do_set_font(struct vc_data *vc, int w, int h,
 	}
 
 	if (resize) {
+		/* reset wrap/pan */
 		int cols, rows;
 
 		cols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);
 		rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);
+
+ 		info->var.xoffset = info->var.yoffset = p->yscroll = 0;
+		if (fbsplash_active(info, vc)) {
+			cols = vc->vc_splash.twidth;
+			rows = vc->vc_splash.theight;
+		}
 		cols /= w;
 		rows /= h;
+
 		vc_resize(vc, cols, rows);
+
 		if (CON_IS_VISIBLE(vc) && softback_buf)
 			fbcon_update_softback(vc);
 	} else if (CON_IS_VISIBLE(vc)
@@ -2488,7 +2557,7 @@ static int fbcon_set_palette(struct vc_data *vc, unsigned char *table)
 	int i, j, k, depth;
 	u8 val;
 
-	if (fbcon_is_inactive(vc, info))
+	if (fbcon_is_inactive(vc, info) || vc->vc_num != fg_console)
 		return -EINVAL;
 
 	if (!CON_IS_VISIBLE(vc))
@@ -2514,7 +2583,49 @@ static int fbcon_set_palette(struct vc_data *vc, unsigned char *table)
 	} else
 		fb_copy_cmap(fb_default_cmap(1 << depth), &palette_cmap);
 
-	return fb_set_cmap(&palette_cmap, info);
+	if (fbsplash_active(info, vc_cons[fg_console].d) &&
+	    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+
+		u16 *red, *green, *blue;
+		int minlen = min(min(info->var.red.length, info->var.green.length),
+				     info->var.blue.length);
+		int h;
+
+		struct fb_cmap cmap = {
+			.start = 0,
+			.len = (1 << minlen),
+			.red = NULL,
+			.green = NULL,
+			.blue = NULL,
+			.transp = NULL
+		};
+
+		red = kmalloc(256 * sizeof(u16) * 3, GFP_KERNEL);
+
+		if (!red)
+			goto out;
+
+		green = red + 256;
+		blue = green + 256;
+		cmap.red = red;
+		cmap.green = green;
+		cmap.blue = blue;
+
+		for (i = 0; i < cmap.len; i++) {
+			red[i] = green[i] = blue[i] = (0xffff * i)/(cmap.len-1);
+		}
+
+		h = fb_set_cmap(&cmap, info);
+		fbsplash_fix_pseudo_pal(info, vc_cons[fg_console].d);
+		kfree(red);
+
+		return h;
+
+	} else if (fbsplash_active(info, vc_cons[fg_console].d) &&
+		   info->var.bits_per_pixel == 8 && info->splash.cmap.red != NULL)
+		fb_set_cmap(&info->splash.cmap, info);
+
+out:	return fb_set_cmap(&palette_cmap, info);
 }
 
 static u16 *fbcon_screen_pos(struct vc_data *vc, int offset)
@@ -2740,7 +2851,14 @@ static void fbcon_modechanged(struct fb_info *info)
 		rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);
 		cols /= vc->vc_font.width;
 		rows /= vc->vc_font.height;
-		vc_resize(vc, cols, rows);
+
+		if (!fbsplash_active_nores(info, vc)) {
+			vc_resize(vc, cols, rows);
+		} else {
+			if (fbsplash_call_helper("modechange", vc->vc_num))
+				fbsplash_disable(vc, 0);
+		}
+
 		updatescrollmode(p, info, vc);
 		scrollback_max = 0;
 		scrollback_current = 0;
diff --git a/drivers/video/fbcmap.c b/drivers/video/fbcmap.c
index c32a2a50bf..f58ec89672 100644
--- a/drivers/video/fbcmap.c
+++ b/drivers/video/fbcmap.c
@@ -16,6 +16,7 @@
 #include <linux/tty.h>
 #include <linux/fb.h>
 #include <linux/slab.h>
+#include "fbsplash.h"
 
 #include <asm/uaccess.h>
 
@@ -240,9 +241,12 @@ int fb_set_cmap(struct fb_cmap *cmap, struct fb_info *info)
 				break;
 		}
 	}
-	if (rc == 0)
+	if (rc == 0) {
 		fb_copy_cmap(cmap, &info->cmap);
-
+		if (fbsplash_active(info, vc_cons[fg_console].d) &&
+		    info->fix.visual == FB_VISUAL_DIRECTCOLOR)
+			fbsplash_fix_pseudo_pal(info, vc_cons[fg_console].d);
+	}
 	return rc;
 }
 
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index b1b4d1342f..3dd9271878 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -1437,6 +1437,7 @@ fbmem_init(void)
 		printk(KERN_WARNING "Unable to create fb class; errno = %ld\n", PTR_ERR(fb_class));
 		fb_class = NULL;
 	}
+
 	return 0;
 }
 
diff --git a/drivers/video/fbsplash.c b/drivers/video/fbsplash.c
new file mode 100644
index 0000000000..3ea2d74982
--- /dev/null
+++ b/drivers/video/fbsplash.c
@@ -0,0 +1,406 @@
+/*
+ *  linux/drivers/video/fbsplash.c -- Framebuffer splash routines
+ *
+ *  Copyright (C) 2004 Michal Januszewski <spock@gentoo.org>
+ *
+ *  Code based upon "Bootsplash" (C) 2001-2003
+ *       Volker Poplawski <volker@poplawski.de>,
+ *       Stefan Reinauer <stepan@suse.de>,
+ *       Steffen Winterfeldt <snwint@suse.de>,
+ *       Michael Schroeder <mls@suse.de>,
+ *       Ken Wimer <wimer@suse.de>.
+ *
+ *  Splash render routines are located in /linux/drivers/video/cfbsplash.c
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <linux/vmalloc.h>
+#include <linux/unistd.h>
+#include <linux/syscalls.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/workqueue.h>
+#include <linux/kmod.h>
+#include <linux/miscdevice.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "console/fbcon.h"
+#include "fbsplash.h"
+
+#define SPLASH_VERSION 		"0.9.2"
+
+extern signed char con2fb_map[];
+static int fbsplash_enable(struct vc_data *vc);
+char fbsplash_path[KMOD_PATH_LEN] = "/sbin/splash_helper";
+
+int fbsplash_call_helper(char* cmd, unsigned short vc)
+{
+	char *envp[] = {
+		"HOME=/",
+		"PATH=/sbin:/bin",
+		NULL
+	};
+
+	char tfb[5];
+	char tcons[5];
+	unsigned char fb = (int) con2fb_map[vc];
+
+	char *argv[] = {
+		fbsplash_path,
+		"2",
+		cmd,
+		tcons,
+		tfb,
+		vc_cons[vc].d->vc_splash.theme,
+		NULL
+	};
+
+	snprintf(tfb,5,"%d",fb);
+	snprintf(tcons,5,"%d",vc);
+
+	return call_usermodehelper(fbsplash_path, argv, envp, 1);
+}
+
+/* Disables fbsplash on a virtual console; called with console sem held. */
+int fbsplash_disable(struct vc_data *vc, unsigned char redraw)
+{
+	struct fb_info* info;
+
+	if (!vc->vc_splash.state)
+		return -EINVAL;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+
+	if (info == NULL)
+		return -EINVAL;
+
+	vc->vc_splash.state = 0;
+	vc_resize(vc, info->var.xres / vc->vc_font.width,
+		  info->var.yres / vc->vc_font.height);
+
+	if (fg_console == vc->vc_num && redraw) {
+		redraw_screen(vc, 0);
+		update_region(vc, vc->vc_origin +
+			      vc->vc_size_row * vc->vc_top,
+			      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+	}
+
+	printk(KERN_INFO "fbsplash: switched splash state to 'off' on console %d\n",
+			 vc->vc_num);
+
+	return 0;
+}
+
+/* Enables fbsplash on a virtual console; called with console sem held. */
+static int fbsplash_enable(struct vc_data *vc)
+{
+	struct fb_info* info;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+
+	if (vc->vc_splash.twidth == 0 || vc->vc_splash.theight == 0 ||
+	    info == NULL || vc->vc_splash.state || (!info->splash.data &&
+	    vc->vc_num == fg_console))
+		return -EINVAL;
+
+	vc->vc_splash.state = 1;
+	vc_resize(vc, vc->vc_splash.twidth / vc->vc_font.width,
+		  vc->vc_splash.theight / vc->vc_font.height);
+
+	if (fg_console == vc->vc_num) {
+		redraw_screen(vc, 0);
+		update_region(vc, vc->vc_origin +
+			      vc->vc_size_row * vc->vc_top,
+			      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+		fbsplash_clear_margins(vc, info, 0);
+	}
+
+	printk(KERN_INFO "fbsplash: switched splash state to 'on' on console %d\n",
+			 vc->vc_num);
+
+	return 0;
+}
+
+static inline int fbsplash_ioctl_dosetstate(struct vc_data *vc, unsigned int __user* state, unsigned char origin)
+{
+	int tmp, ret;
+
+	if (get_user(tmp, state))
+		return -EFAULT;
+
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		acquire_console_sem();
+	if (!tmp)
+		ret = fbsplash_disable(vc, 1);
+	else
+		ret = fbsplash_enable(vc);
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		release_console_sem();
+
+	return ret;
+}
+
+static inline int fbsplash_ioctl_dogetstate(struct vc_data *vc, unsigned int __user *state)
+{
+	return put_user(vc->vc_splash.state, (unsigned int __user*) state);
+}
+
+static int fbsplash_ioctl_dosetcfg(struct vc_data *vc, struct vc_splash __user *arg, unsigned char origin)
+{
+	struct vc_splash cfg;
+	struct fb_info *info;
+	int len;
+	char *tmp;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+
+	if (copy_from_user(&cfg, arg, sizeof(struct vc_splash)))
+		return -EFAULT;
+	if (info == NULL || !cfg.twidth || !cfg.theight ||
+	    cfg.tx + cfg.twidth  > info->var.xres ||
+	    cfg.ty + cfg.theight > info->var.yres)
+		return -EINVAL;
+
+	len = strlen_user(cfg.theme);
+	if (!len || len > FB_SPLASH_THEME_LEN)
+		return -EINVAL;
+	tmp = kmalloc(len, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	if (copy_from_user(tmp, (void __user *)cfg.theme, len))
+		return -EFAULT;
+	cfg.theme = tmp;
+	cfg.state = 0;
+
+	/* If this ioctl is a response to a request from kernel, the console sem
+	 * is already held; we also don't need to disable splash because either the
+	 * new config and background picture will be successfully loaded, and the
+	 * splash will stay on, or in case of a failure it'll be turned off in fbcon. */
+	if (origin == FB_SPLASH_IO_ORIG_USER) {
+		acquire_console_sem();
+		if (vc->vc_splash.state)
+			fbsplash_disable(vc, 1);
+	}
+
+	if (vc->vc_splash.theme)
+		kfree(vc->vc_splash.theme);
+
+	vc->vc_splash = cfg;
+
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		release_console_sem();
+
+	printk(KERN_INFO "fbsplash: console %d using theme '%s'\n",
+			 vc->vc_num, vc->vc_splash.theme);
+	return 0;
+}
+
+static int fbsplash_ioctl_dogetcfg(struct vc_data *vc, struct vc_splash __user *arg)
+{
+	struct vc_splash splash;
+	char __user *tmp;
+
+	if (get_user(tmp, &arg->theme))
+		return -EFAULT;
+
+	splash = vc->vc_splash;
+	splash.theme = tmp;
+
+	if (vc->vc_splash.theme) {
+		if (copy_to_user(tmp, vc->vc_splash.theme, strlen(vc->vc_splash.theme) + 1))
+			return -EFAULT;
+	} else
+		if (put_user(0, tmp))
+			return -EFAULT;
+
+	if (copy_to_user(arg, &splash, sizeof(struct vc_splash)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int fbsplash_ioctl_dosetpic(struct vc_data *vc, struct fb_image __user *arg, unsigned char origin)
+{
+	struct fb_image img;
+	struct fb_info *info;
+	int len;
+	u8 *tmp;
+
+	if (vc->vc_num != fg_console)
+		return -EINVAL;
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+
+	if (info == NULL)
+		return -EINVAL;
+
+	if (copy_from_user(&img, arg, sizeof(struct fb_image)))
+		return -EFAULT;
+
+	if (img.width != info->var.xres || img.height != info->var.yres) {
+		printk(KERN_ERR "fbsplash: picture dimensions mismatch\n");
+		return -EINVAL;
+	}
+
+	if (img.depth != info->var.bits_per_pixel) {
+		printk(KERN_ERR "fbsplash: picture depth mismatch\n");
+		return -EINVAL;
+	}
+
+	if (img.depth == 8) {
+		if (!img.cmap.len || !img.cmap.red || !img.cmap.green ||
+		    !img.cmap.blue)
+			return -EINVAL;
+
+		tmp = vmalloc(img.cmap.len * 3 * 2);
+		if (!tmp)
+			return -ENOMEM;
+
+		if (copy_from_user(tmp, (void __user*)img.cmap.red, img.cmap.len * 2) ||
+		    copy_from_user(tmp + (img.cmap.len << 1),
+			    	   (void __user*)img.cmap.green, (img.cmap.len << 1)) ||
+		    copy_from_user(tmp + (img.cmap.len << 2),
+			    	   (void __user*)img.cmap.blue, (img.cmap.len << 1))) {
+			vfree(tmp);
+			return -EFAULT;
+		}
+
+		img.cmap.transp = NULL;
+		img.cmap.red = (u16*)tmp;
+		img.cmap.green = img.cmap.red + img.cmap.len;
+		img.cmap.blue = img.cmap.green + img.cmap.len;
+	} else {
+		img.cmap.red = NULL;
+	}
+
+	len = ((img.depth + 7) >> 3) * img.width * img.height;
+	tmp = vmalloc(len);
+
+	if (!tmp)
+		goto out;
+
+	if (copy_from_user(tmp, (void __user*)img.data, len))
+		goto out;
+
+	img.data = tmp;
+
+	/* If this ioctl is a response to a request from kernel, the console sem
+	 * is already held. */
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		acquire_console_sem();
+
+	if (info->splash.data)
+		vfree((u8*)info->splash.data);
+	if (info->splash.cmap.red)
+		vfree(info->splash.cmap.red);
+
+	info->splash = img;
+
+	if (origin == FB_SPLASH_IO_ORIG_USER)
+		release_console_sem();
+
+	return 0;
+
+out:	if (img.cmap.red)
+		vfree(img.cmap.red);
+	if (tmp)
+		vfree(tmp);
+	return -ENOMEM;
+}
+
+static int splash_ioctl(struct inode * inode, struct file *filp, u_int cmd,
+			u_long arg)
+{
+	struct fb_splash_iowrapper __user *wrapper = (void __user*) arg;
+	struct vc_data *vc = NULL;
+	unsigned short vc_num = 0;
+	unsigned char origin = 0;
+	void __user *data = NULL;
+
+	if (!access_ok(VERIFY_READ, wrapper,
+			sizeof(struct fb_splash_iowrapper)))
+		return -EFAULT;
+
+	__get_user(vc_num, &wrapper->vc);
+	__get_user(origin, &wrapper->origin);
+	__get_user(data, &wrapper->data);
+
+	if (!vc_cons_allocated(vc_num))
+		return -EINVAL;
+
+	vc = vc_cons[vc_num].d;
+
+	switch (cmd) {
+	case FBIOSPLASH_SETPIC:
+		return fbsplash_ioctl_dosetpic(vc, (struct fb_image __user*)data, origin);
+	case FBIOSPLASH_SETCFG:
+		return fbsplash_ioctl_dosetcfg(vc, (struct vc_splash*)data, origin);
+	case FBIOSPLASH_GETCFG:
+		return fbsplash_ioctl_dogetcfg(vc, (struct vc_splash*)data);
+	case FBIOSPLASH_SETSTATE:
+		return fbsplash_ioctl_dosetstate(vc, (unsigned int *)data, origin);
+	case FBIOSPLASH_GETSTATE:
+		return fbsplash_ioctl_dogetstate(vc, (unsigned int *)data);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+static struct file_operations splash_ops = {
+	.owner = THIS_MODULE,
+	.ioctl = splash_ioctl
+};
+
+static struct miscdevice splash_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "fbsplash",
+	.fops = &splash_ops
+};
+
+int fbsplash_init(void)
+{
+	struct fb_info *info;
+	struct vc_data *vc;
+	int i;
+
+	vc = vc_cons[0].d;
+	info = registered_fb[0];
+
+	for (i = 0; i < num_registered_fb; i++) {
+		registered_fb[i]->splash.data = NULL;
+		registered_fb[i]->splash.cmap.red = NULL;
+	}
+
+	for (i = 0; i < MAX_NR_CONSOLES && vc_cons[i].d; i++) {
+		vc_cons[i].d->vc_splash.state = vc_cons[i].d->vc_splash.twidth =
+						vc_cons[i].d->vc_splash.theight = 0;
+		vc_cons[i].d->vc_splash.theme = NULL;
+	}
+
+	i = misc_register(&splash_dev);
+	if (i) {
+		printk(KERN_ERR "fbsplash: failed to register device\n");
+		return i;
+	}
+
+	fbsplash_call_helper("init", 0);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(fbsplash_path);
diff --git a/drivers/video/fbsplash.h b/drivers/video/fbsplash.h
new file mode 100644
index 0000000000..186f000276
--- /dev/null
+++ b/drivers/video/fbsplash.h
@@ -0,0 +1,76 @@
+/*
+ *  linux/drivers/video/fbsplash.h -- Framebuffer splash headers
+ *
+ *  Copyright (C) 2004 Michal Januszewski <spock@gentoo.org>
+ *
+ */
+
+#ifndef __FB_SPLASH_H
+#define __FB_SPLASH_H
+
+#ifndef _LINUX_FB_H
+#include <linux/fb.h>
+#endif
+
+/* This is needed for vc_cons in fbcmap.c */
+#include <linux/vt_kern.h>
+
+struct fb_cursor;
+struct fb_info;
+struct vc_data;
+
+#ifdef CONFIG_FB_SPLASH
+/* fbsplash.c */
+int fbsplash_init(void);
+int fbsplash_call_helper(char* cmd, unsigned short cons);
+int fbsplash_disable(struct vc_data *vc, unsigned char redraw);
+
+/* cfbsplash.c */
+void fbsplash_putcs(struct vc_data *vc, struct fb_info *info, const unsigned short *s, int count, int yy, int xx);
+void fbsplash_cursor(struct fb_info *info, struct fb_cursor *cursor);
+void fbsplash_clear(struct vc_data *vc, struct fb_info *info, int sy, int sx, int height, int width);
+void fbsplash_clear_margins(struct vc_data *vc, struct fb_info *info, int bottom_only);
+void fbsplash_blank(struct vc_data *vc, struct fb_info *info, int blank);
+void fbsplash_bmove_redraw(struct vc_data *vc, struct fb_info *info, int y, int sx, int dx, int width);
+void fbsplash_copy(u8 *dst, u8 *src, int height, int width, int linebytes, int srclinesbytes, int bpp);
+void fbsplash_fix_pseudo_pal(struct fb_info *info, struct vc_data *vc);
+
+/* vt.c */
+void acquire_console_sem(void);
+void release_console_sem(void);
+void do_unblank_screen(int entering_gfx);
+
+/* struct vc_data *y */
+#define fbsplash_active_vc(y) (y->vc_splash.state && y->vc_splash.theme)
+
+/* struct fb_info *x, struct vc_data *y */
+#define fbsplash_active_nores(x,y) (x->splash.data && fbsplash_active_vc(y))
+
+/* struct fb_info *x, struct vc_data *y */
+#define fbsplash_active(x,y) (fbsplash_active_nores(x,y) &&		\
+			      x->splash.width == x->var.xres && 	\
+			      x->splash.height == x->var.yres &&	\
+			      x->splash.depth == x->var.bits_per_pixel)
+
+
+#else /* CONFIG_FB_SPLASH */
+
+static inline void fbsplash_putcs(struct vc_data *vc, struct fb_info *info, const unsigned short *s, int count, int yy, int xx) {}
+static inline void fbsplash_putc(struct vc_data *vc, struct fb_info *info, int c, int ypos, int xpos) {}
+static inline void fbsplash_cursor(struct fb_info *info, struct fb_cursor *cursor) {}
+static inline void fbsplash_clear(struct vc_data *vc, struct fb_info *info, int sy, int sx, int height, int width) {}
+static inline void fbsplash_clear_margins(struct vc_data *vc, struct fb_info *info, int bottom_only) {}
+static inline void fbsplash_blank(struct vc_data *vc, struct fb_info *info, int blank) {}
+static inline void fbsplash_bmove_redraw(struct vc_data *vc, struct fb_info *info, int y, int sx, int dx, int width) {}
+static inline void fbsplash_fix_pseudo_pal(struct fb_info *info, struct vc_data *vc) {}
+static inline int fbsplash_call_helper(char* cmd, unsigned short cons) { return 0; }
+static inline int fbsplash_init(void) { return 0; }
+static inline int fbsplash_disable(struct vc_data *vc, unsigned char redraw) { return 0; }
+
+#define fbsplash_active_vc(y) (0)
+#define fbsplash_active_nores(x,y) (0)
+#define fbsplash_active(x,y) (0)
+
+#endif /* CONFIG_FB_SPLASH */
+
+#endif /* __FB_SPLASH_H */
diff --git a/drivers/video/modedb.c b/drivers/video/modedb.c
index 244a21adc3..15e23cbf7f 100644
--- a/drivers/video/modedb.c
+++ b/drivers/video/modedb.c
@@ -671,6 +671,7 @@ void fb_var_to_videomode(struct fb_videomode *mode,
 {
 	u32 pixclock, hfreq, htotal, vtotal;
 
+	mode->refresh = 0;
 	mode->name = NULL;
 	mode->xres = var->xres;
 	mode->yres = var->yres;
diff --git a/drivers/video/vesafb-thread.c b/drivers/video/vesafb-thread.c
new file mode 100644
index 0000000000..c6efe8cddf
--- /dev/null
+++ b/drivers/video/vesafb-thread.c
@@ -0,0 +1,722 @@
+/*
+ * Framebuffer driver for VBE 2.0+ compliant graphic boards.
+ * Kernel thread and vm86 routines.
+ *
+ * (c) 2004-2005 Michal Januszewski <spock@gentoo.org>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/signal.h>
+#include <linux/suspend.h>
+#include <linux/unistd.h>
+#include <video/vesa.h>
+#include <video/edid.h>
+#include <asm/mman.h>
+#include <asm/page.h>
+#include <asm/vm86.h>
+#include <asm/thread_info.h>
+#include <asm/uaccess.h>
+#include <asm/mmu_context.h>
+#include "edid.h"
+
+#ifdef MODULE
+int errno;
+#endif
+
+static DECLARE_COMPLETION(vesafb_th_completion);
+static DECLARE_MUTEX(vesafb_task_list_sem);
+static LIST_HEAD(vesafb_task_list);
+static DECLARE_WAIT_QUEUE_HEAD(vesafb_wait);
+
+static struct vm86_struct vm86;
+static int vesafb_pid = 0;
+
+_syscall3(int,ioperm,unsigned long, a, unsigned long, b, unsigned long, c);
+_syscall1(int,vm86old,struct vm86_struct __user*, v86);
+
+#define DEFAULT_VM86_FLAGS (IF_MASK | IOPL_MASK)
+#define VM86_PUSHW(x)					\
+do { 							\
+	vm86.regs.esp -= 2; 				\
+	*(u16*)(STACK_ADDR + vm86.regs.esp) = x;	\
+} while(0);
+
+/* Stack, the return code and buffers will be put into
+ * one contiguous memory chunk:
+ *
+ * [ STACK | RET_CODE | BUFFER ]
+ *
+ * We only need a buffer that is ca. 0x2000 bytes in size.
+ * Some video BIOSes (sis6326) try to store data somewhere
+ * in 0x7000-0x7fff, so we zeromap more memory to be safe.
+ */
+#define IVTBDA_SIZE 	PAGE_SIZE
+#define RET_CODE_SIZE	0x0010
+#define STACK_SIZE	0x0500
+#define BUFFER_SIZE	0x10000
+
+/* The amount of memory that will be allocated should be a multiple
+ * of PAGE_SIZE. */
+#define __MEM_SIZE 	(RET_CODE_SIZE + STACK_SIZE + BUFFER_SIZE)
+#define REAL_MEM_SIZE	(((__MEM_SIZE / PAGE_SIZE) + 1) * PAGE_SIZE)
+
+#define IVTBDA_ADDR	0x00000
+#define STACK_ADDR	(IVTBDA_ADDR + IVTBDA_SIZE)
+#define RET_CODE_ADDR	(STACK_ADDR + STACK_SIZE)
+#define BUF_ADDR	(RET_CODE_ADDR + RET_CODE_SIZE)
+
+#define FLAG_D 		(1 << 10)
+
+/* Segment prefix opcodes */
+enum {
+	P_CS = 0x2e,
+	P_SS = 0x36,
+	P_DS = 0x3e,
+	P_ES = 0x26,
+	P_FS = 0x64,
+	P_GS = 0x65
+};
+
+/* Emulated vm86 ins instruction */
+static void vm86_ins(int size)
+{
+	u32 edx, edi;
+	edx = vm86.regs.edx & 0xffff;
+	edi = (vm86.regs.edi & 0xffff) + (u32)(vm86.regs.es << 4);
+
+	if (vm86.regs.eflags & FLAG_D)
+		asm volatile ("std\n");
+	else
+		asm volatile ("cld\n");
+
+	switch (size) {
+	case 4:
+		asm volatile ("insl\n" : "=D" (edi) : "d" (edx), "0" (edi));
+		break;
+	case 2:
+		asm volatile ("insw\n" : "=D" (edi) : "d" (edx), "0" (edi));
+		break;
+	case 1:
+		asm volatile ("insb\n" : "=D" (edi) : "d" (edx), "0" (edi));
+		break;
+	}
+
+	if (vm86.regs.eflags & FLAG_D)
+		asm volatile ("cld\n");
+
+	edi -= (u32)(vm86.regs.es << 4);
+
+	vm86.regs.edi &= 0xffff0000;
+	vm86.regs.edi |= edi & 0xffff;
+}
+
+static void vm86_rep_ins(int size)
+{
+	u16 cx = vm86.regs.ecx;
+	while (cx--)
+		vm86_ins(size);
+
+	vm86.regs.ecx &= 0xffff0000;
+}
+
+/* Emulated vm86 outs instruction */
+static void vm86_outs(int size, int segment)
+{
+	u32 edx, esi, base;
+
+	edx = vm86.regs.edx & 0xffff;
+	esi = vm86.regs.esi & 0xffff;
+
+	switch (segment) {
+	case P_CS: base = vm86.regs.cs; break;
+	case P_SS: base = vm86.regs.ss; break;
+	case P_ES: base = vm86.regs.es; break;
+	case P_FS: base = vm86.regs.fs; break;
+	case P_GS: base = vm86.regs.gs; break;
+	default:   base = vm86.regs.ds; break;
+	}
+
+	esi += base << 4;
+
+	if (vm86.regs.eflags & FLAG_D)
+		asm volatile ("std\n");
+	else
+		asm volatile ("cld\n");
+
+	switch (size) {
+	case 4:
+		asm volatile ("outsl\n" : "=S" (esi) : "d" (edx), "0" (esi));
+		break;
+	case 2:
+		asm volatile ("outsw\n" : "=S" (esi) : "d" (edx), "0" (esi));
+		break;
+	case 1:
+		asm volatile ("outsb\n" : "=S" (esi) : "d" (edx), "0" (esi));
+		break;
+	}
+
+	if (vm86.regs.eflags & FLAG_D)
+		asm volatile ("cld");
+
+	esi -= base << 4;
+	vm86.regs.esi &= 0xffff0000;
+	vm86.regs.esi |= (esi & 0xffff);
+}
+
+static void vm86_rep_outs(int size, int segment)
+{
+	u16 cx = vm86.regs.ecx;
+	while (cx--)
+		vm86_outs(size, segment);
+
+	vm86.regs.ecx &= 0xffff0000;
+}
+
+static int vm86_do_unknown(void)
+{
+	u8 data32 = 0, segment = P_DS, rep = 0;
+	u8 *instr;
+	int ret = 0, i = 0;
+
+	instr = (u8*)((vm86.regs.cs << 4) + vm86.regs.eip);
+
+	while (1) {
+		switch(instr[i]) {
+		case 0x66:	/* operand size prefix */
+			data32 = 1 - data32;
+			i++;
+			break;
+		case 0xf2:	/* repnz */
+		case 0xf3:	/* rep */
+			rep = 1;
+			i++;
+			break;
+		case P_CS:	/* segment prefix */
+		case P_SS:
+		case P_DS:
+		case P_ES:
+		case P_FS:
+		case P_GS:
+			segment = instr[i];
+			i++;
+			break;
+		case 0xf0:	/* LOCK - ignored */
+		case 0x67:	/* address size prefix - ignored */
+			i++;
+			break;
+		case 0x6c:	/* insb */
+			if (rep)
+				vm86_rep_ins(1);
+			else
+				vm86_ins(1);
+			i++;
+			goto out;
+		case 0x6d:	/* insw / insd */
+			if (rep) {
+				if (data32)
+					vm86_rep_ins(4);
+				else
+					vm86_rep_ins(2);
+			} else {
+				if (data32)
+					vm86_ins(4);
+				else
+					vm86_ins(2);
+			}
+			i++;
+			goto out;
+		case 0x6e:	/* outsb */
+			if (rep)
+				vm86_rep_outs(1, segment);
+			else
+				vm86_outs(1, segment);
+			i++;
+			goto out;
+		case 0x6f:	/* outsw / outsd */
+			if (rep) {
+				if (data32)
+					vm86_rep_outs(4, segment);
+				else
+					vm86_rep_outs(2, segment);
+			} else {
+				if (data32)
+					vm86_outs(4, segment);
+				else
+					vm86_outs(2, segment);
+			}
+			i++;
+			goto out;
+		case 0xe4:	/* inb xx */
+			asm volatile (
+				"inb %w1, %b0"
+				: "=a" (vm86.regs.eax)
+				: "d" (instr[i+1]), "0" (vm86.regs.eax));
+			i += 2;
+			goto out;
+		case 0xe5:	/* inw xx / ind xx */
+			if (data32) {
+				asm volatile (
+					"inl %w1, %0"
+					: "=a" (vm86.regs.eax)
+					: "d" (instr[i+1]),
+					  "0" (vm86.regs.eax));
+			} else {
+				asm volatile (
+					"inw %w1, %w0"
+					: "=a" (vm86.regs.eax)
+					: "d" (instr[i+1]),
+					  "0" (vm86.regs.eax));
+			}
+			i += 2;
+			goto out;
+
+		case 0xec:	/* inb dx */
+			asm volatile (
+				"inb %w1, %b0"
+	 			: "=a" (vm86.regs.eax)
+				: "d" (vm86.regs.edx), "0" (vm86.regs.eax));
+			i++;
+			goto out;
+		case 0xed:	/* inw dx / ind dx */
+			if (data32) {
+				asm volatile (
+					"inl %w1, %0"
+					: "=a" (vm86.regs.eax)
+					: "d" (vm86.regs.edx));
+			} else {
+				asm volatile (
+					"inw %w1, %w0"
+					: "=a" (vm86.regs.eax)
+					: "d" (vm86.regs.edx));
+			}
+			i++;
+			goto out;
+		case 0xe6:	/* outb xx */
+			asm volatile (
+				"outb %b0, %w1"
+				: /* no return value */
+				: "a" (vm86.regs.eax), "d" (instr[i+1]));
+			i += 2;
+			goto out;
+		case 0xe7:	/* outw xx / outd xx */
+			if (data32) {
+				asm volatile (
+					"outl %0, %w1"
+					: /* no return value */
+					: "a" (vm86.regs.eax),
+					  "d" (instr[i+1]));
+			} else {
+				asm volatile (
+					"outw %w0, %w1"
+					: /* no return value */
+					: "a" (vm86.regs.eax),
+					  "d" (instr[i+1]));
+			}
+			i += 2;
+			goto out;
+		case 0xee:	/* outb dx */
+			asm volatile (
+				"outb %b0, %w1"
+				: /* no return value */
+				: "a" (vm86.regs.eax), "d" (vm86.regs.edx));
+			i++;
+			goto out;
+		case 0xef:	/* outw dx / outd dx */
+			if (data32) {
+				asm volatile (
+					"outl %0, %w1"
+					: /* no return value */
+					: "a" (vm86.regs.eax),
+					  "d" (vm86.regs.edx));
+			} else {
+				asm volatile (
+					"outw %w0, %w1"
+					: /* no return value */
+					: "a" (vm86.regs.eax),
+					  "d" (vm86.regs.edx));
+			}
+			i++;
+			goto out;
+		default:
+			printk(KERN_ERR "vesafb: BUG, opcode 0x%x emulation "
+					"not supported (EIP: 0x%lx)\n",
+					instr[i], (u32)(vm86.regs.cs << 4) +
+					vm86.regs.eip);
+			ret = 1;
+			goto out;
+		}
+	}
+out: 	vm86.regs.eip += i;
+	return ret;
+}
+
+void vesafb_do_vm86(struct vm86_regs *regs)
+{
+	unsigned int ret;
+	u8 *retcode = (void*)RET_CODE_ADDR;
+
+	memset(&vm86,0,sizeof(vm86));
+	memcpy(&vm86.regs, regs, sizeof(struct vm86_regs));
+
+	/* The return code */
+	retcode[0] = 0xcd;  		/* int opcode */
+	retcode[1] = 0xff;		/* int number (255) */
+
+        /* We use int 0xff to get back to protected mode */
+	memset(&vm86.int_revectored, 0, sizeof(vm86.int_revectored));
+        ((unsigned char *)&vm86.int_revectored)[0xff / 8] |= (1 << (0xff % 8));
+
+	/*
+	 * We want to call int 0x10, so we set:
+	 *   CS = 0x42 = 0x10 * 4 + 2
+	 *   IP = 0x40 = 0x10 * 4
+	 * and SS:ESP. It's up to the caller to set the rest of the registers.
+	 */
+	vm86.regs.eflags = DEFAULT_VM86_FLAGS;
+	vm86.regs.cs = *(unsigned short *)0x42;
+	vm86.regs.eip = *(unsigned short *)0x40;
+	vm86.regs.ss = (STACK_ADDR >> 4);
+	vm86.regs.esp = ((STACK_ADDR & 0x0000f) + STACK_SIZE);
+
+	/* These will be fetched off the stack when we come to an iret in the
+	 * int's 0x10 code. */
+	VM86_PUSHW(DEFAULT_VM86_FLAGS);
+	VM86_PUSHW((RET_CODE_ADDR >> 4));	/* return code segment */
+	VM86_PUSHW((RET_CODE_ADDR & 0x0000f));	/* return code offset */
+
+	while(1) {
+		ret = vm86old(&vm86);
+
+		if (VM86_TYPE(ret) == VM86_INTx) {
+			int vint = VM86_ARG(ret);
+
+			/* If exit from vm86 was caused by int 0xff, then
+			 * we're done.. */
+			if (vint == 0xff)
+				goto out;
+
+			/* .. otherwise, we have to call the int handler
+			 * manually */
+			VM86_PUSHW(vm86.regs.eflags);
+			VM86_PUSHW(vm86.regs.cs);
+			VM86_PUSHW(vm86.regs.eip);
+
+			vm86.regs.cs = *(u16 *)((vint << 2) + 2);
+			vm86.regs.eip = *(u16 *)(vint << 2);
+			vm86.regs.eflags &= ~(VIF_MASK | TF_MASK);
+		} else if (VM86_TYPE(ret) == VM86_UNKNOWN) {
+			if (vm86_do_unknown())
+				goto out;
+		} else {
+			printk(KERN_ERR "vesafb: BUG, returned from "
+					"vm86 with %x (EIP: 0x%lx)\n",
+					ret, (u32)(vm86.regs.cs << 4) +
+					vm86.regs.eip);
+			goto out;
+		}
+	}
+
+out:	/* copy the registers' state back to the caller's struct */
+	memcpy(regs, &vm86.regs, sizeof(struct vm86_regs));
+}
+
+static int vesafb_remap_pfn_range(unsigned long start, unsigned long end,
+				  unsigned long pgoff, unsigned long prot,
+				  int type)
+{
+	struct vm_area_struct *vma;
+	struct mm_struct *mm = current->mm;
+	int ret = 0;
+
+	vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+	if (!vma)
+		return -ENOMEM;
+	memset(vma, 0, sizeof(*vma));
+	down_write(&mm->mmap_sem);
+	vma->vm_mm = mm;
+	vma->vm_start = start;
+	vma->vm_end = end;
+	vma->vm_flags = VM_READ | VM_WRITE | VM_EXEC;
+	vma->vm_flags |= mm->def_flags;
+	vma->vm_page_prot.pgprot = prot;
+	vma->vm_pgoff = pgoff;
+
+	if ((ret = insert_vm_struct(mm, vma))) {
+		up_write(&mm->mmap_sem);
+		kmem_cache_free(vm_area_cachep, vma);
+		return ret;
+	}
+
+	if (type) {
+		vma->vm_flags |= VM_SHARED;
+		ret = zeromap_page_range(vma,
+					 vma->vm_start,
+					 vma->vm_end - vma->vm_start,
+					 vma->vm_page_prot);
+	} else {
+		ret = remap_pfn_range(vma,
+				      vma->vm_start,
+				      vma->vm_pgoff,
+				      vma->vm_end - vma->vm_start,
+				      vma->vm_page_prot);
+	}
+	up_write(&mm->mmap_sem);
+	return ret;
+}
+
+static inline int vesafb_init_mem(void)
+{
+	int ret = 0;
+
+	/* The memory chunks we're remapping here should be multiples
+	 * of PAGE_SIZE. */
+	ret += vesafb_remap_pfn_range(0x00000, IVTBDA_SIZE, 0,
+				      PROT_READ | PROT_EXEC | PROT_WRITE, 0);
+	ret += vesafb_remap_pfn_range(IVTBDA_SIZE, REAL_MEM_SIZE, 0,
+				      PROT_READ | PROT_EXEC | PROT_WRITE, 1);
+	ret += vesafb_remap_pfn_range(0x9f000, 0x100000,
+				      0x9f000 >> PAGE_SHIFT,
+				      PROT_READ | PROT_EXEC | PROT_WRITE, 0);
+	if (ret)
+		printk(KERN_ERR "vesafb thread: memory remapping failed\n");
+
+	return ret;
+}
+
+#define vesafb_get_string(str) \
+{ 									\
+	/* The address is in the form ssssoooo, where oooo = offset,	\
+	 * ssss = segment */						\
+	addr = ((p_vbe(tsk->buf)->str & 0xffff0000) >> 12) +		\
+		(p_vbe(tsk->buf)->str & 0x0000ffff);			\
+									\
+	/* The data is in ROM which is shared between processes, so we 	\
+	 * just translate the real mode address into one visible from 	\
+	 * kernel space */						\
+	if (addr >= 0xa0000) {						\
+		p_vbe(tsk->buf)->str = (u32) __va(addr);		\
+									\
+	/* The data is in the buffer, we just have to convert the	\
+	 * address so that it points into the buffer user provided. */	\
+	} else if (addr > BUF_ADDR && addr < BUF_ADDR +			\
+		   sizeof(struct vesafb_vbe_ib)) {			\
+		addr -= BUF_ADDR;					\
+		p_vbe(tsk->buf)->str = (u32) (tsk->buf + addr);		\
+									\
+	/* This should never happen: someone was insane enough to put	\
+	 * the data somewhere in RAM.. */				\
+	} else {							\
+		p_vbe(tsk->buf)->str = (u32) "";			\
+	}								\
+}
+
+void vesafb_handle_getvbeib(struct vesafb_task *tsk)
+{
+	int addr, res;
+
+	tsk->regs.es  = (BUF_ADDR >> 4);
+	tsk->regs.edi = (BUF_ADDR & 0x000f);
+	strncpy(p_vbe(BUF_ADDR)->vbe_signature, "VBE2", 4);
+
+	vesafb_do_vm86(&tsk->regs);
+	memcpy(tsk->buf, (void*)(BUF_ADDR), sizeof(struct vesafb_vbe_ib));
+
+	/* The OEM fields were not defined prior to VBE 2.0 */
+	if (p_vbe(tsk->buf)->vbe_version >= 0x200) {
+		vesafb_get_string(oem_string_ptr);
+		vesafb_get_string(oem_vendor_name_ptr);
+		vesafb_get_string(oem_product_name_ptr);
+		vesafb_get_string(oem_product_rev_ptr);
+	}
+
+	/* This is basically the same as vesafb_get_string() */
+	addr = ((p_vbe(tsk->buf)->mode_list_ptr & 0xffff0000) >> 12) +
+		(p_vbe(tsk->buf)->mode_list_ptr & 0x0000ffff);
+
+	if (addr >= 0xa0000) {
+		p_vbe(tsk->buf)->mode_list_ptr = (u32) __va(addr);
+	} else if (addr > BUF_ADDR && addr < BUF_ADDR +
+		   sizeof(struct vesafb_vbe_ib)) {
+		addr -= BUF_ADDR;
+		p_vbe(tsk->buf)->mode_list_ptr = (u32) (tsk->buf + addr);
+	} else {
+		res = 0;
+		printk(KERN_WARNING "vesafb: warning, copying modelist "
+				    "from somewhere in RAM!\n");
+		while (*(u16*)(addr+res) != 0xffff &&
+		       res < (sizeof(p_vbe(tsk->buf)->reserved) - 2)) {
+			*(u16*) ((u32)&(p_vbe(tsk->buf)->reserved) + res) =
+				*(u16*)(addr+res);
+			res += 2;
+		}
+		*(u16*) ((u32)&(p_vbe(tsk->buf)->reserved) + res) = 0xffff;
+	}
+}
+
+int vesafb_handle_tasks(void)
+{
+	struct vesafb_task *tsk;
+	struct list_head *curr, *next;
+	int ret = 0;
+
+	down(&vesafb_task_list_sem);
+	list_for_each_safe(curr, next, &vesafb_task_list) {
+		tsk = list_entry(curr, struct vesafb_task, node);
+
+		if (tsk->flags & TF_EXIT) {
+			ret = 1;
+			goto task_done;
+		}
+		if (tsk->flags & TF_GETVBEIB) {
+			vesafb_handle_getvbeib(tsk);
+			goto task_done;
+		}
+		if (tsk->flags & TF_MASK_BUF) {
+			tsk->regs.es  = (BUF_ADDR >> 4);
+			tsk->regs.edi = (BUF_ADDR & 0x000f);
+		}
+		if (tsk->flags & TF_USE_BUF)
+			memcpy((void*)BUF_ADDR, tsk->buf, tsk->buf_len);
+
+		vesafb_do_vm86(&tsk->regs);
+
+		if (tsk->flags & TF_RETURN_BUF)
+			memcpy(tsk->buf, (void*)BUF_ADDR, tsk->buf_len);
+
+task_done:	list_del(curr);
+		complete(&tsk->done);
+	}
+
+	/* If we're going to kill this thread, don't allow any elements
+	 * to be added to the task list. */
+	if (!ret)
+		up(&vesafb_task_list_sem);
+
+	return ret;
+}
+
+/*
+ * This 'hybrid' thread serves as a backend for vesafb-tng, handling all vm86
+ * calls. It is started as a kernel thread. It then creates its own mm struct,
+ * thus separating itself from any userspace processes. At this moment, it
+ * stops being a kernel thread (kernel threads have mm = NULL) and becomes
+ * a 'hybrid' thread -- one that has full access to kernel space, yet runs
+ * with its own address space.
+ *
+ * This is necessary because in order to make vm86 calls some parts of the
+ * first 1MB of RAM have to be setup to mimic the real mode. These are:
+ *  - interrupt vector table	[0x00000-0x003ff]
+ *  - BIOS data area		[0x00400-0x004ff]
+ *  - Extended BIOS data area	[0x9fc00-0x9ffff]
+ *  - the video RAM		[0xa0000-0xbffff]
+ *  - video BIOS		[0xc0000-0xcffff]
+ *  - motherboard BIOS		[0xf0000-0xfffff]
+ */
+int vesafb_thread(void *unused)
+{
+	int err = 0;
+
+	set_fs(KERNEL_DS);
+	daemonize("vesafb");
+
+	if (set_new_mm()) {
+		err = -ENOMEM;
+		goto thr_end;
+	}
+	if (vesafb_init_mem()) {
+		err = -ENOMEM;
+		goto thr_end;
+	}
+
+	DPRINTK("started vesafb thread\n");
+
+	/* Having an IO bitmap makes things faster as we avoid GPFs
+	 * when running vm86 code. We can live if it fails, though,
+	 * so don't bother checking for errors. */
+	ioperm(0,1024,1);
+	set_user_nice(current, -10);
+
+	complete(&vesafb_th_completion);
+
+	while (1) {
+		if (vesafb_handle_tasks())
+			break;
+		wait_event_interruptible(vesafb_wait,
+					 !list_empty(&vesafb_task_list));
+		try_to_freeze();
+	}
+
+out:	DPRINTK("exiting the vesafb thread\n");
+	vesafb_pid = -1;
+
+	/* Now that all callers know this thread is no longer running
+	 * (pid < 0), allow them to continue. */
+	up(&vesafb_task_list_sem);
+	return err;
+thr_end:
+	down(&vesafb_task_list_sem);
+	complete(&vesafb_th_completion);
+	goto out;
+}
+
+int vesafb_queue_task(struct vesafb_task *tsk)
+{
+	down(&vesafb_task_list_sem);
+	if (vesafb_pid < 0)
+		return -1;
+	list_add_tail(&tsk->node, &vesafb_task_list);
+	up(&vesafb_task_list_sem);
+	wake_up(&vesafb_wait);
+	return 0;
+}
+
+int vesafb_wait_for_thread(void)
+{
+	/* PID 0 means that the thread is still initializing. */
+	if (vesafb_pid < 0)
+		return -1;
+	wait_for_completion(&vesafb_th_completion);
+	return 0;
+}
+
+int __init vesafb_init_thread(void)
+{
+	vesafb_pid = kernel_thread(vesafb_thread,NULL,0);
+	return 0;
+}
+
+#ifdef MODULE
+void __exit vesafb_kill_thread(void)
+{
+	struct vesafb_task *tsk;
+	if (vesafb_pid <= 0)
+		return;
+
+	vesafb_create_task(tsk);
+	if (!tsk)
+		return;
+	tsk->flags |= TF_EXIT;
+	vesafb_queue_task(tsk);
+	vesafb_wait_for_task(tsk);
+	kfree(tsk);
+	return;
+}
+module_exit(vesafb_kill_thread);
+#endif
+module_init(vesafb_init_thread);
+
+EXPORT_SYMBOL_GPL(vesafb_queue_task);
+EXPORT_SYMBOL_GPL(vesafb_wait_for_thread);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Januszewski");
+
diff --git a/drivers/video/vesafb-tng.c b/drivers/video/vesafb-tng.c
new file mode 100644
index 0000000000..c800c7fb7c
--- /dev/null
+++ b/drivers/video/vesafb-tng.c
@@ -0,0 +1,1478 @@
+/*
+ * Framebuffer driver for VBE 2.0+ compliant graphic boards
+ *
+ * (c) 2004-2005 Michal Januszewski <spock@gentoo.org
+ *     Based upon vesafb code by Gerd Knorr <kraxel@goldbach.in-berlin.de
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <video/edid.h>
+#include <video/vesa.h>
+#include <video/vga.h>
+#include <asm/io.h>
+#include <asm/mtrr.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include "edid.h"
+
+#define dac_reg	(0x3c8)
+#define dac_val	(0x3c9)
+
+#define VESAFB_NEED_EXACT_RES 	1
+#define VESAFB_NEED_EXACT_DEPTH 2
+
+/* --------------------------------------------------------------------- */
+
+static struct fb_var_screeninfo vesafb_defined __initdata = {
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= 0,
+	.width		= 0,
+	.right_margin	= 32,
+	.upper_margin	= 16,
+	.lower_margin	= 4,
+	.vsync_len	= 4,
+	.vmode		= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo vesafb_fix __initdata = {
+	.id	= "VESA VGA",
+	.type	= FB_TYPE_PACKED_PIXELS,
+	.accel	= FB_ACCEL_NONE,
+};
+
+static int  mtrr       = 0;	/* disable mtrr by default */
+static int  ypan       = 0;	/* 0 - nothing, 1 - ypan, 2 - ywrap */
+static int  pmi_setpal = 0;	/* pmi for palette changes */
+static u16  *pmi_base  = NULL;  /* protected mode interface location */
+static void (*pmi_start)(void) = NULL;
+static void (*pmi_pal)(void)   = NULL;
+static struct vesafb_vbe_ib  vbe_ib;
+static struct vesafb_mode_ib *vbe_modes;
+static int                   vbe_modes_cnt = 0;
+static struct fb_info	     *vesafb_info = NULL;
+static int  nocrtc		    = 0; /* ignore CRTC settings */
+static int  noedid       __initdata = 0; /* don't try DDC transfers */
+static int  vram_remap   __initdata = 0; /* set amount of memory to be used */
+static int  vram_total   __initdata = 0; /* set total amount of memory */
+static u16  maxclk       __initdata = 0; /* maximum pixel clock */
+static u16  maxvf        __initdata = 0; /* maximum vertical frequency */
+static u16  maxhf        __initdata = 0; /* maximum horizontal frequency */
+static int  gtf          __initdata = 0; /* forces use of the GTF */
+static char *mode_option __initdata = NULL;
+static u16  vbemode      __initdata = 0;
+
+/* --------------------------------------------------------------------- */
+
+static int vesafb_find_vbe_mode(int xres, int yres, int depth,
+				unsigned char flags)
+{
+	int i, match = -1, h = 0, d = 0x7fffffff;
+
+	for (i = 0; i < vbe_modes_cnt; i++) {
+		h = abs(vbe_modes[i].x_res - xres) +
+		    abs(vbe_modes[i].y_res - yres) +
+		    abs(depth - vbe_modes[i].depth);
+		if (h == 0)
+			return i;
+		if (h < d || (h == d && vbe_modes[i].depth > depth)) {
+			d = h;
+			match = i;
+		}
+	}
+	i = 1;
+
+	if (flags & VESAFB_NEED_EXACT_DEPTH && vbe_modes[match].depth != depth)
+		i = 0;
+	if (flags & VESAFB_NEED_EXACT_RES && d > 24)
+		i = 0;
+	if (i != 0)
+		return match;
+	else
+		return -1;
+}
+
+static int vesafb_pan_display(struct fb_var_screeninfo *var,
+                              struct fb_info *info)
+{
+	int offset;
+
+	if (!ypan)
+		return -EINVAL;
+	if (var->xoffset)
+		return -EINVAL;
+	if (var->yoffset > var->yres_virtual)
+		return -EINVAL;
+	if ((ypan==1) && var->yoffset+var->yres > var->yres_virtual)
+		return -EINVAL;
+
+	offset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;
+
+	/* It turns out it's not the best idea to do panning via vm86,
+	 * so we only allow it if we have a PMI. */
+	if (pmi_start) {
+		__asm__ __volatile__(
+			"call *(%%edi)"
+			: /* no return value */
+			: "a" (0x4f07),         /* EAX */
+			  "b" (0),              /* EBX */
+			  "c" (offset),         /* ECX */
+			  "d" (offset >> 16),   /* EDX */
+			  "D" (&pmi_start));    /* EDI */
+	}
+	return 0;
+}
+
+static int vesafb_blank(int blank, struct fb_info *info)
+{
+	struct vesafb_task *tsk;
+	int err = 1;
+
+	if (vbe_ib.capabilities & VBE_CAP_VGACOMPAT) {
+		int loop = 10000;
+		u8 seq = 0, crtc17 = 0;
+
+		if (blank == FB_BLANK_POWERDOWN) {
+			seq = 0x20;
+			crtc17 = 0x00;
+			err = 0;
+		} else {
+			seq = 0x00;
+			crtc17 = 0x80;
+			err = (blank == FB_BLANK_UNBLANK) ? 0 : -EINVAL;
+		}
+
+		vga_wseq(NULL, 0x00, 0x01);
+		seq |= vga_rseq(NULL, 0x01) & ~0x20;
+		vga_wseq(NULL, 0x00, seq);
+
+		crtc17 |= vga_rcrt(NULL, 0x17) & ~0x80;
+		while (loop--);
+		vga_wcrt(NULL, 0x17, crtc17);
+		vga_wseq(NULL, 0x00, 0x03);
+	} else {
+		vesafb_create_task (tsk);
+		if (!tsk)
+			return -ENOMEM;
+		tsk->regs.eax = 0x4f10;
+		switch (blank) {
+		case FB_BLANK_UNBLANK:
+			tsk->regs.ebx = 0x0001;
+			break;
+		case FB_BLANK_NORMAL:
+			tsk->regs.ebx = 0x0101;	/* standby */
+			break;
+		case FB_BLANK_POWERDOWN:
+			tsk->regs.ebx = 0x0401;	/* powerdown */
+			break;
+		default:
+			goto out;
+		}
+		tsk->flags = TF_CALL;
+		if (!vesafb_queue_task (tsk))
+			vesafb_wait_for_task(tsk);
+
+		if ((tsk->regs.eax & 0xffff) == 0x004f)
+			err = 0;
+out:		kfree(tsk);
+	}
+	return err;
+}
+
+static int vesafb_setpalette(struct vesafb_pal_entry *entries, int count,
+			     int start, struct fb_info *info)
+{
+	struct vesafb_task *tsk;
+	int i = ((struct vesafb_par*)info->par)->mode_idx;
+	int ret = 0;
+
+	/* We support palette modifications for 8 bpp modes only, so
+	 * there can never be more than 256 entries. */
+	if (start + count > 256)
+		return -EINVAL;
+
+	if (pmi_setpal) {
+		__asm__ __volatile__(
+		"call *(%%esi)"
+		: /* no return value */
+		: "a" (0x4f09),         /* EAX */
+		  "b" (0),              /* EBX */
+		  "c" (count),          /* ECX */
+		  "d" (start),          /* EDX */
+		  "D" (entries),        /* EDI */
+		  "S" (&pmi_pal));      /* ESI */
+		return 0;
+	}
+
+	/* Use VGA registers if mode is VGA-compatible. */
+	if (i >= 0 && i < vbe_modes_cnt &&
+	    vbe_modes[i].mode_attr & VBE_MODE_VGACOMPAT) {
+		for (i = 0; i < count; i++) {
+			outb_p(start + i,        dac_reg);
+			outb_p(entries[i].red,   dac_val);
+			outb_p(entries[i].green, dac_val);
+			outb_p(entries[i].blue,  dac_val);
+		}
+	} else {
+		vesafb_create_task (tsk);
+		if (!tsk)
+			return -ENOMEM;
+		tsk->regs.eax = 0x4f09;
+		tsk->regs.ebx = 0x0;
+		tsk->regs.ecx = count;
+		tsk->regs.edx = start;
+		tsk->buf = entries;
+		tsk->buf_len = sizeof(struct vesafb_pal_entry) * count;
+		tsk->flags = TF_CALL | TF_USE_BUF;
+
+		if (!vesafb_queue_task (tsk))
+			vesafb_wait_for_task(tsk);
+		if ((tsk->regs.eax & 0xffff) != 0x004f)
+			ret = 1;
+		kfree(tsk);
+	}
+	return ret;
+}
+
+static int vesafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			    unsigned blue, unsigned transp,
+			    struct fb_info *info)
+{
+	struct vesafb_pal_entry entry;
+	int shift = 16 - info->var.green.length;
+	int ret = 0;
+
+	if (regno >= info->cmap.len)
+		return -EINVAL;
+
+	if (info->var.bits_per_pixel == 8) {
+		entry.red   = red   >> shift;
+		entry.green = green >> shift;
+		entry.blue  = blue  >> shift;
+		entry.pad   = 0;
+
+		ret = vesafb_setpalette(&entry, 1, regno, info);
+	} else if (regno < 16) {
+		switch (info->var.bits_per_pixel) {
+		case 16:
+			if (info->var.red.offset == 10) {
+				/* 1:5:5:5 */
+				((u32*) (info->pseudo_palette))[regno] =
+						((red   & 0xf800) >>  1) |
+						((green & 0xf800) >>  6) |
+						((blue  & 0xf800) >> 11);
+			} else {
+				/* 0:5:6:5 */
+				((u32*) (info->pseudo_palette))[regno] =
+						((red   & 0xf800)      ) |
+						((green & 0xfc00) >>  5) |
+						((blue  & 0xf800) >> 11);
+			}
+			break;
+
+		case 24:
+		case 32:
+			red   >>= 8;
+			green >>= 8;
+			blue  >>= 8;
+			((u32 *)(info->pseudo_palette))[regno] =
+				(red   << info->var.red.offset)   |
+				(green << info->var.green.offset) |
+				(blue  << info->var.blue.offset);
+			break;
+		}
+	}
+	return ret;
+}
+
+static int vesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	struct vesafb_pal_entry *entries;
+	int shift = 16 - info->var.green.length;
+	int i, ret = 0;
+
+	if (info->var.bits_per_pixel == 8) {
+		if (cmap->start + cmap->len > info->cmap.start +
+		    info->cmap.len || cmap->start < info->cmap.start)
+			return -EINVAL;
+
+		entries = vmalloc(sizeof(struct vesafb_pal_entry) * cmap->len);
+		if (!entries)
+			return -ENOMEM;
+		for (i = 0; i < cmap->len; i++) {
+			entries[i].red   = cmap->red[i]   >> shift;
+			entries[i].green = cmap->green[i] >> shift;
+			entries[i].blue  = cmap->blue[i]  >> shift;
+			entries[i].pad   = 0;
+		}
+		ret = vesafb_setpalette(entries, cmap->len, cmap->start, info);
+		vfree(entries);
+	} else {
+		/* For modes with bpp > 8, we only set the pseudo palette in
+		 * the fb_info struct. We rely on vesafb_setcolreg to do all
+		 * sanity checking. */
+		for (i = 0; i < cmap->len; i++) {
+			ret += vesafb_setcolreg(cmap->start + i, cmap->red[i],
+						cmap->green[i], cmap->blue[i],
+						0, info);
+		}
+	}
+	return ret;
+}
+
+static int vesafb_set_par(struct fb_info *info)
+{
+	struct vesafb_par *par = (struct vesafb_par *) info->par;
+	struct vesafb_task *tsk;
+	struct vesafb_crtc_ib *crtc = NULL;
+	struct vesafb_mode_ib *mode = NULL;
+	int i, err = 0, depth = info->var.bits_per_pixel;
+
+	if (depth > 8 && depth != 32)
+		depth = info->var.red.length + info->var.green.length +
+			info->var.blue.length;
+
+	i = vesafb_find_vbe_mode(info->var.xres, info->var.yres, depth,
+				 VESAFB_NEED_EXACT_RES |
+				 VESAFB_NEED_EXACT_DEPTH);
+	if (i >= 0)
+		mode = &vbe_modes[i];
+	else
+		return -EINVAL;
+
+	vesafb_create_task (tsk);
+	if (!tsk)
+		return -ENOMEM;
+	tsk->regs.eax = 0x4f02;
+	tsk->regs.ebx = mode->mode_id | 0x4000;		/* use LFB */
+	tsk->flags = TF_CALL;
+
+	if (vbe_ib.vbe_version >= 0x0300 && !nocrtc &&
+	    info->var.pixclock != 0) {
+		tsk->regs.ebx |= 0x0800; 		/* use CRTC data */
+		tsk->flags |= TF_USE_BUF;
+		crtc = kmalloc(sizeof(struct vesafb_crtc_ib), GFP_KERNEL);
+		if (!crtc) {
+			err = -ENOMEM;
+			goto out;
+		}
+		crtc->horiz_start = info->var.xres + info->var.right_margin;
+		crtc->horiz_end	  = crtc->horiz_start + info->var.hsync_len;
+		crtc->horiz_total = crtc->horiz_end + info->var.left_margin;
+
+		crtc->vert_start  = info->var.yres + info->var.lower_margin;
+		crtc->vert_end    = crtc->vert_start + info->var.vsync_len;
+		crtc->vert_total  = crtc->vert_end + info->var.upper_margin;
+
+		crtc->pixel_clock = PICOS2KHZ(info->var.pixclock) * 1000;
+		crtc->refresh_rate = (u16)(100 * (crtc->pixel_clock /
+				     (crtc->vert_total * crtc->horiz_total)));
+		crtc->flags = 0;
+
+		if (info->var.vmode & FB_VMODE_DOUBLE)
+			crtc->flags |= 0x1;
+		if (info->var.vmode & FB_VMODE_INTERLACED)
+			crtc->flags |= 0x2;
+		if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+			crtc->flags |= 0x4;
+		if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+			crtc->flags |= 0x8;
+		memcpy(&par->crtc, crtc, sizeof(struct vesafb_crtc_ib));
+	} else
+		memset(&par->crtc, 0, sizeof(struct vesafb_crtc_ib));
+
+	tsk->buf = (void*)crtc;
+	tsk->buf_len = sizeof(struct vesafb_crtc_ib);
+
+	if (vesafb_queue_task (tsk)) {
+		err = -EINVAL;
+		goto out;
+	}
+	vesafb_wait_for_task(tsk);
+
+	if ((tsk->regs.eax & 0xffff) != 0x004f) {
+		printk(KERN_ERR "vesafb: mode switch failed (eax: 0x%lx)\n",
+				tsk->regs.eax);
+		err = -EINVAL;
+		goto out;
+	}
+	par->mode_idx = i;
+
+	/* For 8bpp modes, always try to set the DAC to 8 bits. */
+	if (vbe_ib.capabilities & VBE_CAP_CAN_SWITCH_DAC &&
+	    mode->bits_per_pixel <= 8) {
+		vesafb_reset_task(tsk);
+		tsk->flags = TF_CALL;
+		tsk->regs.eax = 0x4f08;
+		tsk->regs.ebx = 0x0800;
+
+		if (!vesafb_queue_task (tsk))
+			vesafb_wait_for_task(tsk);
+
+		if ((tsk->regs.eax & 0xffff) != 0x004f ||
+		    ((tsk->regs.ebx & 0xff00) >> 8) != 8) {
+			/* We've failed to set the DAC palette format -
+			 * time to correct var. */
+			info->var.red.length    = 6;
+			info->var.green.length  = 6;
+			info->var.blue.length   = 6;
+		}
+	}
+
+	info->fix.visual = (info->var.bits_per_pixel == 8) ?
+		           FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+	info->fix.line_length = mode->bytes_per_scan_line;
+
+	DPRINTK("set new mode %dx%d-%d (0x%x)\n",
+		info->var.xres, info->var.yres, info->var.bits_per_pixel,
+		mode->mode_id);
+
+out:	if (crtc != NULL)
+		kfree(crtc);
+	kfree(tsk);
+
+	return err;
+}
+
+static void vesafb_setup_var(struct fb_var_screeninfo *var, struct fb_info *info,
+			     struct vesafb_mode_ib *mode)
+{
+	var->xres = mode->x_res;
+	var->yres = mode->y_res;
+	var->xres_virtual = mode->x_res;
+	var->yres_virtual = (ypan) ?
+			      info->fix.smem_len / mode->bytes_per_scan_line :
+			      mode->y_res;
+	var->xoffset = 0;
+	var->yoffset = 0;
+	var->bits_per_pixel = mode->bits_per_pixel;
+
+	if (var->bits_per_pixel == 15)
+		var->bits_per_pixel = 16;
+
+	if (var->bits_per_pixel > 8) {
+		var->red.offset    = mode->red_off;
+		var->red.length    = mode->red_len;
+		var->green.offset  = mode->green_off;
+		var->green.length  = mode->green_len;
+		var->blue.offset   = mode->blue_off;
+		var->blue.length   = mode->blue_len;
+		var->transp.offset = mode->rsvd_off;
+		var->transp.length = mode->rsvd_len;
+
+		DPRINTK("directcolor: size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",
+			mode->rsvd_len,
+			mode->red_len,
+			mode->green_len,
+			mode->blue_len,
+			mode->rsvd_off,
+			mode->red_off,
+			mode->green_off,
+			mode->blue_off);
+	} else {
+		var->red.offset    = 0;
+		var->green.offset  = 0;
+		var->blue.offset   = 0;
+		var->transp.offset = 0;
+
+		/* We're assuming that we can switch the DAC to 8 bits. If
+		 * this proves to be incorrect, we'll update the fields
+		 * later in set_par(). */
+		if (vbe_ib.capabilities & VBE_CAP_CAN_SWITCH_DAC) {
+			var->red.length    = 8;
+			var->green.length  = 8;
+			var->blue.length   = 8;
+			var->transp.length = 0;
+		} else {
+			var->red.length    = 6;
+			var->green.length  = 6;
+			var->blue.length   = 6;
+			var->transp.length = 0;
+		}
+	}
+}
+
+static void inline vesafb_check_limits(struct fb_var_screeninfo *var,
+		 		       struct fb_info *info)
+{
+	struct fb_videomode *mode;
+
+	if (!var->pixclock)
+		return;
+	if (vbe_ib.vbe_version < 0x0300) {
+		fb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, var, info);
+		return;
+	}
+	if (!fb_validate_mode(var, info))
+		return;
+	mode = fb_find_best_mode(var, &info->modelist);
+	if (mode) {
+		DPRINTK("find_best_mode: %d %d @ %d (vmode: %d)\n",
+			mode->xres, mode->yres, mode->refresh, mode->vmode);
+		if (mode->xres == var->xres && mode->yres == var->yres &&
+		    !(mode->vmode & (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE))) {
+			fb_videomode_to_var(var, mode);
+			return;
+		}
+	}
+	if (info->monspecs.gtf && !fb_get_mode(FB_MAXTIMINGS, 0, var, info))
+		return;
+	/* Use default refresh rate */
+	var->pixclock = 0;
+}
+
+static int vesafb_check_var(struct fb_var_screeninfo *var,
+			    struct fb_info *info)
+{
+	int match = -1;
+	int depth = var->red.length + var->green.length + var->blue.length;
+
+	/* Various apps will use bits_per_pixel to set the color depth,
+	 * which is theoretically incorrect, but which we'll try to handle
+	 * here. */
+	if (depth == 0 || abs(depth - var->bits_per_pixel) >= 8)
+		depth = var->bits_per_pixel;
+	match = vesafb_find_vbe_mode(var->xres, var->yres, depth,
+				     VESAFB_NEED_EXACT_RES);
+
+	if (match == -1) {
+		DPRINTK("vesafb: mode %dx%d-%d not found\n", var->xres,
+			var->yres, depth);
+		return -EINVAL;
+	}
+
+	vesafb_setup_var(var, info, &vbe_modes[match]);
+	DPRINTK("found mode 0x%x (%dx%d-%dbpp)\n",
+		vbe_modes[match].mode_id, vbe_modes[match].x_res,
+		vbe_modes[match].y_res, vbe_modes[match].depth);
+
+	/* Check whether we have remapped enough memory for this mode. */
+	if (var->yres * vbe_modes[match].bytes_per_scan_line >
+	    info->fix.smem_len) {
+		return -EINVAL;
+	}
+
+	if ((var->vmode & FB_VMODE_DOUBLE) &&
+	    !(vbe_modes[match].mode_attr & 0x100))
+		var->vmode &= ~FB_VMODE_DOUBLE;
+	if ((var->vmode & FB_VMODE_INTERLACED) &&
+	    !(vbe_modes[match].mode_attr & 0x200))
+		var->vmode &= ~FB_VMODE_INTERLACED;
+	vesafb_check_limits(var, info);
+	return 0;
+}
+
+static void vesafb_platform_release(struct device *device)
+{
+	return;
+}
+
+static int __init vesafb_probe(struct platform_device *device);
+
+static struct fb_ops vesafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= vesafb_setcolreg,
+	.fb_setcmap	= vesafb_setcmap,
+	.fb_pan_display	= vesafb_pan_display,
+	.fb_blank       = vesafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_check_var	= vesafb_check_var,
+	.fb_set_par	= vesafb_set_par
+};
+
+static struct platform_driver vesafb_driver = {
+	.probe	= vesafb_probe,
+	.driver	= {
+		.name	= "vesafb",
+	},
+};
+
+static struct platform_device vesafb_device = {
+	.name	= "vesafb",
+        .dev    = {
+                .release = vesafb_platform_release,
+        }
+};
+
+#ifndef MODULE
+int __init vesafb_setup(char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	DPRINTK("options %s\n",options);
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt) continue;
+
+		DPRINTK("this_opt: %s\n",this_opt);
+
+		if (! strcmp(this_opt, "redraw"))
+			ypan=0;
+		else if (! strcmp(this_opt, "ypan"))
+			ypan=1;
+		else if (! strcmp(this_opt, "ywrap"))
+			ypan=2;
+		else if (! strcmp(this_opt, "vgapal"))
+			pmi_setpal=0;
+		else if (! strcmp(this_opt, "pmipal"))
+			pmi_setpal=1;
+		else if (! strncmp(this_opt, "mtrr:", 5))
+			mtrr = simple_strtoul(this_opt+5, NULL, 0);
+		else if (! strcmp(this_opt, "nomtrr"))
+			mtrr=0;
+		else if (! strcmp(this_opt, "nocrtc"))
+			nocrtc=1;
+		else if (! strcmp(this_opt, "noedid"))
+			noedid=1;
+		else if (! strcmp(this_opt, "gtf"))
+			gtf=1;
+		else if (! strncmp(this_opt, "vtotal:", 7))
+			vram_total = simple_strtoul(this_opt + 7, NULL, 0);
+		else if (! strncmp(this_opt, "vremap:", 7))
+			vram_remap = simple_strtoul(this_opt + 7, NULL, 0);
+		else if (! strncmp(this_opt, "maxhf:", 6))
+			maxhf = simple_strtoul(this_opt + 6, NULL, 0);
+		else if (! strncmp(this_opt, "maxvf:", 6))
+			maxvf = simple_strtoul(this_opt + 6, NULL, 0);
+		else if (! strncmp(this_opt, "maxclk:", 7))
+			maxclk = simple_strtoul(this_opt + 7, NULL, 0);
+		else if (! strncmp(this_opt, "vbemode:", 8))
+			vbemode = simple_strtoul(this_opt + 8, NULL,0);
+		else if (this_opt[0] >= '0' && this_opt[0] <= '9') {
+			DPRINTK("mode_option: %s\n",this_opt);
+			mode_option = this_opt;
+		} else {
+			printk(KERN_WARNING
+			       "vesafb: unrecognized option %s\n", this_opt);
+		}
+	}
+
+	return 0;
+}
+#endif /* !MODULE */
+
+static int vesafb_read_proc_modes(char *buf, char **start, off_t offset,
+			    	  int len, int *eof, void *private)
+{
+	int clen = 0, i;
+
+	for (i = 0; i < vbe_modes_cnt; i++) {
+		clen += sprintf(buf + clen, "%dx%d-%d\n", vbe_modes[i].x_res,
+				vbe_modes[i].y_res, vbe_modes[i].depth);
+	}
+	*start = buf + offset;
+
+	if (clen > offset) {
+		clen -= offset;
+	} else {
+		clen = 0;
+	}
+	return clen;
+}
+
+static int vesafb_read_proc_vbe_info(char *buf, char **start, off_t offset,
+			    	     int len, int *eof, void *private)
+{
+	int clen = 0;
+
+	clen += sprintf(buf + clen, "Version:    %d.%d\n",
+			((vbe_ib.vbe_version & 0xff00) >> 8),
+			vbe_ib.vbe_version & 0xff);
+	clen += sprintf(buf + clen, "Vendor:     %s\n",
+			(char*)vbe_ib.oem_vendor_name_ptr);
+	clen += sprintf(buf + clen, "Product:    %s\n",
+			(char*)vbe_ib.oem_product_name_ptr);
+	clen += sprintf(buf + clen, "OEM rev:    %s\n",
+			(char*)vbe_ib.oem_product_rev_ptr);
+	clen += sprintf(buf + clen, "OEM string: %s\n",
+			(char*)vbe_ib.oem_string_ptr);
+
+	*start = buf + offset;
+
+	if (clen > offset) {
+		clen -= offset;
+	} else {
+		clen = 0;
+	}
+	return clen;
+}
+
+static int __init inline vesafb_vbe_getinfo(struct vesafb_task *tsk)
+{
+	tsk->regs.eax = 0x4f00;
+	tsk->flags = TF_CALL | TF_GETVBEIB;
+	tsk->buf = &vbe_ib;
+	tsk->buf_len = sizeof(vbe_ib);
+	if (vesafb_queue_task (tsk))
+		return -EINVAL;
+	vesafb_wait_for_task(tsk);
+
+	if (vbe_ib.vbe_version < 0x0200) {
+		printk(KERN_ERR "vesafb: Sorry, pre-VBE 2.0 cards are "
+				"not supported.\n");
+		return -EINVAL;
+	}
+
+	if ((tsk->regs.eax & 0xffff) != 0x004f) {
+		printk(KERN_ERR "vesafb: Getting mode info block failed "
+				"(eax=0x%x)\n", (u32)tsk->regs.eax);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "vesafb: %s, %s, %s (OEM: %s)\n",
+		(char*)vbe_ib.oem_vendor_name_ptr,
+		(char*)vbe_ib.oem_product_name_ptr,
+		(char*)vbe_ib.oem_product_rev_ptr,
+		(char*)vbe_ib.oem_string_ptr);
+
+	printk(KERN_INFO "vesafb: VBE version: %d.%d\n",
+			 ((vbe_ib.vbe_version & 0xff00) >> 8),
+			 vbe_ib.vbe_version & 0xff);
+	return 0;
+}
+
+static int __init inline vesafb_vbe_getmodes(struct vesafb_task *tsk)
+{
+	u16 *mode = 0;
+	int off = 0;
+
+	/* Count available modes. */
+	mode = (u16*)vbe_ib.mode_list_ptr;
+	while (*mode != 0xffff) {
+		vbe_modes_cnt++;
+		mode++;
+	}
+
+	vbe_modes = kmalloc(sizeof(struct vesafb_mode_ib)*
+			    vbe_modes_cnt, GFP_KERNEL);
+	if (!vbe_modes)
+		return -ENOMEM;
+
+	/* Get mode info for all available modes. */
+	mode = (u16*)vbe_ib.mode_list_ptr;
+
+	while (*mode != 0xffff) {
+		struct vesafb_mode_ib *mib;
+
+		vesafb_reset_task(tsk);
+		tsk->regs.eax = 0x4f01;
+		tsk->regs.ecx = (u32) *mode;
+		tsk->flags = TF_CALL | TF_RETURN_BUF;
+		tsk->buf = vbe_modes+off;
+		tsk->buf_len = sizeof(struct vesafb_mode_ib);
+		if (vesafb_queue_task(tsk))
+			return -EINVAL;
+		vesafb_wait_for_task(tsk);
+		mib = p_mode(tsk->buf);
+		mib->mode_id = *mode;
+
+		/* We only want modes that are supported with the currennt
+		 * hardware configuration (D0), color (D3), graphics (D4)
+		 * and that have support for the LFB (D7). */
+		if ((mib->mode_attr & 0x99) == 0x99 &&
+		    mib->bits_per_pixel >= 8) {
+			off++;
+		} else {
+			vbe_modes_cnt--;
+		}
+		mode++;
+		mib->depth = mib->red_len + mib->green_len + mib->blue_len;
+		/* Handle 8bpp modes and modes with broken color component
+		 * lengths. */
+		if (mib->depth == 0 ||
+		    (mib->depth == 24 && mib->bits_per_pixel == 32))
+			mib->depth = mib->bits_per_pixel;
+	}
+
+	return 0;
+}
+
+static int __init inline vesafb_vbe_getpmi(struct vesafb_task *tsk)
+{
+	int i;
+
+	vesafb_reset_task(tsk);
+	tsk->regs.eax = 0x4f0a;
+	tsk->regs.ebx = 0x0;
+	tsk->flags = TF_CALL;
+	if (vesafb_queue_task(tsk))
+		return -EINVAL;
+	vesafb_wait_for_task(tsk);
+
+	if ((tsk->regs.eax & 0xffff) != 0x004f || tsk->regs.es < 0xc000) {
+		pmi_setpal = ypan = 0;
+	} else {
+		pmi_base  = (u16*)phys_to_virt(((u32)tsk->regs.es << 4) +
+			     tsk->regs.edi);
+		pmi_start = (void*)((char*)pmi_base + pmi_base[1]);
+		pmi_pal   = (void*)((char*)pmi_base + pmi_base[2]);
+		printk(KERN_INFO "vesafb: protected mode interface info at "
+				 "%04x:%04x\n",
+				 (u16)tsk->regs.es, (u16)tsk->regs.edi);
+		printk(KERN_INFO "vesafb: pmi: set display start = %p, "
+				 "set palette = %p\n", pmi_start, pmi_pal);
+
+		if (pmi_base[3]) {
+			printk(KERN_INFO "vesafb: pmi: ports = ");
+			for (i = pmi_base[3]/2; pmi_base[i] != 0xffff; i++)
+				printk("%x ",pmi_base[i]);
+			printk("\n");
+
+			/*
+			 * memory areas not supported (yet?)
+			 *
+			 * Rules are: we have to set up a descriptor for the
+			 * requested memory area and pass it in the ES register
+			 * to the BIOS function.
+			 */
+			if (pmi_base[i] != 0xffff) {
+				printk(KERN_INFO "vesafb: can't handle memory "
+						 "requests, pmi disabled\n");
+				ypan = pmi_setpal = 0;
+			}
+		}
+	}
+	return 0;
+}
+
+static int __init inline vesafb_vbe_getedid(struct vesafb_task *tsk,
+					    struct fb_info *info)
+{
+	int res = 0;
+
+	if (noedid || vbe_ib.vbe_version < 0x0300)
+		return -EINVAL;
+
+	vesafb_reset_task(tsk);
+	tsk->regs.eax = 0x4f15;
+	tsk->regs.ebx = 0;
+	tsk->regs.ecx = 0;
+	if (vesafb_queue_task(tsk))
+		return -EINVAL;
+	vesafb_wait_for_task(tsk);
+
+	if ((tsk->regs.eax & 0xffff) != 0x004f)
+		return -EINVAL;
+
+	if ((tsk->regs.ebx & 0x3) == 3) {
+		printk(KERN_INFO "vesafb: VBIOS/hardware supports both "
+				 "DDC1 and DDC2 transfers\n");
+	} else if ((tsk->regs.ebx & 0x3) == 2) {
+		printk(KERN_INFO "vesafb: VBIOS/hardware supports DDC2 "
+				 "transfers\n");
+	} else if ((tsk->regs.ebx & 0x3) == 1) {
+		printk(KERN_INFO "vesafb: VBIOS/hardware supports DDC1 "
+				 "transfers\n");
+	} else {
+		printk(KERN_INFO "vesafb: VBIOS/hardware doesn't support "
+				 "DDC transfers\n");
+		return -EINVAL;
+	}
+
+	vesafb_reset_task(tsk);
+	tsk->regs.eax = 0x4f15;
+	tsk->regs.ebx = 1;
+	tsk->regs.ecx = tsk->regs.edx = 0;
+	tsk->flags = TF_CALL | TF_RETURN_BUF;
+	tsk->buf = kmalloc(EDID_LENGTH, GFP_KERNEL);
+	tsk->buf_len = EDID_LENGTH;
+
+	if (vesafb_queue_task(tsk)) {
+		res = -EINVAL;
+		goto out;
+	}
+	vesafb_wait_for_task(tsk);
+
+	if ((tsk->regs.eax & 0xffff) == 0x004f) {
+		fb_edid_to_monspecs(tsk->buf, &info->monspecs);
+		fb_videomode_to_modelist(info->monspecs.modedb,
+				info->monspecs.modedb_len, &info->modelist);
+		if (info->monspecs.vfmax && info->monspecs.hfmax) {
+			/* If the maximum pixel clock wasn't specified in
+			 * the EDID block, set it to 300 MHz. */
+			if (info->monspecs.dclkmax == 0)
+				info->monspecs.dclkmax = 300 * 1000000;
+			info->monspecs.gtf = 1;
+		} else {
+			res = -EINVAL;
+		}
+	}
+
+out:	kfree(tsk->buf);
+	return res;
+}
+
+static void __init inline vesafb_vbe_getmonspecs(struct vesafb_task *tsk,
+		                                 struct fb_info *info)
+{
+	struct fb_var_screeninfo var;
+	int i;
+	memset(&info->monspecs, 0, sizeof(struct fb_monspecs));
+
+	/* If we didn't get all necessary data from the EDID block,
+	 * mark it as incompatible with the GTF. */
+	if (vesafb_vbe_getedid(tsk, info))
+		info->monspecs.gtf = 0;
+
+	/* Kernel command line overrides. */
+	if (maxclk)
+		info->monspecs.dclkmax = maxclk * 1000000;
+	if (maxvf)
+		info->monspecs.vfmax = maxvf;
+	if (maxhf)
+		info->monspecs.hfmax = maxhf * 1000;
+
+	/* In case DDC transfers are not supported the user can provide
+	 * monitor limits manually. Lower limits are set to "safe" values. */
+	if (info->monspecs.gtf == 0 && maxclk && maxvf && maxhf) {
+		info->monspecs.dclkmin = 0;
+		info->monspecs.vfmin = 60;
+		info->monspecs.hfmin = 29000;
+		info->monspecs.gtf = 1;
+	}
+
+	if (info->monspecs.gtf) {
+		printk(KERN_INFO
+		       	"vesafb: monitor limits: vf = %d Hz, hf = %d kHz, "
+			"clk = %d MHz\n", info->monspecs.vfmax,
+			(int)(info->monspecs.hfmax / 1000),
+			(int)(info->monspecs.dclkmax / 1000000));
+		/* Add valid VESA video modes to our modelist. */
+		for (i = 0; i < VESA_MODEDB_SIZE; i++) {
+			fb_videomode_to_var(&var, (struct fb_videomode *)
+					    &vesa_modes[i]);
+			if (!fb_validate_mode(&var, info))
+				fb_add_videomode((struct fb_videomode *)
+						 &vesa_modes[i],
+						 &info->modelist);
+		}
+	} else {
+		/* Add all VESA video modes to our modelist. */
+		fb_videomode_to_modelist((struct fb_videomode *)vesa_modes,
+				 	 VESA_MODEDB_SIZE, &info->modelist);
+		printk(KERN_INFO "vesafb: no monitor limits have been set\n");
+	}
+	return;
+}
+
+static int __init inline vesafb_vbe_init(struct fb_info *info)
+{
+	struct vesafb_task *tsk;
+	int res = 0;
+
+	vesafb_create_task(tsk);
+	if (!tsk)
+		return -EINVAL;
+	if ((res = vesafb_vbe_getinfo(tsk)) != 0)
+		goto out;
+	if ((res = vesafb_vbe_getmodes(tsk)) != 0)
+		goto out;
+	if (pmi_setpal || ypan)
+		vesafb_vbe_getpmi(tsk);
+	vesafb_vbe_getmonspecs(tsk, info);
+out:	kfree(tsk);
+	return res;
+}
+
+static int __init decode_mode(u32 *xres, u32 *yres, u32 *bpp, u32 *refresh)
+{
+	int len = strlen(mode_option), i, err = 0;
+	u8 res_specified = 0, bpp_specified = 0, refresh_specified = 0,
+	   yres_specified = 0;
+
+	for (i = len-1; i >= 0; i--) {
+ 		switch (mode_option[i]) {
+		case '@':
+    			len = i;
+    			if (!refresh_specified && !bpp_specified &&
+			    !yres_specified) {
+				*refresh = simple_strtoul(&mode_option[i+1],
+							  NULL, 0);
+				refresh_specified = 1;
+			} else
+				goto out;
+		    	break;
+		case '-':
+			len = i;
+		    	if (!bpp_specified && !yres_specified) {
+			    	*bpp = simple_strtoul(&mode_option[i+1],
+						      NULL, 0);
+				bpp_specified = 1;
+		    	} else
+				goto out;
+		    	break;
+		case 'x':
+			if (!yres_specified) {
+				*yres = simple_strtoul(&mode_option[i+1],
+						       NULL, 0);
+				yres_specified = 1;
+		    	} else
+				goto out;
+		    	break;
+		case '0'...'9':
+			break;
+		default:
+			goto out;
+	    	}
+	}
+
+	if (i < 0 && yres_specified) {
+		*xres = simple_strtoul(mode_option, NULL, 0);
+	   	res_specified = 1;
+	}
+
+out:	if (!res_specified || !yres_specified) {
+		printk(KERN_ERR "vesafb: invalid resolution, "
+				"%s not specified\n",
+				(!res_specified) ? "width" : "height");
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int __init vesafb_init_set_mode(struct fb_info *info)
+{
+	struct fb_videomode *fbmode;
+	struct fb_videomode mode;
+	int i, modeid, refresh = 0;
+	u8 refresh_specified = 0;
+
+	if (!mode_option)
+		mode_option = CONFIG_FB_VESA_DEFAULT_MODE;
+
+	if (vbemode > 0) {
+		for (i = 0; i < vbe_modes_cnt; i++) {
+			if (vbe_modes[i].mode_id == vbemode) {
+				info->var.vmode = FB_VMODE_NONINTERLACED;
+				info->var.sync = FB_SYNC_VERT_HIGH_ACT;
+				vesafb_setup_var(&info->var, info,
+						 &vbe_modes[i]);
+				fb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON,
+					    60, &info->var, info);
+				/* With pixclock set to 0, the default BIOS
+				 * timings will be used in set_par(). */
+				info->var.pixclock = 0;
+				modeid = i;
+				goto out;
+			}
+		}
+		printk(KERN_INFO "specified VBE mode %d not found\n",
+				 vbemode);
+		vbemode = 0;
+	}
+
+	/* Decode the mode specified on the kernel command line. We save
+	 * the depth into bits_per_pixel, which is wrong, but will work
+	 * anyway. */
+	if (decode_mode(&info->var.xres, &info->var.yres,
+			&info->var.bits_per_pixel, &refresh))
+		return -EINVAL;
+	if (refresh)
+		refresh_specified = 1;
+	else
+		refresh = 60;
+
+	/* Look for a matching VBE mode. We can live if an exact match
+	 * cannot be found. */
+	modeid = vesafb_find_vbe_mode(info->var.xres, info->var.yres,
+			              info->var.bits_per_pixel, 0);
+
+	if (modeid == -1) {
+		return -EINVAL;
+	} else {
+		info->var.vmode = FB_VMODE_NONINTERLACED;
+		info->var.sync = FB_SYNC_VERT_HIGH_ACT;
+		vesafb_setup_var(&info->var, info, &vbe_modes[modeid]);
+	}
+	if (vbe_ib.vbe_version < 0x0300) {
+		fb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,
+			    &info->var, info);
+		goto out;
+	}
+	if (!gtf) {
+		struct fb_videomode tmode;
+
+		if (refresh_specified) {
+			fb_var_to_videomode(&tmode, &info->var);
+			tmode.refresh = refresh;
+			fbmode = fb_find_nearest_mode(&tmode,
+						      &info->modelist);
+		} else
+			fbmode = fb_find_best_mode(&info->var,
+						   &info->modelist);
+
+		if (fbmode->xres == info->var.xres &&
+		    fbmode->yres == info->var.yres &&
+		    !(fbmode->vmode & (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE))
+		    && (!refresh_specified ||
+		    abs(refresh - fbmode->refresh) <= 5)) {
+			fb_videomode_to_var(&info->var, fbmode);
+			return modeid;
+		}
+	}
+	i = FB_MAXTIMINGS;
+	if (!info->monspecs.gtf)
+		i = FB_IGNOREMON | FB_VSYNCTIMINGS;
+	else if (refresh_specified)
+		i = FB_VSYNCTIMINGS;
+	if (!fb_get_mode(i, refresh, &info->var, info))
+		goto out;
+	if (info->monspecs.gtf &&
+	    !fb_get_mode(FB_MAXTIMINGS, 0, &info->var, info))
+		goto out;
+	/* Use default refresh rate */
+	printk(KERN_WARNING "vesafb: using default BIOS refresh rate\n");
+	info->var.pixclock = 0;
+
+out:
+	fb_var_to_videomode(&mode, &info->var);
+	fb_add_videomode(&mode, &info->modelist);
+	return modeid;
+}
+
+static int __init vesafb_probe(struct platform_device *dev)
+{
+	char entry[16];
+	struct fb_info *info;
+	struct vesafb_mode_ib *mode = NULL;
+	int err = 0, i, h;
+	unsigned int size_vmode;
+	unsigned int size_remap;
+	unsigned int size_total;
+
+	vesafb_info = info = framebuffer_alloc(sizeof(struct vesafb_par) +
+			                       sizeof(u32) * 256, &dev->dev);
+	if (!info)
+	 	return -ENOMEM;
+
+	if (vesafb_wait_for_thread()) {
+		printk(KERN_ERR "vesafb: vesafb thread not running\n");
+		framebuffer_release(info);
+		return -EINVAL;
+	}
+
+	if (vesafb_vbe_init(info)) {
+		printk(KERN_ERR "vesafb: vbe_init failed\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	vesafb_fix.ypanstep  = ypan     ? 1 : 0;
+	vesafb_fix.ywrapstep = (ypan>1) ? 1 : 0;
+
+	info->pseudo_palette = ((u8*)info->par + sizeof(struct vesafb_par));
+	info->fbops = &vesafb_ops;
+	info->var = vesafb_defined;
+	info->fix = vesafb_fix;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		err = -ENXIO;
+		goto out;
+	}
+
+	i = vesafb_init_set_mode(info);
+	if (i < 0) {
+		err = -EINVAL;
+		goto out_cmap;
+	} else
+		mode = &vbe_modes[i];
+
+	/* Find out how much IO memory is required for the mode with
+	 * the highest resolution. */
+	size_remap = 0;
+	for (i = 0; i < vbe_modes_cnt; i++) {
+		h = vbe_modes[i].bytes_per_scan_line * vbe_modes[i].y_res;
+		if (h > size_remap)
+			size_remap = h;
+	}
+	size_remap *= 2;
+
+	/*   size_vmode -- that is the amount of memory needed for the
+	 *                 used video mode, i.e. the minimum amount of
+	 *                 memory we need. */
+	if (mode != NULL) {
+		size_vmode = info->var.yres * mode->bytes_per_scan_line;
+	} else {
+		size_vmode = info->var.yres * info->var.xres *
+			     ((info->var.bits_per_pixel + 7) >> 3);
+	}
+
+	/*   size_total -- all video memory we have. Used for mtrr
+	 *                 entries, ressource allocation and bounds
+	 *                 checking. */
+	size_total = vbe_ib.total_memory * 65536;
+	if (vram_total)
+		size_total = vram_total * 1024 * 1024;
+	if (size_total < size_vmode)
+		size_total = size_vmode;
+	((struct vesafb_par*)(info->par))->mem_total = size_total;
+
+	/*   size_remap -- the amount of video memory we are going to
+	 *                 use for vesafb.  With modern cards it is no
+	 *                 option to simply use size_total as th
+	 *                 wastes plenty of kernel address space. */
+	if (vram_remap)
+		size_remap = vram_remap * 1024 * 1024;
+	if (size_remap < size_vmode)
+		size_remap = size_vmode;
+	if (size_remap > size_total)
+		size_remap = size_total;
+
+	info->fix.smem_len = size_remap;
+	info->fix.smem_start = mode->phys_base_ptr;
+
+	/* We have to set it here, because when setup_var() was called,
+	 * smem_len wasn't defined yet. */
+	info->var.yres_virtual = info->fix.smem_len /
+				 mode->bytes_per_scan_line;
+
+	if (ypan && info->var.yres_virtual > info->var.yres) {
+		printk(KERN_INFO "vesafb: scrolling: %s "
+		       "using protected mode interface, "
+		       "yres_virtual=%d\n",
+		       (ypan > 1) ? "ywrap" : "ypan",info->var.yres_virtual);
+	} else {
+		printk(KERN_INFO "vesafb: scrolling: redraw\n");
+		info->var.yres_virtual = info->var.yres;
+		ypan = 0;
+	}
+
+	info->flags = FBINFO_FLAG_DEFAULT |
+		(ypan) ? FBINFO_HWACCEL_YPAN : 0;
+
+	if (!request_mem_region(info->fix.smem_start, size_total, "vesafb")) {
+		printk(KERN_WARNING "vesafb: cannot reserve video memory at "
+		       "0x%lx\n", info->fix.smem_start);
+		/* We cannot make this fatal. Sometimes this comes from magic
+		   spaces our resource handlers simply don't know about. */
+	}
+
+	info->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);
+
+	if (!info->screen_base) {
+		printk(KERN_ERR
+		       "vesafb: abort, cannot ioremap video memory "
+		       "0x%x @ 0x%lx\n",
+		       info->fix.smem_len, info->fix.smem_start);
+		err = -EIO;
+		goto out_mem;
+ 	}
+
+	/* Request failure does not faze us, as vgacon probably has this
+	   region already (FIXME) */
+	request_region(0x3c0, 32, "vesafb");
+
+	if (mtrr && !(info->fix.smem_start & (PAGE_SIZE - 1))) {
+		int temp_size = size_total;
+		unsigned int type = 0;
+
+		switch (mtrr) {
+		case 1:
+			type = MTRR_TYPE_UNCACHABLE;
+			break;
+		case 2:
+			type = MTRR_TYPE_WRBACK;
+			break;
+		case 3:
+			type = MTRR_TYPE_WRCOMB;
+			break;
+		case 4:
+			type = MTRR_TYPE_WRTHROUGH;
+			break;
+		default:
+			type = 0;
+			break;
+		}
+
+		if (type) {
+			int rc;
+
+			/* Find the largest power-of-two */
+			while (temp_size & (temp_size - 1))
+				temp_size &= (temp_size - 1);
+
+			/* Try and find a power of two to add */
+			do {
+				rc = mtrr_add(info->fix.smem_start,
+					      temp_size, type, 1);
+				temp_size >>= 1;
+			} while (temp_size >= PAGE_SIZE && rc == -EINVAL);
+  		}
+  	}
+
+	if (register_framebuffer(info) < 0) {
+		printk(KERN_ERR
+		       "vesafb: failed to register framebuffer device\n");
+		err = -EINVAL;
+		goto out_mem;
+	}
+
+  	printk(KERN_INFO "vesafb: framebuffer at 0x%lx, mapped to 0x%p, "
+	       "using %dk, total %dk\n", info->fix.smem_start,
+	       info->screen_base, size_remap/1024, size_total/1024);
+	printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node,
+	       info->fix.id);
+
+	sprintf(entry, "fb%d", info->node);
+	proc_mkdir(entry, 0);
+
+	sprintf(entry, "fb%d/modes", info->node);
+	create_proc_read_entry(entry, 0, 0, vesafb_read_proc_modes, NULL);
+
+	sprintf(entry, "fb%d/vbe_info", info->node);
+	create_proc_read_entry(entry, 0, 0, vesafb_read_proc_vbe_info, NULL);
+	return 0;
+
+out_mem:
+	release_mem_region(info->fix.smem_start, size_total);
+	if (!list_empty(&info->modelist))
+		fb_destroy_modelist(&info->modelist);
+	fb_destroy_modedb(info->monspecs.modedb);
+out_cmap:
+	fb_dealloc_cmap(&info->cmap);
+out:
+	framebuffer_release(info);
+	vesafb_info = NULL;
+	kfree(vbe_modes);
+	vbe_modes = NULL;
+	return err;
+}
+
+int __init vesafb_init(void)
+{
+	int ret;
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("vesafb", &option))
+		return -ENODEV;
+	vesafb_setup(option);
+#endif
+	ret = platform_driver_register(&vesafb_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&vesafb_device);
+		if (ret)
+			platform_driver_unregister(&vesafb_driver);
+	}
+	return ret;
+}
+
+module_init(vesafb_init);
+
+#ifdef MODULE
+void __exit vesafb_exit(void)
+{
+	char entry[16];
+
+	if (vesafb_info)
+		unregister_framebuffer(vesafb_info);
+
+	platform_device_unregister(&vesafb_device);
+	platform_driver_unregister(&vesafb_driver);
+
+	if (vesafb_info) {
+		struct vesafb_par *par = (struct vesafb_par*)vesafb_info->par;
+
+		sprintf(entry, "fb%d/modes", vesafb_info->node);
+		remove_proc_entry(entry, NULL);
+
+		sprintf(entry, "fb%d/vbe_info", vesafb_info->node);
+		remove_proc_entry(entry, NULL);
+
+		sprintf(entry, "fb%d", vesafb_info->node);
+		remove_proc_entry(entry, NULL);
+
+		iounmap(vesafb_info->screen_base);
+		release_mem_region(vesafb_info->fix.smem_start,
+				   par->mem_total);
+		fb_dealloc_cmap(&vesafb_info->cmap);
+		if (!list_empty(&vesafb_info->modelist))
+			fb_destroy_modelist(&vesafb_info->modelist);
+		fb_destroy_modedb(vesafb_info->monspecs.modedb);
+		framebuffer_release(vesafb_info);
+	}
+
+	if (vbe_modes != NULL)
+		kfree(vbe_modes);
+}
+
+module_exit(vesafb_exit);
+
+static inline int param_get_scroll(char *buffer, struct kernel_param *kp)
+{
+	return 0;
+}
+static inline int param_set_scroll(const char *val, struct kernel_param *kp)
+{
+	ypan = 0;
+
+	if (! strcmp(val, "redraw"))
+		ypan = 0;
+	else if (! strcmp(val, "ypan"))
+		ypan = 1;
+	else if (! strcmp(val, "ywrap"))
+		ypan = 2;
+
+	return 0;
+}
+
+#define param_check_scroll(name, p) __param_check(name, p, void);
+
+module_param_named(scroll, ypan, scroll, 0);
+MODULE_PARM_DESC(scroll,"Scrolling mode, set to 'redraw', 'ypan' or 'ywrap'");
+module_param_named(vgapal, pmi_setpal, invbool, 0);
+MODULE_PARM_DESC(vgapal,"bool: set palette using VGA registers");
+module_param_named(pmipal, pmi_setpal, bool, 0);
+MODULE_PARM_DESC(pmipal,"bool: set palette using PMI calls");
+module_param_named(nomtrr, mtrr, invbool, 0);
+MODULE_PARM_DESC(nomtrr,"bool: disable use of MTRR registers");
+module_param(nocrtc, bool, 0);
+MODULE_PARM_DESC(nocrtc,"bool: ignore CRTC timings when setting modes");
+module_param(noedid, bool, 0);
+MODULE_PARM_DESC(noedid,"bool: ignore EDID-provided monitor limits "
+		        "when setting modes");
+module_param(gtf, bool, 0);
+MODULE_PARM_DESC(gtf,"bool: force use of VESA GTF to calculate mode timings");
+module_param(vram_remap, uint, 0);
+MODULE_PARM_DESC(vram_remap,"Set amount of video memory to be used [MiB]");
+module_param(vram_total, uint, 0);
+MODULE_PARM_DESC(vram_total,"Set total amount of video memoery [MiB]");
+module_param(maxclk, ushort, 0);
+MODULE_PARM_DESC(maxclk,"Maximum pixelclock [MHz], overrides EDID data");
+module_param(maxhf, ushort, 0);
+MODULE_PARM_DESC(maxhf,"Maximum horizontal frequency [kHz], "
+		       "overrides EDID data");
+module_param(maxvf, ushort, 0);
+MODULE_PARM_DESC(maxvf,"Maximum vertical frequency [Hz], "
+		       "overrides EDID data");
+module_param_named(mode, mode_option, charp, 0);
+MODULE_PARM_DESC(mode, "Specify resolution as "
+		       "\"<xres>x<yres>[-<bpp>][@<refresh>]\"");
+module_param(vbemode, ushort, 0);
+MODULE_PARM_DESC(vbemode,"VBE mode number to set, overrides 'mode' setting");
+
+#endif /* MODULE */
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Januszewski");
+MODULE_DESCRIPTION("Framebuffer driver for VBE2.0+ compliant graphics boards");
+
diff --git a/fs/Kconfig b/fs/Kconfig
index cfbfbd813c..2176e3a87e 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -1199,6 +1199,71 @@ config CRAMFS
 
 	  If unsure, say N.
 
+config SQUASHFS
+	tristate "SquashFS 3.0 - Squashed file system support"
+	select ZLIB_INFLATE
+	help
+	  Saying Y here includes support for SquashFS 3.0 (a Compressed Read-Only File
+	  System).  Squashfs is a highly compressed read-only filesystem for Linux.
+	  It uses zlib compression to compress both files, inodes and directories.
+	  Inodes in the system are very small and all blocks are packed to minimise
+	  data overhead. Block sizes greater than 4K are supported up to a maximum of 64K.
+	  SquashFS 3.0 supports 64 bit filesystems and files (larger than 4GB), full
+	  uid/gid information, hard links and timestamps.
+
+	  Squashfs is intended for general read-only filesystem use, for archival
+	  use (i.e. in cases where a .tar.gz file may be used), and in embedded
+	  systems where low overhead is needed.  Further information and filesystem tools
+	  are available from http://squashfs.sourceforge.net.
+
+	  If you want to compile this as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called squashfs.  Note that the root file system (the one
+	  containing the directory /) cannot be compiled as a module.
+
+	  If unsure, say N.
+
+config SQUASHFS_EMBEDDED
+
+	bool "Additional options for memory-constrained systems" 
+	depends on SQUASHFS
+	default n
+	help
+	  Saying Y here allows you to specify cache sizes and how Squashfs
+	  allocates memory.  This is only intended for memory constrained
+	  systems.
+
+	  If unsure, say N.
+
+config SQUASHFS_FRAGMENT_CACHE_SIZE
+	int "Number of fragments cached" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default "3"
+	help
+	  By default SquashFS caches the last 3 fragments read from
+	  the filesystem.  Increasing this amount may mean SquashFS
+	  has to re-read fragments less often from disk, at the expense
+	  of extra system memory.  Decreasing this amount will mean
+	  SquashFS uses less memory at the expense of extra reads from disk.
+
+	  Note there must be at least one cached fragment.  Anything
+	  much more than three will probably not make much difference.
+
+config SQUASHFS_VMALLOC
+	bool "Use Vmalloc rather than Kmalloc" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default n
+	help
+	  By default SquashFS uses kmalloc to obtain fragment cache memory.
+	  Kmalloc memory is the standard kernel allocator, but it can fail
+	  on memory constrained systems.  Because of the way Vmalloc works,
+	  Vmalloc can succeed when kmalloc fails.  Specifying this option
+	  will make SquashFS always use Vmalloc to allocate the
+	  fragment cache memory.
+
+	  If unsure, say N.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	help
diff --git a/fs/Makefile b/fs/Makefile
index 1db711319c..7d2d8f5920 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_EXT3_FS)		+= ext3/ # Before ext2 so root fs can be ext3
 obj-$(CONFIG_JBD)		+= jbd/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
diff --git a/fs/squashfs/Makefile b/fs/squashfs/Makefile
new file mode 100644
index 0000000000..1bc7b0609e
--- /dev/null
+++ b/fs/squashfs/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux squashfs routines.
+#
+
+obj-$(CONFIG_SQUASHFS) += squashfs.o
+squashfs-y += inode.o
+squashfs-y += squashfs2_0.o
diff --git a/fs/squashfs/inode.c b/fs/squashfs/inode.c
new file mode 100644
index 0000000000..da0b3eed6d
--- /dev/null
+++ b/fs/squashfs/inode.c
@@ -0,0 +1,2127 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * inode.c
+ */
+
+#include <linux/types.h>
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/init.h>
+#include <linux/dcache.h>
+#include <linux/wait.h>
+#include <linux/zlib.h>
+#include <linux/blkdev.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+#include "squashfs.h"
+
+static void squashfs_put_super(struct super_block *);
+static int squashfs_statfs(struct super_block *, struct kstatfs *);
+static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static int squashfs_readpage(struct file *file, struct page *page);
+static int squashfs_readpage4K(struct file *file, struct page *page);
+static int squashfs_readdir(struct file *, void *, filldir_t);
+static struct inode *squashfs_alloc_inode(struct super_block *sb);
+static void squashfs_destroy_inode(struct inode *inode);
+static int init_inodecache(void);
+static void destroy_inodecache(void);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *,
+				struct nameidata *);
+static struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode);
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
+static struct super_block *squashfs_get_sb(struct file_system_type *, int,
+				const char *, void *);
+
+
+static z_stream stream;
+
+static struct file_system_type squashfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "squashfs",
+	.get_sb = squashfs_get_sb,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static struct super_operations squashfs_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+};
+
+SQSH_EXTERN struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
+};
+
+SQSH_EXTERN struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
+};
+
+SQSH_EXTERN struct address_space_operations squashfs_aops_4K = {
+	.readpage = squashfs_readpage4K
+};
+
+static struct file_operations squashfs_dir_ops = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir
+};
+
+SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {
+	.lookup = squashfs_lookup
+};
+
+
+static struct buffer_head *get_block_length(struct super_block *s,
+				int *cur_index, int *offset, int *c_byte)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned short temp;
+	struct buffer_head *bh;
+
+	if (!(bh = sb_bread(s, *cur_index)))
+		goto out;
+
+	if (msblk->devblksize - *offset == 1) {
+		if (msblk->swap)
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+		else
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+		brelse(bh);
+		if (!(bh = sb_bread(s, ++(*cur_index))))
+			goto out;
+		if (msblk->swap)
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				bh->b_data); 
+		else
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				bh->b_data); 
+		*c_byte = temp;
+		*offset = 1;
+	} else {
+		if (msblk->swap) {
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		} else {
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		}
+		*c_byte = temp;
+		*offset += 2;
+	}
+
+	if (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {
+		if (*offset == msblk->devblksize) {
+			brelse(bh);
+			if (!(bh = sb_bread(s, ++(*cur_index))))
+				goto out;
+			*offset = 0;
+		}
+		if (*((unsigned char *) (bh->b_data + *offset)) !=
+						SQUASHFS_MARKER_BYTE) {
+			ERROR("Metadata block marker corrupt @ %x\n",
+						*cur_index);
+			brelse(bh);
+			goto out;
+		}
+		(*offset)++;
+	}
+	return bh;
+
+out:
+	return NULL;
+}
+
+
+SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+			long long index, unsigned int length,
+			long long *next_index)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct buffer_head *bh[((SQUASHFS_FILE_MAX_SIZE - 1) >>
+			msblk->devblksize_log2) + 2];
+	unsigned int offset = index & ((1 << msblk->devblksize_log2) - 1);
+	unsigned int cur_index = index >> msblk->devblksize_log2;
+	int bytes, avail_bytes, b = 0, k;
+	char *c_buffer;
+	unsigned int compressed;
+	unsigned int c_byte = length;
+
+	if (c_byte) {
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
+		c_buffer = compressed ? msblk->read_data : buffer;
+		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		if (!(bh[0] = sb_getblk(s, cur_index)))
+			goto block_release;
+
+		for (b = 1; bytes < c_byte; b++) {
+			if (!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b, bh);
+	} else {
+		if (!(bh[0] = get_block_length(s, &cur_index, &offset,
+								&c_byte)))
+			goto read_failure;
+
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED(c_byte);
+		c_buffer = compressed ? msblk->read_data : buffer;
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		for (b = 1; bytes < c_byte; b++) {
+			if (!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b - 1, bh + 1);
+	}
+
+	if (compressed)
+		down(&msblk->read_data_mutex);
+
+	for (bytes = 0, k = 0; k < b; k++) {
+		avail_bytes = (c_byte - bytes) > (msblk->devblksize - offset) ?
+					msblk->devblksize - offset :
+					c_byte - bytes;
+		wait_on_buffer(bh[k]);
+		if (!buffer_uptodate(bh[k]))
+			goto block_release;
+		memcpy(c_buffer + bytes, bh[k]->b_data + offset, avail_bytes);
+		bytes += avail_bytes;
+		offset = 0;
+		brelse(bh[k]);
+	}
+
+	/*
+	 * uncompress block
+	 */
+	if (compressed) {
+		int zlib_err;
+
+		stream.next_in = c_buffer;
+		stream.avail_in = c_byte;
+		stream.next_out = buffer;
+		stream.avail_out = msblk->read_size;
+
+		if (((zlib_err = zlib_inflateInit(&stream)) != Z_OK) ||
+				((zlib_err = zlib_inflate(&stream, Z_FINISH))
+				 != Z_STREAM_END) || ((zlib_err =
+				zlib_inflateEnd(&stream)) != Z_OK)) {
+			ERROR("zlib_fs returned unexpected result 0x%x\n",
+				zlib_err);
+			bytes = 0;
+		} else
+			bytes = stream.total_out;
+		
+		up(&msblk->read_data_mutex);
+	}
+
+	if (next_index)
+		*next_index = index + c_byte + (length ? 0 :
+				(SQUASHFS_CHECK_DATA(msblk->sblk.flags)
+				 ? 3 : 2));
+	return bytes;
+
+block_release:
+	while (--b >= 0)
+		brelse(bh[b]);
+
+read_failure:
+	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	return 0;
+}
+
+
+SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, char *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int n, i, bytes, return_length = length;
+	long long next_index;
+
+	TRACE("Entered squashfs_get_cached_block [%llx:%x]\n", block, offset);
+
+	while ( 1 ) {
+		for (i = 0; i < SQUASHFS_CACHED_BLKS; i++) 
+			if (msblk->block_cache[i].block == block)
+				break; 
+		
+		down(&msblk->block_cache_mutex);
+
+		if (i == SQUASHFS_CACHED_BLKS) {
+			/* read inode header block */
+			for (i = msblk->next_cache, n = SQUASHFS_CACHED_BLKS;
+					n ; n --, i = (i + 1) %
+					SQUASHFS_CACHED_BLKS)
+				if (msblk->block_cache[i].block !=
+							SQUASHFS_USED_BLK)
+					break;
+
+			if (n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msblk->waitq, &wait);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+ 				up(&msblk->block_cache_mutex);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msblk->waitq, &wait);
+				continue;
+			}
+			msblk->next_cache = (i + 1) % SQUASHFS_CACHED_BLKS;
+
+			if (msblk->block_cache[i].block ==
+							SQUASHFS_INVALID_BLK) {
+				if (!(msblk->block_cache[i].data =
+						kmalloc(SQUASHFS_METADATA_SIZE,
+						GFP_KERNEL))) {
+					ERROR("Failed to allocate cache"
+							"block\n");
+					up(&msblk->block_cache_mutex);
+					goto out;
+				}
+			}
+	
+			msblk->block_cache[i].block = SQUASHFS_USED_BLK;
+			up(&msblk->block_cache_mutex);
+
+			if (!(msblk->block_cache[i].length =
+						squashfs_read_data(s,
+						msblk->block_cache[i].data,
+						block, 0, &next_index))) {
+				ERROR("Unable to read cache block [%llx:%x]\n",
+						block, offset);
+				goto out;
+			}
+
+			down(&msblk->block_cache_mutex);
+			wake_up(&msblk->waitq);
+			msblk->block_cache[i].block = block;
+			msblk->block_cache[i].next_index = next_index;
+			TRACE("Read cache block [%llx:%x]\n", block, offset);
+		}
+
+		if (msblk->block_cache[i].block != block) {
+			up(&msblk->block_cache_mutex);
+			continue;
+		}
+
+		if ((bytes = msblk->block_cache[i].length - offset) >= length) {
+			if (buffer)
+				memcpy(buffer, msblk->block_cache[i].data +
+						offset, length);
+			if (msblk->block_cache[i].length - offset == length) {
+				*next_block = msblk->block_cache[i].next_index;
+				*next_offset = 0;
+			} else {
+				*next_block = block;
+				*next_offset = offset + length;
+			}
+			up(&msblk->block_cache_mutex);
+			goto finish;
+		} else {
+			if (buffer) {
+				memcpy(buffer, msblk->block_cache[i].data +
+						offset, bytes);
+				buffer += bytes;
+			}
+			block = msblk->block_cache[i].next_index;
+			up(&msblk->block_cache_mutex);
+			length -= bytes;
+			offset = 0;
+		}
+	}
+
+finish:
+	return return_length;
+out:
+	return 0;
+}
+
+
+static int get_fragment_location(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
+	struct squashfs_fragment_entry fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment)
+{
+	down(&msblk->fragment_mutex);
+	fragment->locked --;
+	wake_up(&msblk->fragment_wait_queue);
+	up(&msblk->fragment_mutex);
+}
+
+
+SQSH_EXTERN struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length)
+{
+	int i, n;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+
+	while ( 1 ) {
+		down(&msblk->fragment_mutex);
+
+		for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&
+				msblk->fragment[i].block != start_block; i++);
+
+		if (i == SQUASHFS_CACHED_FRAGMENTS) {
+			for (i = msblk->next_fragment, n =
+				SQUASHFS_CACHED_FRAGMENTS; n &&
+				msblk->fragment[i].locked; n--, i = (i + 1) %
+				SQUASHFS_CACHED_FRAGMENTS);
+
+			if (n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msblk->fragment_wait_queue,
+									&wait);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				up(&msblk->fragment_mutex);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msblk->fragment_wait_queue,
+									&wait);
+				continue;
+			}
+			msblk->next_fragment = (msblk->next_fragment + 1) %
+				SQUASHFS_CACHED_FRAGMENTS;
+			
+			if (msblk->fragment[i].data == NULL)
+				if (!(msblk->fragment[i].data = SQUASHFS_ALLOC
+						(SQUASHFS_FILE_MAX_SIZE))) {
+					ERROR("Failed to allocate fragment "
+							"cache block\n");
+					up(&msblk->fragment_mutex);
+					goto out;
+				}
+
+			msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msblk->fragment[i].locked = 1;
+			up(&msblk->fragment_mutex);
+
+			if (!(msblk->fragment[i].length = squashfs_read_data(s,
+						msblk->fragment[i].data,
+						start_block, length, NULL))) {
+				ERROR("Unable to read fragment cache block "
+							"[%llx]\n", start_block);
+				msblk->fragment[i].locked = 0;
+				goto out;
+			}
+
+			msblk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %lld, locked %d\n",
+						i, msblk->fragment[i].block,
+						msblk->fragment[i].locked);
+			break;
+		}
+
+		msblk->fragment[i].locked++;
+		up(&msblk->fragment_mutex);
+		TRACE("Got fragment %d, start block %lld, locked %d\n", i,
+						msblk->fragment[i].block,
+						msblk->fragment[i].locked);
+		break;
+	}
+
+	return &msblk->fragment[i];
+
+out:
+	return NULL;
+}
+
+
+static struct inode *squashfs_new_inode(struct super_block *s,
+		struct squashfs_base_inode_header *inodeb)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct inode *i = new_inode(s);
+
+	if (i) {
+		i->i_ino = inodeb->inode_number;
+		i->i_mtime.tv_sec = inodeb->mtime;
+		i->i_atime.tv_sec = inodeb->mtime;
+		i->i_ctime.tv_sec = inodeb->mtime;
+		i->i_uid = msblk->uid[inodeb->uid];
+		i->i_mode = inodeb->mode;
+		i->i_size = 0;
+		if (inodeb->guid == SQUASHFS_GUIDS)
+			i->i_gid = i->i_uid;
+		else
+			i->i_gid = msblk->guid[inodeb->guid];
+	}
+
+	return i;
+}
+
+
+static struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode)
+{
+	struct inode *i;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header id, sid;
+	struct squashfs_base_inode_header *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_iget\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_reg_inode_header *inodep = &id.reg;
+			struct squashfs_reg_inode_header *sinodep = &sid.reg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = 1;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_lreg_inode_header *inodep = &id.lreg;
+			struct squashfs_lreg_inode_header *sinodep = &sid.lreg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inodep = &id.dir;
+			struct squashfs_dir_inode_header *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inodep = &id.dev;
+			struct squashfs_dev_inode_header *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if ((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			struct squashfs_ipc_inode_header *inodep = &id.ipc;
+			struct squashfs_ipc_inode_header *sinodep = &sid.ipc;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if ((i = squashfs_new_inode(s, inodeb)) == NULL)
+				goto failed_read1;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	insert_inode_hash(i);
+	return i;
+
+failed_read:
+	ERROR("Unable to read inode [%llx:%x]\n", block, offset);
+
+failed_read1:
+	return NULL;
+}
+
+
+static int read_fragment_index_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	/* Allocate fragment index table */
+	if (!(msblk->fragment_index = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+   
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),
+						&msblk->fragment_index[i], 1);
+			msblk->fragment_index[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->iget = squashfs_iget;
+	msblk->read_blocklist = read_blocklist;
+	msblk->read_fragment_index_table = read_fragment_index_table;
+
+	if (sblk->s_major == 1) {
+		if (!squashfs_1_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with "
+				"Squashfs 1.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major == 2) {
+		if (!squashfs_2_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with "
+				"Squashfs 2.0 support enabled\n");
+			return 0;
+		}
+	} else if(sblk->s_major != SQUASHFS_MAJOR || sblk->s_minor >
+			SQUASHFS_MINOR) {
+		SERROR("Major/Minor mismatch, trying to mount newer %d.%d "
+				"filesystem\n", sblk->s_major, sblk->s_minor);
+		SERROR("Please update your kernel\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static int squashfs_fill_super(struct super_block *s, void *data, int silent)
+{
+	struct squashfs_sb_info *msblk;
+	struct squashfs_super_block *sblk;
+	int i;
+	char b[BDEVNAME_SIZE];
+	struct inode *root;
+
+	TRACE("Entered squashfs_read_superblock\n");
+
+	if (!(s->s_fs_info = kmalloc(sizeof(struct squashfs_sb_info),
+						GFP_KERNEL))) {
+		ERROR("Failed to allocate superblock\n");
+		goto failure;
+	}
+	memset(s->s_fs_info, 0, sizeof(struct squashfs_sb_info));
+	msblk = s->s_fs_info;
+	sblk = &msblk->sblk;
+	
+	msblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msblk->devblksize_log2 = ffz(~msblk->devblksize);
+
+	init_MUTEX(&msblk->read_data_mutex);
+	init_MUTEX(&msblk->read_page_mutex);
+	init_MUTEX(&msblk->block_cache_mutex);
+	init_MUTEX(&msblk->fragment_mutex);
+	init_MUTEX(&msblk->meta_index_mutex);
+	
+	init_waitqueue_head(&msblk->waitq);
+	init_waitqueue_head(&msblk->fragment_wait_queue);
+
+	if (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,
+					sizeof(struct squashfs_super_block) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		SERROR("unable to read superblock\n");
+		goto failed_mount;
+	}
+
+	/* Check it is a SQUASHFS superblock */
+	msblk->swap = 0;
+	if ((s->s_magic = sblk->s_magic) != SQUASHFS_MAGIC) {
+		if (sblk->s_magic == SQUASHFS_MAGIC_SWAP) {
+			struct squashfs_super_block ssblk;
+
+			WARNING("Mounting a different endian SQUASHFS "
+				"filesystem on %s\n", bdevname(s->s_bdev, b));
+
+			SQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);
+			memcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));
+			msblk->swap = 1;
+		} else  {
+			SERROR("Can't find a SQUASHFS superblock on %s\n",
+							bdevname(s->s_bdev, b));
+			goto failed_mount;
+		}
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	if(!supported_squashfs_filesystem(msblk, silent))
+		goto failed_mount;
+
+	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
+	TRACE("Inodes are %scompressed\n",
+					SQUASHFS_UNCOMPRESSED_INODES
+					(sblk->flags) ? "un" : "");
+	TRACE("Data is %scompressed\n",
+					SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)
+					? "un" : "");
+	TRACE("Check data is %s present in the filesystem\n",
+					SQUASHFS_CHECK_DATA(sblk->flags) ?
+					"" : "not");
+	TRACE("Filesystem size %lld bytes\n", sblk->bytes_used);
+	TRACE("Block size %d\n", sblk->block_size);
+	TRACE("Number of inodes %d\n", sblk->inodes);
+	if (sblk->s_major > 1)
+		TRACE("Number of fragments %d\n", sblk->fragments);
+	TRACE("Number of uids %d\n", sblk->no_uids);
+	TRACE("Number of gids %d\n", sblk->no_guids);
+	TRACE("sblk->inode_table_start %llx\n", sblk->inode_table_start);
+	TRACE("sblk->directory_table_start %llx\n", sblk->directory_table_start);
+	if (sblk->s_major > 1)
+		TRACE("sblk->fragment_table_start %llx\n",
+					sblk->fragment_table_start);
+	TRACE("sblk->uid_start %llx\n", sblk->uid_start);
+
+	s->s_flags |= MS_RDONLY;
+	s->s_op = &squashfs_ops;
+
+	/* Init inode_table block pointer array */
+	if (!(msblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *
+					SQUASHFS_CACHED_BLKS, GFP_KERNEL))) {
+		ERROR("Failed to allocate block cache\n");
+		goto failed_mount;
+	}
+
+	for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+		msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msblk->next_cache = 0;
+
+	/* Allocate read_data block */
+	msblk->read_size = (sblk->block_size < SQUASHFS_METADATA_SIZE) ?
+					SQUASHFS_METADATA_SIZE :
+					sblk->block_size;
+
+	if (!(msblk->read_data = kmalloc(msblk->read_size, GFP_KERNEL))) {
+		ERROR("Failed to allocate read_data block\n");
+		goto failed_mount;
+	}
+
+	/* Allocate read_page block */
+	if (!(msblk->read_page = kmalloc(sblk->block_size, GFP_KERNEL))) {
+		ERROR("Failed to allocate read_page block\n");
+		goto failed_mount;
+	}
+
+	/* Allocate uid and gid tables */
+	if (!(msblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *
+					sizeof(unsigned int), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto failed_mount;
+	}
+	msblk->guid = msblk->uid + sblk->no_uids;
+   
+	if (msblk->swap) {
+		unsigned int suid[sblk->no_uids + sblk->no_guids];
+
+		if (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+		SQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +
+			sblk->no_guids), (sizeof(unsigned int) * 8));
+	} else
+		if (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+
+	if (sblk->s_major == 1 && squashfs_1_0_supported(msblk))
+		goto allocate_root;
+
+	if (!(msblk->fragment = kmalloc(sizeof(struct squashfs_fragment_cache) *
+				SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL))) {
+		ERROR("Failed to allocate fragment block cache\n");
+		goto failed_mount;
+	}
+
+	for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msblk->fragment[i].locked = 0;
+		msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+		msblk->fragment[i].data = NULL;
+	}
+
+	msblk->next_fragment = 0;
+
+	/* Allocate fragment index table */
+	if (msblk->read_fragment_index_table(s) == 0)
+		goto failed_mount;
+
+allocate_root:
+	if ((root = (msblk->iget)(s, sblk->root_inode)) == NULL)
+		goto failed_mount;
+
+	if ((s->s_root = d_alloc_root(root)) == NULL) {
+		ERROR("Root inode create failed\n");
+		iput(root);
+		goto failed_mount;
+	}
+
+	TRACE("Leaving squashfs_read_super\n");
+	return 0;
+
+failed_mount:
+	kfree(msblk->fragment_index);
+	kfree(msblk->fragment);
+	kfree(msblk->uid);
+	kfree(msblk->read_page);
+	kfree(msblk->read_data);
+	kfree(msblk->block_cache);
+	kfree(msblk->fragment_index_2);
+	kfree(s->s_fs_info);
+	s->s_fs_info = NULL;
+	return -EINVAL;
+
+failure:
+	return -ENOMEM;
+}
+
+
+static int squashfs_statfs(struct super_block *s, struct kstatfs *buf)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	TRACE("Entered squashfs_statfs\n");
+
+	buf->f_type = SQUASHFS_MAGIC;
+	buf->f_bsize = sblk->block_size;
+	buf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;
+	buf->f_bfree = buf->f_bavail = 0;
+	buf->f_files = sblk->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SQUASHFS_NAME_LEN;
+
+	return 0;
+}
+
+
+static int squashfs_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes;
+	long long block = SQUASHFS_I(inode)->start_block;
+	int offset = SQUASHFS_I(inode)->offset;
+	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_symlink_readpage, page index %ld, start block "
+				"%llx, offset %x\n", page->index,
+				SQUASHFS_I(inode)->start_block,
+				SQUASHFS_I(inode)->offset);
+
+	for (length = 0; length < index; length += bytes) {
+		if (!(bytes = squashfs_get_cached_block(inode->i_sb, NULL,
+				block, offset, PAGE_CACHE_SIZE, &block,
+				&offset))) {
+			ERROR("Unable to read symbolic link [%llx:%x]\n", block,
+					offset);
+			goto skip_read;
+		}
+	}
+
+	if (length != index) {
+		ERROR("(squashfs_symlink_readpage) length != index\n");
+		bytes = 0;
+		goto skip_read;
+	}
+
+	bytes = (i_size_read(inode) - length) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE :
+					i_size_read(inode) - length;
+
+	if (!(bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block,
+					offset, bytes, &block, &offset)))
+		ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)
+{
+	struct meta_index *meta = NULL;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int i;
+
+	down(&msblk->meta_index_mutex);
+
+	TRACE("locate_meta_index: index %d, offset %d\n", index, offset);
+
+	if(msblk->meta_index == NULL)
+		goto not_allocated;
+
+	for (i = 0; i < SQUASHFS_META_NUMBER; i ++)
+		if (msblk->meta_index[i].inode_number == inode->i_ino &&
+				msblk->meta_index[i].offset >= offset &&
+				msblk->meta_index[i].offset <= index &&
+				msblk->meta_index[i].locked == 0) {
+			TRACE("locate_meta_index: entry %d, offset %d\n", i,
+					msblk->meta_index[i].offset);
+			meta = &msblk->meta_index[i];
+			offset = meta->offset;
+		}
+
+	if (meta)
+		meta->locked = 1;
+
+not_allocated:
+	up(&msblk->meta_index_mutex);
+
+	return meta;
+}
+
+
+struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct meta_index *meta = NULL;
+	int i;
+
+	down(&msblk->meta_index_mutex);
+
+	TRACE("empty_meta_index: offset %d, skip %d\n", offset, skip);
+
+	if(msblk->meta_index == NULL) {
+		if (!(msblk->meta_index = kmalloc(sizeof(struct meta_index) *
+					SQUASHFS_META_NUMBER, GFP_KERNEL))) {
+			ERROR("Failed to allocate meta_index\n");
+			goto failed;
+		}
+		for(i = 0; i < SQUASHFS_META_NUMBER; i++) {
+			msblk->meta_index[i].inode_number = 0;
+			msblk->meta_index[i].locked = 0;
+		}
+		msblk->next_meta_index = 0;
+	}
+
+	for(i = SQUASHFS_META_NUMBER; i &&
+			msblk->meta_index[msblk->next_meta_index].locked; i --)
+		msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	if(i == 0) {
+		TRACE("empty_meta_index: failed!\n");
+		goto failed;
+	}
+
+	TRACE("empty_meta_index: returned meta entry %d, %p\n",
+			msblk->next_meta_index,
+			&msblk->meta_index[msblk->next_meta_index]);
+
+	meta = &msblk->meta_index[msblk->next_meta_index];
+	msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	meta->inode_number = inode->i_ino;
+	meta->offset = offset;
+	meta->skip = skip;
+	meta->entries = 0;
+	meta->locked = 1;
+
+failed:
+	up(&msblk->meta_index_mutex);
+	return meta;
+}
+
+
+void release_meta_index(struct inode *inode, struct meta_index *meta)
+{
+	meta->locked = 0;
+}
+
+
+static int read_block_index(struct super_block *s, int blocks, char *block_list,
+		long long *start_block, int *offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned int *block_listp;
+	int block = 0;
+	
+	if (msblk->swap) {
+		char sblock_list[blocks << 2];
+
+		if (!squashfs_get_cached_block(s, sblock_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Unable to read block list [%llx:%x]\n",
+				*start_block, *offset);
+			goto failure;
+		}
+		SQUASHFS_SWAP_INTS(((unsigned int *)block_list),
+				((unsigned int *)sblock_list), blocks);
+	} else
+		if (!squashfs_get_cached_block(s, block_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Unable to read block list [%llx:%x]\n",
+				*start_block, *offset);
+			goto failure;
+		}
+
+	for (block_listp = (unsigned int *) block_list; blocks;
+				block_listp++, blocks --)
+		block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
+
+	return block;
+
+failure:
+	return -1;
+}
+
+
+#define SIZE 256
+
+static inline int calculate_skip(int blocks) {
+	int skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);
+	return skip >= 7 ? 7 : skip + 1;
+}
+
+
+static int get_meta_index(struct inode *inode, int index,
+		long long *index_block, int *index_offset,
+		long long *data_block, char *block_list)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int skip = calculate_skip(i_size_read(inode) >> sblk->block_log);
+	int offset = 0;
+	struct meta_index *meta;
+	struct meta_entry *meta_entry;
+	long long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;
+	int cur_offset = SQUASHFS_I(inode)->offset;
+	long long cur_data_block = SQUASHFS_I(inode)->start_block;
+	int i;
+ 
+	index /= SQUASHFS_META_INDEXES * skip;
+
+	while ( offset < index ) {
+		meta = locate_meta_index(inode, index, offset + 1);
+
+		if (meta == NULL) {
+			if ((meta = empty_meta_index(inode, offset + 1,
+							skip)) == NULL)
+				goto all_done;
+		} else {
+			offset = index < meta->offset + meta->entries ? index :
+				meta->offset + meta->entries - 1;
+			meta_entry = &meta->meta_entry[offset - meta->offset];
+			cur_index_block = meta_entry->index_block + sblk->inode_table_start;
+			cur_offset = meta_entry->offset;
+			cur_data_block = meta_entry->data_block;
+			TRACE("get_meta_index: offset %d, meta->offset %d, "
+				"meta->entries %d\n", offset, meta->offset,
+				meta->entries);
+			TRACE("get_meta_index: index_block 0x%llx, offset 0x%x"
+				" data_block 0x%llx\n", cur_index_block,
+				cur_offset, cur_data_block);
+		}
+
+		for (i = meta->offset + meta->entries; i <= index &&
+				i < meta->offset + SQUASHFS_META_ENTRIES; i++) {
+			int blocks = skip * SQUASHFS_META_INDEXES;
+
+			while (blocks) {
+				int block = blocks > (SIZE >> 2) ? (SIZE >> 2) :
+					blocks;
+				int res = read_block_index(inode->i_sb, block,
+					block_list, &cur_index_block,
+					&cur_offset);
+
+				if (res == -1)
+					goto failed;
+
+				cur_data_block += res;
+				blocks -= block;
+			}
+
+			meta_entry = &meta->meta_entry[i - meta->offset];
+			meta_entry->index_block = cur_index_block - sblk->inode_table_start;
+			meta_entry->offset = cur_offset;
+			meta_entry->data_block = cur_data_block;
+			meta->entries ++;
+			offset ++;
+		}
+
+		TRACE("get_meta_index: meta->offset %d, meta->entries %d\n",
+				meta->offset, meta->entries);
+
+		release_meta_index(inode, meta);
+	}
+
+all_done:
+	*index_block = cur_index_block;
+	*index_offset = cur_offset;
+	*data_block = cur_data_block;
+
+	return offset * SQUASHFS_META_INDEXES * skip;
+
+failed:
+	release_meta_index(inode, meta);
+	return -1;
+}
+
+
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize)
+{
+	long long block_ptr;
+	int offset;
+	long long block;
+	int res = get_meta_index(inode, index, &block_ptr, &offset, &block,
+		block_list);
+
+	TRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"
+		       " 0x%x, block 0x%llx\n", res, index, block_ptr, offset,
+		       block);
+
+	if(res == -1)
+		goto failure;
+
+	index -= res;
+
+	while ( index ) {
+		int blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;
+		int res = read_block_index(inode->i_sb, blocks, block_list,
+			&block_ptr, &offset);
+		if (res == -1)
+			goto failure;
+		block += res;
+		index -= blocks;
+	}
+
+	if (read_block_index(inode->i_sb, 1, block_list,
+			&block_ptr, &offset) == -1)
+		goto failure;
+	*bsize = *((unsigned int *) block_list);
+
+	return block;
+
+failure:
+	return 0;
+}
+
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char block_list[SIZE];
+	long long block;
+	unsigned int bsize, i = 0, bytes = 0, byte_offset = 0;
+	int index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr;
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msblk->read_page;
+	
+	int mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+					page->index,
+					SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto skip_read;
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < (i_size_read(inode) >>
+					sblk->block_log)) {
+		if ((block = (msblk->read_blocklist)(inode, index, 1,
+					block_list, NULL, &bsize)) == 0)
+			goto skip_read;
+
+		down(&msblk->read_page_mutex);
+		
+		if (!(bytes = squashfs_read_data(inode->i_sb, msblk->read_page,
+					block, bsize, NULL))) {
+			ERROR("Unable to read page, block %llx, size %x\n", block,
+					bsize);
+			up(&msblk->read_page_mutex);
+			goto skip_read;
+		}
+	} else {
+		if ((fragment = get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					SQUASHFS_I(inode)->u.s1.fragment_size))
+					== NULL) {
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					(int) SQUASHFS_I(inode)->
+					u.s1.fragment_size);
+			goto skip_read;
+		}
+		bytes = SQUASHFS_I(inode)->u.s1.fragment_offset +
+					(i_size_read(inode) & (sblk->block_size
+					- 1));
+		byte_offset = SQUASHFS_I(inode)->u.s1.fragment_offset;
+		data_ptr = fragment->data;
+	}
+
+	for (i = start_index; i <= end_index && byte_offset < bytes;
+					i++, byte_offset += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int available_bytes = (bytes - byte_offset) > PAGE_CACHE_SIZE ?
+					PAGE_CACHE_SIZE : bytes - byte_offset;
+
+		TRACE("bytes %d, i %d, byte_offset %d, available_bytes %d\n",
+					bytes, i, byte_offset, available_bytes);
+
+		if (i == page->index)  {
+			pageaddr = kmap_atomic(page, KM_USER0);
+			memcpy(pageaddr, data_ptr + byte_offset,
+					available_bytes);
+			memset(pageaddr + available_bytes, 0,
+					PAGE_CACHE_SIZE - available_bytes);
+			kunmap_atomic(pageaddr, KM_USER0);
+			flush_dcache_page(page);
+			SetPageUptodate(page);
+			unlock_page(page);
+		} else if ((push_page =
+				grab_cache_page_nowait(page->mapping, i))) {
+ 			pageaddr = kmap_atomic(push_page, KM_USER0);
+
+			memcpy(pageaddr, data_ptr + byte_offset,
+					available_bytes);
+			memset(pageaddr + available_bytes, 0,
+					PAGE_CACHE_SIZE - available_bytes);
+			kunmap_atomic(pageaddr, KM_USER0);
+			flush_dcache_page(push_page);
+			SetPageUptodate(push_page);
+			unlock_page(push_page);
+			page_cache_release(push_page);
+		}
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < (i_size_read(inode) >>
+					sblk->block_log))
+		up(&msblk->read_page_mutex);
+	else
+		release_cached_fragment(msblk, fragment);
+
+	return 0;
+
+skip_read:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+static int squashfs_readpage4K(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char block_list[SIZE];
+	long long block;
+	unsigned int bsize, bytes = 0;
+ 	void *pageaddr;
+	
+	TRACE("Entered squashfs_readpage4K, page index %lx, start block %llx\n",
+					page->index,
+					SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT)) {
+		pageaddr = kmap_atomic(page, KM_USER0);
+		goto skip_read;
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| page->index < (i_size_read(inode) >>
+					sblk->block_log)) {
+		block = (msblk->read_blocklist)(inode, page->index, 1,
+					block_list, NULL, &bsize);
+
+		down(&msblk->read_page_mutex);
+		bytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,
+					bsize, NULL);
+		pageaddr = kmap_atomic(page, KM_USER0);
+		if (bytes)
+			memcpy(pageaddr, msblk->read_page, bytes);
+		else
+			ERROR("Unable to read page, block %llx, size %x\n",
+					block, bsize);
+		up(&msblk->read_page_mutex);
+	} else {
+		struct squashfs_fragment_cache *fragment =
+			get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					SQUASHFS_I(inode)-> u.s1.fragment_size);
+		pageaddr = kmap_atomic(page, KM_USER0);
+		if (fragment) {
+			bytes = i_size_read(inode) & (sblk->block_size - 1);
+			memcpy(pageaddr, fragment->data + SQUASHFS_I(inode)->
+					u.s1.fragment_offset, bytes);
+			release_cached_fragment(msblk, fragment);
+		} else
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block, (int)
+					SQUASHFS_I(inode)-> u.s1.fragment_size);
+	}
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	f_pos =- 3;
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length + 3;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	char buffer[sizeof(struct squashfs_dir_index) + SQUASHFS_NAME_LEN + 1];
+	struct squashfs_dir_index *index = (struct squashfs_dir_index *) buffer;
+	char str[SQUASHFS_NAME_LEN + 1];
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	return length + 3;
+}
+
+		
+static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dirs_read = 0,
+		dir_count;
+	struct squashfs_dir_header dirh;
+	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1];
+	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;
+
+	TRACE("Entered squashfs_readdir [%llx:%x]\n", next_block, next_offset);
+
+	while(file->f_pos < 3) {
+		char *name;
+		int size, i_ino;
+
+		if(file->f_pos == 0) {
+			name = ".";
+			size = 1;
+			i_ino = i->i_ino;
+		} else {
+			name = "..";
+			size = 2;
+			i_ino = SQUASHFS_I(i)->u.s2.parent_inode;
+		}
+		TRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\n",
+				(unsigned int) dirent, name, size, (int)
+				file->f_pos, i_ino,
+				squashfs_filetype_table[1]);
+
+		if (filldir(dirent, name, size,
+				file->f_pos, i_ino,
+				squashfs_filetype_table[1]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+		}
+		file->f_pos += size;
+		dirs_read++;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+			dirs_read++;
+		}
+	}
+
+finish:
+	return dirs_read;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header dirh;
+	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN];
+	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %d\n", name,
+					dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number);
+
+				inode = (msblk->iget)(i->i_sb, ino);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+static void squashfs_put_super(struct super_block *s)
+{
+	int i;
+
+	if (s->s_fs_info) {
+		struct squashfs_sb_info *sbi = s->s_fs_info;
+		if (sbi->block_cache)
+			for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+				if (sbi->block_cache[i].block !=
+							SQUASHFS_INVALID_BLK)
+					kfree(sbi->block_cache[i].data);
+		if (sbi->fragment)
+			for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) 
+				SQUASHFS_FREE(sbi->fragment[i].data);
+		kfree(sbi->fragment);
+		kfree(sbi->block_cache);
+		kfree(sbi->read_data);
+		kfree(sbi->read_page);
+		kfree(sbi->uid);
+		kfree(sbi->fragment_index);
+		kfree(sbi->fragment_index_2);
+		kfree(sbi->meta_index);
+		kfree(s->s_fs_info);
+		s->s_fs_info = NULL;
+	}
+}
+
+
+static struct super_block *squashfs_get_sb(struct file_system_type *fs_type,
+				int flags, const char *dev_name, void *data)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super);
+}
+
+
+static int __init init_squashfs_fs(void)
+{
+	int err = init_inodecache();
+	if (err)
+		goto out;
+
+	printk(KERN_INFO "squashfs: version 3.0 (2006/03/15) "
+		"Phillip Lougher\n");
+
+	if (!(stream.workspace = vmalloc(zlib_inflate_workspacesize()))) {
+		ERROR("Failed to allocate zlib workspace\n");
+		destroy_inodecache();
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if ((err = register_filesystem(&squashfs_fs_type))) {
+		vfree(stream.workspace);
+		destroy_inodecache();
+	}
+
+out:
+	return err;
+}
+
+
+static void __exit exit_squashfs_fs(void)
+{
+	vfree(stream.workspace);
+	unregister_filesystem(&squashfs_fs_type);
+	destroy_inodecache();
+}
+
+
+static kmem_cache_t * squashfs_inode_cachep;
+
+
+static struct inode *squashfs_alloc_inode(struct super_block *sb)
+{
+	struct squashfs_inode_info *ei;
+	ei = kmem_cache_alloc(squashfs_inode_cachep, SLAB_KERNEL);
+	if (!ei)
+		return NULL;
+	return &ei->vfs_inode;
+}
+
+
+static void squashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));
+}
+
+
+static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct squashfs_inode_info *ei = foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+							SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&ei->vfs_inode);
+}
+ 
+
+static int __init init_inodecache(void)
+{
+	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
+	     sizeof(struct squashfs_inode_info),
+	     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT,
+	     init_once, NULL);
+	if (squashfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+
+static void destroy_inodecache(void)
+{
+	if (kmem_cache_destroy(squashfs_inode_cachep))
+		printk(KERN_INFO "squashfs_inode_cache: not all structures "
+			"were freed\n");
+}
+
+
+module_init(init_squashfs_fs);
+module_exit(exit_squashfs_fs);
+MODULE_DESCRIPTION("squashfs, a compressed read-only filesystem");
+MODULE_AUTHOR("Phillip Lougher <phillip@lougher.org.uk>");
+MODULE_LICENSE("GPL");
diff --git a/fs/squashfs/squashfs.h b/fs/squashfs/squashfs.h
new file mode 100644
index 0000000000..dcbef0d11c
--- /dev/null
+++ b/fs/squashfs/squashfs.h
@@ -0,0 +1,86 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs.h
+ */
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#endif
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)	{}
+#endif
+
+#define ERROR(s, args...)	printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)	do { \
+				if (!silent) \
+				printk(KERN_ERR "SQUASHFS error: "s, ## args);\
+				} while(0)
+
+#define WARNING(s, args...)	printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)
+#define SQSH_EXTERN
+extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+				long long index, unsigned int length,
+				long long *next_index);
+extern int squashfs_get_cached_block(struct super_block *s, char *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset);
+extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment);
+extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length);
+extern struct address_space_operations squashfs_symlink_aops;
+extern struct address_space_operations squashfs_aops;
+extern struct address_space_operations squashfs_aops_4K;
+extern struct inode_operations squashfs_dir_inode_ops;
+#else
+#define SQSH_EXTERN static
+#endif
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
diff --git a/fs/squashfs/squashfs2_0.c b/fs/squashfs/squashfs2_0.c
new file mode 100644
index 0000000000..d846eb1bdb
--- /dev/null
+++ b/fs/squashfs/squashfs2_0.c
@@ -0,0 +1,758 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs2_0.c
+ */
+
+#include <linux/types.h>
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/init.h>
+#include <linux/dcache.h>
+#include <linux/wait.h>
+#include <linux/zlib.h>
+#include <linux/blkdev.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+#include "squashfs.h"
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);
+static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,
+				struct nameidata *);
+
+static struct file_operations squashfs_dir_ops_2 = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir_2
+};
+
+static struct inode_operations squashfs_dir_inode_ops_2 = {
+	.lookup = squashfs_lookup_2
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static int read_fragment_index_table_2(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	if (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+   
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index_2,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		unsigned int fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),
+						&msblk->fragment_index_2[i], 1);
+			msblk->fragment_index_2[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int get_fragment_location_2(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);
+	struct squashfs_fragment_entry_2 fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry_2 sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+static struct inode *squashfs_new_inode(struct super_block *s,
+		struct squashfs_base_inode_header_2 *inodeb, unsigned int ino)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	struct inode *i = new_inode(s);
+
+	if (i) {
+		i->i_ino = ino;
+		i->i_mtime.tv_sec = sblk->mkfs_time;
+		i->i_atime.tv_sec = sblk->mkfs_time;
+		i->i_ctime.tv_sec = sblk->mkfs_time;
+		i->i_uid = msblk->uid[inodeb->uid];
+		i->i_mode = inodeb->mode;
+		i->i_nlink = 1;
+		i->i_size = 0;
+		if (inodeb->guid == SQUASHFS_GUIDS)
+			i->i_gid = i->i_uid;
+		else
+			i->i_gid = msblk->guid[inodeb->guid];
+	}
+
+	return i;
+}
+
+
+static struct inode *squashfs_iget_2(struct super_block *s, squashfs_inode_t inode)
+{
+	struct inode *i;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int ino = SQUASHFS_MK_VFS_INODE(block
+		- sblk->inode_table_start, offset);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header_2 id, sid;
+	struct squashfs_base_inode_header_2 *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_iget\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header_2 *inodep = &id.reg;
+			struct squashfs_reg_inode_header_2 *sinodep = &sid.reg;
+			long long frag_blk;
+			unsigned int frag_size;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location_2(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			i->i_blksize = PAGE_CACHE_SIZE;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %x, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header_2 *inodep = &id.dir;
+			struct squashfs_dir_inode_header_2 *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header_2 *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header_2 *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header_2 *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header_2 *inodep = &id.dev;
+			struct squashfs_dev_inode_header_2 *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			if ((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			if ((i = squashfs_new_inode(s, inodeb, ino)) == NULL)
+				goto failed_read1;
+
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	insert_inode_hash(i);
+	return i;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return NULL;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	char buffer[sizeof(struct squashfs_dir_index_2) + SQUASHFS_NAME_LEN + 1];
+	struct squashfs_dir_index_2 *index = (struct squashfs_dir_index_2 *) buffer;
+	char str[SQUASHFS_NAME_LEN + 1];
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index_2),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	return length;
+}
+
+		
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dirs_read = 0,
+		dir_count;
+	struct squashfs_dir_header_2 dirh;
+	char buffer[sizeof(struct squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1];
+	struct squashfs_dir_entry_2 *dire = (struct squashfs_dir_entry_2 *) buffer;
+
+	TRACE("Entered squashfs_readdir_2 [%llx:%x]\n", next_block, next_offset);
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos, SQUASHFS_MK_VFS_INODE(
+					dirh.start_block, dire->offset),
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+			dirs_read++;
+		}
+	}
+
+finish:
+	return dirs_read;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header_2 dirh;
+	char buffer[sizeof(struct squashfs_dir_entry_2) + SQUASHFS_NAME_LEN];
+	struct squashfs_dir_entry_2 *dire = (struct squashfs_dir_entry_2 *) buffer;
+	int sorted = sblk->s_major == 2 && sblk->s_minor >= 1;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (sorted && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %lld\n", name,
+					dirh.start_block, dire->offset, ino);
+
+				inode = (msblk->iget)(i->i_sb, ino);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->iget = squashfs_iget_2;
+	msblk->read_fragment_index_table = read_fragment_index_table_2;
+
+	sblk->bytes_used = sblk->bytes_used_2;
+	sblk->uid_start = sblk->uid_start_2;
+	sblk->guid_start = sblk->guid_start_2;
+	sblk->inode_table_start = sblk->inode_table_start_2;
+	sblk->directory_table_start = sblk->directory_table_start_2;
+	sblk->fragment_table_start = sblk->fragment_table_start_2;
+
+	return 1;
+}
diff --git a/include/asm-sparc64/numnodes.h b/include/asm-sparc64/numnodes.h
new file mode 100644
index 0000000000..017e7e74f5
--- /dev/null
+++ b/include/asm-sparc64/numnodes.h
@@ -0,0 +1,6 @@
+#ifndef _SPARC64_NUMNODES_H
+#define _SPARC64_NUMNODES_H
+
+#define NODES_SHIFT	0
+
+#endif /* !(_SPARC64_NUMNODES_H) */
diff --git a/include/asm-sparc64/page.h b/include/asm-sparc64/page.h
index 5426bb28a9..af13d32be6 100644
--- a/include/asm-sparc64/page.h
+++ b/include/asm-sparc64/page.h
@@ -124,17 +124,10 @@ typedef unsigned long pgprot_t;
 #define __pa(x)			((unsigned long)(x) - PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long) (x) + PAGE_OFFSET))
 
-/* PFNs are real physical page numbers.  However, mem_map only begins to record
- * per-page information starting at pfn_base.  This is to handle systems where
- * the first physical page in the machine is at some huge physical address,
- * such as 4GB.   This is common on a partitioned E10000, for example.
- */
-extern struct page *pfn_to_page(unsigned long pfn);
-extern unsigned long page_to_pfn(struct page *);
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 
 #define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr)>>PAGE_SHIFT)
 
-#define pfn_valid(pfn)		(((pfn)-(pfn_base)) < max_mapnr)
 #define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
 
 #define virt_to_phys __pa
diff --git a/include/asm-sparc64/pgtable.h b/include/asm-sparc64/pgtable.h
index 3d6dff2ca1..de09ffd2ef 100644
--- a/include/asm-sparc64/pgtable.h
+++ b/include/asm-sparc64/pgtable.h
@@ -212,9 +212,6 @@
 
 #ifndef __ASSEMBLY__
 
-extern unsigned long phys_base;
-extern unsigned long pfn_base;
-
 extern struct page *mem_map_zero;
 #define ZERO_PAGE(vaddr)	(mem_map_zero)
 
diff --git a/include/asm-sparc64/sparsemem.h b/include/asm-sparc64/sparsemem.h
new file mode 100644
index 0000000000..ed5c9d8541
--- /dev/null
+++ b/include/asm-sparc64/sparsemem.h
@@ -0,0 +1,12 @@
+#ifndef _SPARC64_SPARSEMEM_H
+#define _SPARC64_SPARSEMEM_H
+
+#ifdef __KERNEL__
+
+#define SECTION_SIZE_BITS       26
+#define MAX_PHYSADDR_BITS       42
+#define MAX_PHYSMEM_BITS        42
+
+#endif /* !(__KERNEL__) */
+
+#endif /* !(_SPARC64_SPARSEMEM_H) */
diff --git a/include/linux/console_splash.h b/include/linux/console_splash.h
new file mode 100644
index 0000000000..c448dd297f
--- /dev/null
+++ b/include/linux/console_splash.h
@@ -0,0 +1,13 @@
+#ifndef _LINUX_CONSOLE_SPLASH_H_
+#define _LINUX_CONSOLE_SPLASH_H_ 1
+
+/* A structure used by the framebuffer splash code (drivers/video/fbsplash.c) */
+struct vc_splash {
+	__u8 bg_color;				/* The color that is to be treated as transparent */
+	__u8 state;				/* Current splash state: 0 = off, 1 = on */
+	__u16 tx, ty;				/* Top left corner coordinates of the text field */
+	__u16 twidth, theight;			/* Width and height of the text field */
+	char* theme;
+};
+
+#endif
diff --git a/include/linux/console_struct.h b/include/linux/console_struct.h
index f8e5587a0f..3e7f476699 100644
--- a/include/linux/console_struct.h
+++ b/include/linux/console_struct.h
@@ -14,6 +14,7 @@
 struct vt_struct;
 
 #define NPAR 16
+#include <linux/console_splash.h>
 
 struct vc_data {
 	unsigned short	vc_num;			/* Console number */
@@ -97,6 +98,8 @@ struct vc_data {
 	struct vc_data **vc_display_fg;		/* [!] Ptr to var holding fg console for this display */
 	unsigned long	vc_uni_pagedir;
 	unsigned long	*vc_uni_pagedir_loc;  /* [!] Location of uni_pagedir variable for this console */
+
+	struct vc_splash vc_splash;
 	/* additional information is in vt_kern.h */
 };
 
diff --git a/include/linux/fb.h b/include/linux/fb.h
index 2fdd8aeca2..6b9b5727d6 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -8,6 +8,13 @@
 #define FB_MAJOR		29
 #define FB_MAX			32	/* sufficient for now */
 
+struct fb_splash_iowrapper
+{
+	unsigned short vc;		/* Virtual console */
+	unsigned char origin;		/* Point of origin of the request */
+	void *data;
+};
+
 /* ioctls
    0x46 is 'F'								*/
 #define FBIOGET_VSCREENINFO	0x4600
@@ -35,7 +42,15 @@
 #define FBIOGET_HWCINFO         0x4616
 #define FBIOPUT_MODEINFO        0x4617
 #define FBIOGET_DISPINFO        0x4618
+#define FBIOSPLASH_SETCFG	_IOWR('F', 0x19, struct fb_splash_iowrapper)
+#define FBIOSPLASH_GETCFG	_IOR('F', 0x1A, struct fb_splash_iowrapper)
+#define FBIOSPLASH_SETSTATE	_IOWR('F', 0x1B, struct fb_splash_iowrapper)
+#define FBIOSPLASH_GETSTATE	_IOR('F', 0x1C, struct fb_splash_iowrapper)
+#define FBIOSPLASH_SETPIC 	_IOWR('F', 0x1D, struct fb_splash_iowrapper)
 
+#define FB_SPLASH_THEME_LEN		128	/* Maximum lenght of a theme name */
+#define FB_SPLASH_IO_ORIG_KERNEL	0	/* Kernel ioctl origin */
+#define FB_SPLASH_IO_ORIG_USER		1 	/* User ioctl origin */
 
 #define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
 #define FB_TYPE_PLANES			1	/* Non interleaved planes */
@@ -769,6 +784,9 @@ struct fb_info {
 #define FBINFO_STATE_SUSPENDED	1
 	u32 state;			/* Hardware state i.e suspend */
 	void *fbcon_par;                /* fbcon use-only private area */
+
+	struct fb_image splash;
+
 	/* From here on everything is device dependent */
 	void *par;	
 };
diff --git a/include/linux/input.h b/include/linux/input.h
index 1a418a9419..1a609e554d 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -12,8 +12,6 @@
 #ifdef __KERNEL__
 #include <linux/time.h>
 #include <linux/list.h>
-#include <linux/device.h>
-#include <linux/mod_devicetable.h>
 #else
 #include <sys/time.h>
 #include <sys/ioctl.h>
@@ -568,15 +566,15 @@ struct input_absinfo {
  * Switch events
  */
 
-#define SW_0		0x00
-#define SW_1		0x01
-#define SW_2		0x02
-#define SW_3		0x03
-#define SW_4		0x04
-#define SW_5		0x05
-#define SW_6		0x06
-#define SW_7		0x07
-#define SW_MAX		0x0f
+#define SW_0			0x00
+#define SW_1			0x01
+#define SW_2			0x02
+#define SW_3			0x03
+#define SW_4			0x04
+#define SW_5			0x05
+#define SW_6			0x06
+#define SW_7			0x07
+#define SW_MAX			0x0f
 
 /*
  * Misc events
@@ -796,55 +794,16 @@ struct ff_effect {
 
 #define FF_MAX		0x7f
 
-/* musn't be userspace visible since it uses kernel_ulong_t */
-#if defined(__KERNEL__) || defined (LINUX_MOD_DEVICETABLE_H)
-struct input_device_id {
-
-	kernel_ulong_t flags;
-
-	struct input_id id;
-
-	kernel_ulong_t evbit[EV_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t keybit[KEY_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t relbit[REL_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t absbit[ABS_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t mscbit[MSC_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t ledbit[LED_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t sndbit[SND_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t ffbit[FF_MAX/BITS_PER_LONG+1];
-	kernel_ulong_t swbit[SW_MAX/BITS_PER_LONG+1];
-
-	kernel_ulong_t driver_info;
-};
-#endif  /*  defined(__KERNEL__) || defined (LINUX_MOD_DEVICETABLE_H) */
-
-/*
- * Structure for hotplug & device<->driver matching.
- */
-
-#define INPUT_DEVICE_ID_MATCH_BUS	1
-#define INPUT_DEVICE_ID_MATCH_VENDOR	2
-#define INPUT_DEVICE_ID_MATCH_PRODUCT	4
-#define INPUT_DEVICE_ID_MATCH_VERSION	8
-
-#define INPUT_DEVICE_ID_MATCH_EVBIT	0x010
-#define INPUT_DEVICE_ID_MATCH_KEYBIT	0x020
-#define INPUT_DEVICE_ID_MATCH_RELBIT	0x040
-#define INPUT_DEVICE_ID_MATCH_ABSBIT	0x080
-#define INPUT_DEVICE_ID_MATCH_MSCIT	0x100
-#define INPUT_DEVICE_ID_MATCH_LEDBIT	0x200
-#define INPUT_DEVICE_ID_MATCH_SNDBIT	0x400
-#define INPUT_DEVICE_ID_MATCH_FFBIT	0x800
-#define INPUT_DEVICE_ID_MATCH_SWBIT	0x1000
-
 #ifdef __KERNEL__
 
 /*
  * In-kernel definitions.
  */
 
+#include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/timer.h>
+#include <linux/mod_devicetable.h>
 
 #define NBITS(x) (((x)/BITS_PER_LONG)+1)
 #define BIT(x)	(1UL<<((x)%BITS_PER_LONG))
@@ -945,9 +904,49 @@ struct input_dev {
 };
 #define to_input_dev(d) container_of(d, struct input_dev, cdev)
 
-#define INPUT_DEVICE_ID_MATCH_DEVICE\
+/*
+ * Verify that we are in sync with input_device_id mod_devicetable.h #defines
+ */
+
+#if EV_MAX != INPUT_DEVICE_ID_EV_MAX
+#error "EV_MAX and INPUT_DEVICE_ID_EV_MAX do not match"
+#endif
+
+#if KEY_MAX != INPUT_DEVICE_ID_KEY_MAX
+#error "KEY_MAX and INPUT_DEVICE_ID_KEY_MAX do not match"
+#endif
+
+#if REL_MAX != INPUT_DEVICE_ID_REL_MAX
+#error "REL_MAX and INPUT_DEVICE_ID_REL_MAX do not match"
+#endif
+
+#if ABS_MAX != INPUT_DEVICE_ID_ABS_MAX
+#error "ABS_MAX and INPUT_DEVICE_ID_ABS_MAX do not match"
+#endif
+
+#if MSC_MAX != INPUT_DEVICE_ID_MSC_MAX
+#error "MSC_MAX and INPUT_DEVICE_ID_MSC_MAX do not match"
+#endif
+
+#if LED_MAX != INPUT_DEVICE_ID_LED_MAX
+#error "LED_MAX and INPUT_DEVICE_ID_LED_MAX do not match"
+#endif
+
+#if SND_MAX != INPUT_DEVICE_ID_SND_MAX
+#error "SND_MAX and INPUT_DEVICE_ID_SND_MAX do not match"
+#endif
+
+#if FF_MAX != INPUT_DEVICE_ID_FF_MAX
+#error "FF_MAX and INPUT_DEVICE_ID_FF_MAX do not match"
+#endif
+
+#if SW_MAX != INPUT_DEVICE_ID_SW_MAX
+#error "SW_MAX and INPUT_DEVICE_ID_SW_MAX do not match"
+#endif
+
+#define INPUT_DEVICE_ID_MATCH_DEVICE \
 	(INPUT_DEVICE_ID_MATCH_BUS | INPUT_DEVICE_ID_MATCH_VENDOR | INPUT_DEVICE_ID_MATCH_PRODUCT)
-#define INPUT_DEVICE_ID_MATCH_DEVICE_AND_VERSION\
+#define INPUT_DEVICE_ID_MATCH_DEVICE_AND_VERSION \
 	(INPUT_DEVICE_ID_MATCH_DEVICE | INPUT_DEVICE_ID_MATCH_VERSION)
 
 struct input_handle;
diff --git a/include/linux/keyboard.h b/include/linux/keyboard.h
index 08488042d7..3f7a68611a 100644
--- a/include/linux/keyboard.h
+++ b/include/linux/keyboard.h
@@ -44,6 +44,7 @@ extern unsigned short plain_map[NR_KEYS];
 #define KT_ASCII	9
 #define KT_LOCK		10
 #define KT_SLOCK	12
+#define KT_SPKUP       	14
 
 #define K(t,v)		(((t)<<8)|(v))
 #define KTYP(x)		((x) >> 8)
@@ -426,6 +427,7 @@ extern unsigned short plain_map[NR_KEYS];
 #define K_CTRLR_SLOCK	K(KT_SLOCK,KG_CTRLR)
 
 #define NR_LOCK		8
+#define NR_SPKUP       0x45
 
 #define MAX_DIACR	256
 #endif
diff --git a/include/linux/libata.h b/include/linux/libata.h
index c91be5e64e..48a5a090f3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -237,6 +237,7 @@ struct ata_probe_ent {
 	unsigned long		irq;
 	unsigned int		irq_flags;
 	unsigned long		host_flags;
+	unsigned long		port_flags[ATA_MAX_PORTS];
 	void __iomem		*mmio_base;
 	void			*private_data;
 };
diff --git a/include/linux/miscdevice.h b/include/linux/miscdevice.h
index 14ceebfc1e..1fc11f394c 100644
--- a/include/linux/miscdevice.h
+++ b/include/linux/miscdevice.h
@@ -12,6 +12,7 @@
 #define APOLLO_MOUSE_MINOR 7
 #define PC110PAD_MINOR 9
 /*#define ADB_MOUSE_MINOR 10	FIXME OBSOLETE */
+#define SYNTH_MINOR   25
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR 135
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index 7b08c11ec4..f697770858 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -249,4 +249,52 @@ struct i2c_device_id {
 	__u16 id;
 };
 
+/* Input */
+#define INPUT_DEVICE_ID_EV_MAX		0x1f
+#define INPUT_DEVICE_ID_KEY_MAX		0x1ff
+#define INPUT_DEVICE_ID_REL_MAX		0x0f
+#define INPUT_DEVICE_ID_ABS_MAX		0x3f
+#define INPUT_DEVICE_ID_MSC_MAX		0x07
+#define INPUT_DEVICE_ID_LED_MAX		0x0f
+#define INPUT_DEVICE_ID_SND_MAX		0x07
+#define INPUT_DEVICE_ID_FF_MAX		0x7f
+#define INPUT_DEVICE_ID_SW_MAX		0x0f
+
+#define INPUT_DEVICE_ID_MATCH_BUS	1
+#define INPUT_DEVICE_ID_MATCH_VENDOR	2
+#define INPUT_DEVICE_ID_MATCH_PRODUCT	4
+#define INPUT_DEVICE_ID_MATCH_VERSION	8
+
+#define INPUT_DEVICE_ID_MATCH_EVBIT	0x0010
+#define INPUT_DEVICE_ID_MATCH_KEYBIT	0x0020
+#define INPUT_DEVICE_ID_MATCH_RELBIT	0x0040
+#define INPUT_DEVICE_ID_MATCH_ABSBIT	0x0080
+#define INPUT_DEVICE_ID_MATCH_MSCIT	0x0100
+#define INPUT_DEVICE_ID_MATCH_LEDBIT	0x0200
+#define INPUT_DEVICE_ID_MATCH_SNDBIT	0x0400
+#define INPUT_DEVICE_ID_MATCH_FFBIT	0x0800
+#define INPUT_DEVICE_ID_MATCH_SWBIT	0x1000
+
+struct input_device_id {
+
+	kernel_ulong_t flags;
+
+	__u16 bustype;
+	__u16 vendor;
+	__u16 product;
+	__u16 version;
+
+	kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + 1];
+	kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + 1];
+
+	kernel_ulong_t driver_info;
+};
+
 #endif /* LINUX_MOD_DEVICETABLE_H */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 62e6314382..91920b6c49 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1140,6 +1140,8 @@ extern void mmput(struct mm_struct *);
 extern struct mm_struct *get_task_mm(struct task_struct *task);
 /* Remove the current tasks stale references to the old mm_struct */
 extern void mm_release(struct task_struct *, struct mm_struct *);
+/* Create a new mm for a kernel thread */
+extern int set_new_mm(void);
 
 extern int  copy_thread(int, unsigned long, unsigned long, unsigned long, struct task_struct *, struct pt_regs *);
 extern void flush_thread(void);
diff --git a/include/linux/speakup.h b/include/linux/speakup.h
new file mode 100644
index 0000000000..22a449f109
--- /dev/null
+++ b/include/linux/speakup.h
@@ -0,0 +1,35 @@
+#ifndef __SPEAKUP_H
+#define __SPEAKUP_H
+
+#include <linux/version.h>
+
+struct kbd_struct;
+struct vc_data;
+
+/* how about some prototypes! */
+
+#if defined(CONFIG_SPEAKUP)
+extern void speakup_init(struct vc_data *);
+extern int speakup_dev_init(void);
+extern void speakup_allocate(struct vc_data *);
+extern void speakup_bs(struct vc_data *);
+extern void speakup_con_write(struct vc_data *, const char *, int);
+extern void speakup_con_update(struct vc_data *);
+extern int speakup_key(struct vc_data*, int, int, u_short, int, struct pt_regs *);
+#elif defined(CONFIG_SPEAKUP_MODULE)
+typedef void (*spk_con_func)(struct vc_data * );
+typedef void (*spk_write_func)(struct vc_data *, const char *, int);
+typedef int (*spk_key_func)(struct vc_data*, int, int, u_short, int, struct pt_regs *);
+extern void spk_set_addresses( spk_con_func allocate, spk_con_func bs,
+	spk_write_func con_write, spk_con_func con_update, spk_key_func key );
+#define speakup_init(vc)
+extern int speakup_dev_init(void);
+#else
+#define speakup_allocate(vc)
+#define speakup_bs(vc)
+#define speakup_con_write(vc, str, len)
+#define speakup_con_update(vc)
+#define speakup_init(currcons)
+#define speakup_dev_init()
+#endif
+#endif
diff --git a/include/linux/squashfs_fs.h b/include/linux/squashfs_fs.h
new file mode 100644
index 0000000000..ef01d88743
--- /dev/null
+++ b/include/linux/squashfs_fs.h
@@ -0,0 +1,911 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
+#ifdef	CONFIG_SQUASHFS_VMALLOC
+#define SQUASHFS_ALLOC(a)		vmalloc(a)
+#define SQUASHFS_FREE(a)		vfree(a)
+#else
+#define SQUASHFS_ALLOC(a)		kmalloc(a, GFP_KERNEL)
+#define SQUASHFS_FREE(a)		kfree(a)
+#endif
+#define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE	
+#define SQUASHFS_MAJOR			3
+#define SQUASHFS_MINOR			0
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		65536
+#define SQUASHFS_FILE_LOG		16
+
+#define SQUASHFS_FILE_MAX_SIZE		65536
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_FRAG		((unsigned int) 0xffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) -1)
+#define SQUASHFS_USED_BLK		((long long) -2)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOI)
+
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOD)
+
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOF)
+
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_FRAG)
+
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_ALWAYS_FRAG)
+
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_DUPLICATE)
+
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_CHECK)
+
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \
+		duplicate_checking)	(noi | (nod << 1) | (check_data << 2) \
+		| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \
+		(duplicate_checking << 6))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is
+ * uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+		(B) & ~SQUASHFS_COMPRESSED_BIT :  SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK) ? (B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)	(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an
+ * uncompressed  offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+					<< 16) + (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + \
+					((b) >> 2) + 1))
+/* XXX */
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES(A)	(A * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) *\
+						sizeof(long long))
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	31
+#define SQUASHFS_META_NUMBER	8
+#define SQUASHFS_SLOTS		4
+
+struct meta_entry {
+	long long		data_block;
+	unsigned int		index_block;
+	unsigned short		offset;
+	unsigned short		pad;
+};
+
+struct meta_index {
+	unsigned int		inode_number;
+	unsigned int		offset;
+	unsigned short		entries;
+	unsigned short		skip;
+	unsigned short		locked;
+	unsigned short		pad;
+	struct meta_entry	meta_entry[SQUASHFS_META_ENTRIES];
+};
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef long long		squashfs_block_t;
+typedef long long		squashfs_inode_t;
+
+struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used_2;
+	unsigned int		uid_start_2;
+	unsigned int		guid_start_2;
+	unsigned int		inode_table_start_2;
+	unsigned int		directory_table_start_2;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode_t	root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start_2;
+	long long		bytes_used;
+	long long		uid_start;
+	long long		guid_start;
+	long long		inode_table_start;
+	long long		directory_table_start;
+	long long		fragment_table_start;
+	long long		unused;
+} __attribute__ ((packed));
+
+struct squashfs_dir_index {
+	unsigned int		index;
+	unsigned int		start_block;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+#define SQUASHFS_BASE_INODE_HEADER		\
+	unsigned int		inode_type:4;	\
+	unsigned int		mode:12;	\
+	unsigned int		uid:8;		\
+	unsigned int		guid:8;		\
+	unsigned int		mtime;		\
+	unsigned int 		inode_number;
+
+struct squashfs_base_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_lreg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	long long		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		parent_inode;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		i_count:16;
+	unsigned int		parent_inode;
+	struct squashfs_dir_index	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header {
+	struct squashfs_base_inode_header	base;
+	struct squashfs_dev_inode_header	dev;
+	struct squashfs_symlink_inode_header	symlink;
+	struct squashfs_reg_inode_header	reg;
+	struct squashfs_lreg_inode_header	lreg;
+	struct squashfs_dir_inode_header	dir;
+	struct squashfs_ldir_inode_header	ldir;
+	struct squashfs_ipc_inode_header	ipc;
+};
+	
+struct squashfs_dir_entry {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	int			inode_number:16;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_header {
+	unsigned int		count:8;
+	unsigned int		start_block;
+	unsigned int		inode_number;
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry {
+	long long		start_block;
+	unsigned int		size;
+	unsigned int		unused;
+} __attribute__ ((packed));
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem
+ * on a machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_START \
+	int bits;\
+	int b_pos;\
+	unsigned long long val;\
+	unsigned char *s;\
+	unsigned char *d;
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\
+	SQUASHFS_SWAP((s)->uid_start, d, 568, 64);\
+	SQUASHFS_SWAP((s)->guid_start, d, 632, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\
+	SQUASHFS_SWAP((s)->unused, d, 888, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 192, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 224, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 256, 64);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 147, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 160, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 155, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 168, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 200, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 40, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+	SQUASHFS_SWAP((s)->inode_number, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+
+struct squashfs_base_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+struct squashfs_dir_index_2 {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+struct squashfs_base_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	struct squashfs_dir_index_2	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header_2 {
+	struct squashfs_base_inode_header_2	base;
+	struct squashfs_dev_inode_header_2	dev;
+	struct squashfs_symlink_inode_header_2	symlink;
+	struct squashfs_reg_inode_header_2	reg;
+	struct squashfs_dir_inode_header_2	dir;
+	struct squashfs_ldir_inode_header_2	ldir;
+	struct squashfs_ipc_inode_header_2	ipc;
+};
+	
+struct squashfs_dir_header_2 {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed));
+
+struct squashfs_dir_entry_2 {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry_2 {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \
+	SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dev_inode_header_2)); \
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_2));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_reg_inode_header_2));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_ldir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES_2(A)	(A * sizeof(struct squashfs_fragment_entry_2))
+
+#define SQUASHFS_FRAGMENT_INDEX_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_2(A)	((SQUASHFS_FRAGMENT_BYTES_2(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)	(SQUASHFS_FRAGMENT_INDEXES_2(A) *\
+						sizeof(int))
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing
+ * architectures
+ */
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, b_pos)
+#else
+	/* convert from big endian to little endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	b_pos = pos % 8;\
+	val = 0;\
+	s = (unsigned char *)p + (pos / 8);\
+	d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+
+#endif
+#endif
diff --git a/include/linux/squashfs_fs_i.h b/include/linux/squashfs_fs_i.h
new file mode 100644
index 0000000000..d0cf810a84
--- /dev/null
+++ b/include/linux/squashfs_fs_i.h
@@ -0,0 +1,45 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+struct squashfs_inode_info {
+	long long	start_block;
+	unsigned int	offset;
+	union {
+		struct {
+			long long	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+			long long	block_list_start;
+		} s1;
+		struct {
+			long long	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+			unsigned int	parent_inode;
+		} s2;
+	} u;
+	struct inode	vfs_inode;
+};
+#endif
diff --git a/include/linux/squashfs_fs_sb.h b/include/linux/squashfs_fs_sb.h
new file mode 100644
index 0000000000..9ea7a11c7f
--- /dev/null
+++ b/include/linux/squashfs_fs_sb.h
@@ -0,0 +1,74 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+
+struct squashfs_cache {
+	long long	block;
+	int		length;
+	long long	next_index;
+	char		*data;
+};
+
+struct squashfs_fragment_cache {
+	long long	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+};
+
+struct squashfs_sb_info {
+	struct squashfs_super_block	sblk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	struct squashfs_cache	*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	int			next_meta_index;
+	unsigned int		*uid;
+	unsigned int		*guid;
+	long long		*fragment_index;
+	unsigned int		*fragment_index_2;
+	unsigned int		read_size;
+	char			*read_data;
+	char			*read_page;
+	struct semaphore	read_data_mutex;
+	struct semaphore	read_page_mutex;
+	struct semaphore	block_cache_mutex;
+	struct semaphore	fragment_mutex;
+	struct semaphore	meta_index_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct meta_index	*meta_index;
+	struct inode		*(*iget)(struct super_block *s,  squashfs_inode_t \
+				inode);
+	long long		(*read_blocklist)(struct inode *inode, int \
+				index, int readahead_blks, char *block_list, \
+				unsigned short **block_p, unsigned int *bsize);
+	int			(*read_fragment_index_table)(struct super_block *s);
+};
+#endif
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index d84d8cb691..eb75cf54b6 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -148,6 +148,10 @@ enum
 	KERN_SPIN_RETRY=70,	/* int: number of spinlock retries */
 	KERN_ACPI_VIDEO_FLAGS=71, /* int: flags for setting up video after ACPI sleep */
 	KERN_IA64_UNALIGNED=72, /* int: ia64 unaligned userland trap enable */
+	KERN_FBSPLASH=73,	/* string: path to fbsplash helper */
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+	KERN_UAC_POLICY=74,	/* int: Alpha unaligned access control policy flags */
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 };
 
 
@@ -231,6 +235,17 @@ enum
 	PTY_NR=2
 };
 
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+/* /proc/sys/kernel/uac */
+enum
+{
+	/* UAC policy on Alpha */
+	KERN_UAC_NOPRINT=1,	/* int: printk() on unaligned access */
+	KERN_UAC_SIGBUS=2,	/* int: send SIGBUS on unaligned access */
+	KERN_UAC_NOFIX=3,	/* int: don't fix the unaligned access */
+};
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
+
 /* /proc/sys/bus/isa */
 enum
 {
diff --git a/include/video/vesa.h b/include/video/vesa.h
new file mode 100644
index 0000000000..c2746042fc
--- /dev/null
+++ b/include/video/vesa.h
@@ -0,0 +1,146 @@
+#if 0
+#define DPRINTK(fmt, args...)	printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , \
+						  ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define p_crtc(arg) ((struct vesafb_crtc_ib*)(arg))
+#define p_vbe(arg)  ((struct vesafb_vbe_ib*)(arg))
+#define p_mode(arg) ((struct vesafb_mode_ib*)(arg))
+
+struct vesafb_task {
+	u8 flags;
+	void *buf;
+	int buf_len;
+	struct vm86_regs regs;
+	struct list_head node;
+	struct completion done;
+};
+
+/* Vesafb task flags and masks */
+#define TF_CALL		0x00
+#define TF_EXIT		0x01
+#define TF_GETVBEIB	0x02
+#define TF_USE_BUF	0x04
+#define TF_RETURN_BUF	0x08
+#define TF_MASK_BUF	(TF_USE_BUF | TF_RETURN_BUF)
+
+/* Macros and functions for manipulating vesafb tasks */
+#define vesafb_create_task(task)				\
+do { 								\
+	task = kmalloc(sizeof(struct vesafb_task), GFP_ATOMIC); \
+	if (task) 						\
+		memset(task, 0, sizeof(struct vesafb_task));	\
+	init_completion(&task->done);				\
+} while (0)
+
+#define vesafb_wait_for_task(task) 	wait_for_completion(&task->done);
+#define vesafb_reset_task(task)		init_completion(&task->done);
+int vesafb_queue_task(struct vesafb_task *task);
+
+/* Functions for controlling the vesafb thread */
+int vesafb_wait_for_thread(void);
+
+#define VBE_CAP_CAN_SWITCH_DAC	0x01
+#define VBE_CAP_VGACOMPAT	0x02
+
+/* This struct is 512 bytes long */
+struct vesafb_vbe_ib {
+	char vbe_signature[4];
+	u16  vbe_version;
+	u32  oem_string_ptr;
+	u32  capabilities;
+	u32  mode_list_ptr;
+	u16  total_memory;
+	u16  oem_software_rev;
+	u32  oem_vendor_name_ptr;
+	u32  oem_product_name_ptr;
+	u32  oem_product_rev_ptr;
+	u8   reserved[222];
+	char oem_data[256];
+} __attribute__ ((packed));
+
+struct vesafb_crtc_ib {
+	u16 horiz_total;
+	u16 horiz_start;
+	u16 horiz_end;
+	u16 vert_total;
+	u16 vert_start;
+	u16 vert_end;
+	u8  flags;
+	u32 pixel_clock;
+	u16 refresh_rate;
+	u8  reserved[40];
+} __attribute__ ((packed));
+
+#define VBE_MODE_VGACOMPAT	0x20
+
+struct vesafb_mode_ib {
+	/* for all VBE revisions */
+	u16 mode_attr;
+	u8  winA_attr;
+	u8  winB_attr;
+	u16 win_granularity;
+	u16 win_size;
+	u16 winA_seg;
+	u16 winB_seg;
+	u32 win_func_ptr;
+	u16 bytes_per_scan_line;
+
+	/* for VBE 1.2+ */
+	u16 x_res;
+	u16 y_res;
+	u8  x_char_size;
+	u8  y_char_size;
+	u8  planes;
+	u8  bits_per_pixel;
+	u8  banks;
+	u8  memory_model;
+	u8  bank_size;
+	u8  image_pages;
+	u8  reserved1;
+
+	/* Direct color fields for direct/6 and YUV/7 memory models. */
+	/* Offsets are bit positions of lsb in the mask. */
+	u8  red_len;
+	u8  red_off;
+	u8  green_len;
+	u8  green_off;
+	u8  blue_len;
+	u8  blue_off;
+	u8  rsvd_len;
+	u8  rsvd_off;
+	u8  direct_color_info;	/* direct color mode attributes */
+
+	/* for VBE 2.0+ */
+	u32 phys_base_ptr;
+	u8  reserved2[6];
+
+	/* for VBE 3.0+ */
+	u16 lin_bytes_per_scan_line;
+	u8  bnk_image_pages;
+	u8  lin_image_pages;
+	u8  lin_red_len;
+	u8  lin_red_off;
+	u8  lin_green_len;
+	u8  lin_green_off;
+	u8  lin_blue_len;
+	u8  lin_blue_off;
+	u8  lin_rsvd_len;
+	u8  lin_rsvd_off;
+	u32 max_pixel_clock;
+	u16 mode_id;
+	u8  depth;
+} __attribute__ ((packed));
+
+struct vesafb_pal_entry {
+	u_char blue, green, red, pad;
+} __attribute__ ((packed));
+
+struct vesafb_par {
+	u32 mem_total;
+	int mode_idx;
+	struct vesafb_crtc_ib crtc;
+};
+
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index c2683fcd79..98ca8e79d1 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@ static int __init crd_load(int in_fd, int out_fd);
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ *      squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@ identify_ramdisk_image(int fd, int start_block)
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@ identify_ramdisk_image(int fd, int start_block)
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,15 @@ identify_ramdisk_image(int fd, int start_block)
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+		       "RAMDISK: squashfs filesystem found at block %d\n",
+		       start_block);
+		nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
diff --git a/kernel/fork.c b/kernel/fork.c
index 9d4e0d8b65..cd96c8a89e 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -97,6 +97,7 @@ kmem_cache_t *fs_cachep;
 
 /* SLAB cache for vm_area_struct structures */
 kmem_cache_t *vm_area_cachep;
+EXPORT_SYMBOL_GPL(vm_area_cachep);
 
 /* SLAB cache for mm_struct structures (tsk->mm) */
 static kmem_cache_t *mm_cachep;
@@ -384,6 +385,40 @@ void mmput(struct mm_struct *mm)
 }
 EXPORT_SYMBOL_GPL(mmput);
 
+/**
+ * set_new_mm - allocate, init and activate a new mm for a kernel thread
+ */
+int set_new_mm(void)
+{
+	struct mm_struct *mm;
+	struct task_struct *tsk = current;
+	struct mm_struct *active_mm;
+
+	mm = mm_alloc();
+	if (!mm)
+		goto fail_nomem;
+	if (init_new_context(current,mm))
+		goto fail_nocontext;
+
+	task_lock(tsk);
+	tsk->flags |= PF_BORROWED_MM;
+	active_mm = tsk->active_mm;
+	current->mm = mm;
+	current->active_mm = mm;
+	activate_mm(active_mm, mm);
+	task_unlock(current);
+
+	/* Drop the previous active_mm */
+	mmdrop(active_mm);
+	return 0;
+
+fail_nocontext:
+	mmdrop(mm);
+fail_nomem:
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(set_new_mm);
+
 /**
  * get_task_mm - acquire a reference to the task's mm
  *
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 32b48e8ee3..751b1e7085 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -89,6 +89,9 @@ static int ngroups_max = NGROUPS_MAX;
 #ifdef CONFIG_KMOD
 extern char modprobe_path[];
 #endif
+#ifdef CONFIG_FB_SPLASH
+extern char fbsplash_path[];
+#endif
 #ifdef CONFIG_CHR_DEV_SG
 extern int sg_big_buff;
 #endif
@@ -157,6 +160,9 @@ extern ctl_table inotify_table[];
 #ifdef HAVE_ARCH_PICK_MMAP_LAYOUT
 int sysctl_legacy_va_layout;
 #endif
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+extern ctl_table uac_table[];
+#endif
 
 /* /proc declarations: */
 
@@ -225,7 +231,14 @@ static ctl_table root_table[] = {
 		.mode		= 0555,
 		.child		= dev_table,
 	},
-
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+	{
+		.ctl_name	= KERN_UAC_POLICY,
+		.procname	= "uac",
+		.mode		= 0555,
+		.child		= uac_table,
+	},
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 	{ .ctl_name = 0 }
 };
 
@@ -409,6 +422,17 @@ static ctl_table kern_table[] = {
 		.strategy	= &sysctl_string,
 	},
 #endif
+#ifdef CONFIG_FB_SPLASH
+	{
+		.ctl_name	= KERN_FBSPLASH,
+		.procname	= "fbsplash",
+		.data		= &fbsplash_path,
+		.maxlen		= KMOD_PATH_LEN,
+		.mode		= 0644,
+		.proc_handler	= &proc_dostring,
+		.strategy	= &sysctl_string,
+	},
+#endif
 #ifdef CONFIG_CHR_DEV_SG
 	{
 		.ctl_name	= KERN_SG_BIG_BUFF,
diff --git a/mm/memory.c b/mm/memory.c
index 97f5ea3957..5f4ae54021 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1114,6 +1114,7 @@ static int zeromap_pte_range(struct mm_struct *mm, pmd_t *pmd,
 	pte_unmap_unlock(pte - 1, ptl);
 	return err;
 }
+EXPORT_SYMBOL_GPL(zeromap_page_range);
 
 static inline int zeromap_pmd_range(struct mm_struct *mm, pud_t *pud,
 			unsigned long addr, unsigned long end, pgprot_t prot)
diff --git a/mm/mmap.c b/mm/mmap.c
index 666932b09e..ac4422e38b 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2014,6 +2014,7 @@ int insert_vm_struct(struct mm_struct * mm, struct vm_area_struct * vma)
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(insert_vm_struct);
 
 /*
  * Copy the vma structure to a new location in the same mm,
diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
index c164b230ad..570143989a 100644
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@ -375,10 +375,10 @@ static void do_input(char *alias,
 		     kernel_ulong_t *arr, unsigned int min, unsigned int max)
 {
 	unsigned int i;
-	for (i = min; i < max; i++) {
-		if (arr[i/BITS_PER_LONG] & (1 << (i%BITS_PER_LONG)))
-			sprintf(alias+strlen(alias), "%X,*", i);
-	}
+
+	for (i = min; i < max; i++)
+		if (arr[i / BITS_PER_LONG] & (1 << (i%BITS_PER_LONG)))
+			sprintf(alias + strlen(alias), "%X,*", i);
 }
 
 /* input:b0v0p0e0-eXkXrXaXmXlXsXfXwX where X is comma-separated %02X. */
@@ -387,39 +387,37 @@ static int do_input_entry(const char *filename, struct input_device_id *id,
 {
 	sprintf(alias, "input:");
 
-	ADD(alias, "b", id->flags&INPUT_DEVICE_ID_MATCH_BUS, id->id.bustype);
-	ADD(alias, "v", id->flags&INPUT_DEVICE_ID_MATCH_VENDOR, id->id.vendor);
-	ADD(alias, "p", id->flags&INPUT_DEVICE_ID_MATCH_PRODUCT,
-	    id->id.product);
-	ADD(alias, "e", id->flags&INPUT_DEVICE_ID_MATCH_VERSION,
-	    id->id.version);
+	ADD(alias, "b", id->flags & INPUT_DEVICE_ID_MATCH_BUS, id->bustype);
+	ADD(alias, "v", id->flags & INPUT_DEVICE_ID_MATCH_VENDOR, id->vendor);
+	ADD(alias, "p", id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT, id->product);
+	ADD(alias, "e", id->flags & INPUT_DEVICE_ID_MATCH_VERSION, id->version);
 
 	sprintf(alias + strlen(alias), "-e*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_EVBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_EVBIT)
 		do_input(alias, id->evbit, 0, EV_MAX);
 	sprintf(alias + strlen(alias), "k*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_KEYBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_KEYBIT)
 		do_input(alias, id->keybit, KEY_MIN_INTERESTING, KEY_MAX);
 	sprintf(alias + strlen(alias), "r*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_RELBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_RELBIT)
 		do_input(alias, id->relbit, 0, REL_MAX);
 	sprintf(alias + strlen(alias), "a*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_ABSBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_ABSBIT)
 		do_input(alias, id->absbit, 0, ABS_MAX);
 	sprintf(alias + strlen(alias), "m*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_MSCIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_MSCIT)
 		do_input(alias, id->mscbit, 0, MSC_MAX);
 	sprintf(alias + strlen(alias), "l*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_LEDBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_LEDBIT)
 		do_input(alias, id->ledbit, 0, LED_MAX);
 	sprintf(alias + strlen(alias), "s*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_SNDBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_SNDBIT)
 		do_input(alias, id->sndbit, 0, SND_MAX);
 	sprintf(alias + strlen(alias), "f*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_FFBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_FFBIT)
 		do_input(alias, id->ffbit, 0, FF_MAX);
 	sprintf(alias + strlen(alias), "w*");
-	if (id->flags&INPUT_DEVICE_ID_MATCH_SWBIT)
+	if (id->flags & INPUT_DEVICE_ID_MATCH_SWBIT)
 		do_input(alias, id->swbit, 0, SW_MAX);
 	return 1;
 }
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 4a6dd97deb..aeccf2b333 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -1890,6 +1890,13 @@ int snd_hda_multi_out_analog_prepare(struct hda_codec *codec, struct hda_multi_o
 	if (mout->hp_nid)
 		/* headphone out will just decode front left/right (stereo) */
 		snd_hda_codec_setup_stream(codec, mout->hp_nid, stream_tag, 0, format);
+	/* extra outputs copied from front */
+	for (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++)
+		if (mout->extra_out_nid[i])
+			snd_hda_codec_setup_stream(codec,
+						   mout->extra_out_nid[i],
+						   stream_tag, 0, format);
+
 	/* surrounds */
 	for (i = 1; i < mout->num_dacs; i++) {
 		if (chs >= (i + 1) * 2) /* independent out */
@@ -1914,6 +1921,11 @@ int snd_hda_multi_out_analog_cleanup(struct hda_codec *codec, struct hda_multi_o
 		snd_hda_codec_setup_stream(codec, nids[i], 0, 0, 0);
 	if (mout->hp_nid)
 		snd_hda_codec_setup_stream(codec, mout->hp_nid, 0, 0, 0);
+	for (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++)
+		if (mout->extra_out_nid[i])
+			snd_hda_codec_setup_stream(codec,
+						   mout->extra_out_nid[i],
+						   0, 0, 0);
 	down(&codec->spdif_mutex);
 	if (mout->dig_out_nid && mout->dig_out_used == HDA_DIG_ANALOG_DUP) {
 		snd_hda_codec_setup_stream(codec, mout->dig_out_nid, 0, 0, 0);
@@ -1935,13 +1947,29 @@ static int is_in_nid_list(hda_nid_t nid, hda_nid_t *list)
 	return 0;
 }
 
-/* parse all pin widgets and store the useful pin nids to cfg */
+/*
+ * Parse all pin widgets and store the useful pin nids to cfg
+ *
+ * The number of line-outs or any primary output is stored in line_outs,
+ * and the corresponding output pins are assigned to line_out_pins[],
+ * in the order of front, rear, CLFE, side, ...
+ *
+ * If more extra outputs (speaker and headphone) are found, the pins are
+ * assisnged to hp_pin and speaker_pins[], respectively.  If no line-out jack
+ * is detected, one of speaker of HP pins is assigned as the primary
+ * output, i.e. to line_out_pins[0].  So, line_outs is always positive
+ * if any analog output exists.
+ * 
+ * The analog input pins are assigned to input_pins array.
+ * The digital input/output pins are assigned to dig_in_pin and dig_out_pin,
+ * respectively.
+ */
 int snd_hda_parse_pin_def_config(struct hda_codec *codec, struct auto_pin_cfg *cfg,
 				 hda_nid_t *ignore_nids)
 {
 	hda_nid_t nid, nid_start;
 	int i, j, nodes;
-	short seq, sequences[4], assoc_line_out;
+	short seq, assoc_line_out, sequences[ARRAY_SIZE(cfg->line_out_pins)];
 
 	memset(cfg, 0, sizeof(*cfg));
 
@@ -1983,7 +2011,10 @@ int snd_hda_parse_pin_def_config(struct hda_codec *codec, struct auto_pin_cfg *c
 			cfg->line_outs++;
 			break;
 		case AC_JACK_SPEAKER:
-			cfg->speaker_pin = nid;
+			if (cfg->speaker_outs >= ARRAY_SIZE(cfg->speaker_pins))
+				continue;
+			cfg->speaker_pins[cfg->speaker_outs] = nid;
+			cfg->speaker_outs++;
 			break;
 		case AC_JACK_HP_OUT:
 			cfg->hp_pin = nid;
@@ -2048,6 +2079,46 @@ int snd_hda_parse_pin_def_config(struct hda_codec *codec, struct auto_pin_cfg *c
 		break;
 	}
 
+	/*
+	 * debug prints of the parsed results
+	 */
+	snd_printd("autoconfig: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+		   cfg->line_outs, cfg->line_out_pins[0], cfg->line_out_pins[1],
+		   cfg->line_out_pins[2], cfg->line_out_pins[3],
+		   cfg->line_out_pins[4]);
+	snd_printd("   speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+		   cfg->speaker_outs, cfg->speaker_pins[0],
+		   cfg->speaker_pins[1], cfg->speaker_pins[2],
+		   cfg->speaker_pins[3], cfg->speaker_pins[4]);
+	snd_printd("   hp=0x%x, dig_out=0x%x, din_in=0x%x\n",
+		   cfg->hp_pin, cfg->dig_out_pin, cfg->dig_in_pin);
+	snd_printd("   inputs: mic=0x%x, fmic=0x%x, line=0x%x, fline=0x%x,"
+		   " cd=0x%x, aux=0x%x\n",
+		   cfg->input_pins[AUTO_PIN_MIC],
+		   cfg->input_pins[AUTO_PIN_FRONT_MIC],
+		   cfg->input_pins[AUTO_PIN_LINE],
+		   cfg->input_pins[AUTO_PIN_FRONT_LINE],
+		   cfg->input_pins[AUTO_PIN_CD],
+		   cfg->input_pins[AUTO_PIN_AUX]);
+
+	/*
+	 * FIX-UP: if no line-outs are detected, try to use speaker or HP pin
+	 * as a primary output
+	 */
+	if (! cfg->line_outs) {
+		if (cfg->speaker_outs) {
+			cfg->line_outs = cfg->speaker_outs;
+			memcpy(cfg->line_out_pins, cfg->speaker_pins,
+			       sizeof(cfg->speaker_pins));
+			cfg->speaker_outs = 0;
+			memset(cfg->speaker_pins, 0, sizeof(cfg->speaker_pins));
+		} else if (cfg->hp_pin) {
+			cfg->line_outs = 1;
+			cfg->line_out_pins[0] = cfg->hp_pin;
+			cfg->hp_pin = 0;
+		}
+	}
+
 	return 0;
 }
 
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index c82d2a72d1..9b3846dd53 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -130,6 +130,7 @@ struct hda_multi_out {
 	int num_dacs;		/* # of DACs, must be more than 1 */
 	hda_nid_t *dac_nids;	/* DAC list */
 	hda_nid_t hp_nid;	/* optional DAC for HP, 0 when not exists */
+	hda_nid_t extra_out_nid[3];	/* optional DACs, 0 when not exists */
 	hda_nid_t dig_out_nid;	/* digital out audio widget */
 	int max_channels;	/* currently supported analog channels */
 	int dig_out_used;	/* current usage of digital out (HDA_DIG_XXX) */
@@ -216,7 +217,8 @@ extern const char *auto_pin_cfg_labels[AUTO_PIN_LAST];
 struct auto_pin_cfg {
 	int line_outs;
 	hda_nid_t line_out_pins[5]; /* sorted in the order of Front/Surr/CLFE/Side */
-	hda_nid_t speaker_pin;
+	int speaker_outs;
+	hda_nid_t speaker_pins[5];
 	hda_nid_t hp_pin;
 	hda_nid_t input_pins[AUTO_PIN_LAST];
 	hda_nid_t dig_out_pin;
diff --git a/sound/pci/hda/patch_analog.c b/sound/pci/hda/patch_analog.c
index edb7b1b198..b6701d1172 100644
--- a/sound/pci/hda/patch_analog.c
+++ b/sound/pci/hda/patch_analog.c
@@ -358,6 +358,14 @@ static struct hda_input_mux ad1986a_capture_source = {
 	},
 };
 
+static int ad198x_ch_mode_info(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo);
+static int ad198x_ch_mode_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol);
+static int ad198x_ch_mode_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol);
+
+
 /*
  * PCM control
  *
@@ -477,6 +485,52 @@ static struct snd_kcontrol_new ad1986a_mixers[] = {
 	{ } /* end */
 };
 
+/* additional mixers for 3stack mode */
+static struct snd_kcontrol_new ad1986a_3st_mixers[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Channel Mode",
+		.info = ad198x_ch_mode_info,
+		.get = ad198x_ch_mode_get,
+		.put = ad198x_ch_mode_put,
+	},
+	{ } /* end */
+};
+
+/* laptop model - 2ch only */
+static hda_nid_t ad1986a_laptop_dac_nids[1] = { AD1986A_FRONT_DAC };
+
+static struct snd_kcontrol_new ad1986a_laptop_mixers[] = {
+	HDA_CODEC_VOLUME("PCM Playback Volume", 0x03, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("PCM Playback Switch", 0x03, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Master Playback Volume", 0x1b, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Master Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+	/* HDA_CODEC_VOLUME("Headphone Playback Volume", 0x1a, 0x0, HDA_OUTPUT),
+	   HDA_CODEC_MUTE("Headphone Playback Switch", 0x1a, 0x0, HDA_OUTPUT), */
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x17, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x17, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Aux Playback Volume", 0x16, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Aux Playback Switch", 0x16, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x13, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x13, 0x0, HDA_OUTPUT),
+	/* HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x18, 0x0, HDA_OUTPUT),
+	   HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x18, 0x0, HDA_OUTPUT),
+	   HDA_CODEC_VOLUME("Mono Playback Volume", 0x1e, 0x0, HDA_OUTPUT),
+	   HDA_CODEC_MUTE("Mono Playback Switch", 0x1e, 0x0, HDA_OUTPUT), */
+	HDA_CODEC_VOLUME("Capture Volume", 0x12, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x12, 0x0, HDA_OUTPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = ad198x_mux_enum_info,
+		.get = ad198x_mux_enum_get,
+		.put = ad198x_mux_enum_put,
+	},
+	{ } /* end */
+};
+
 /*
  * initialization verbs
  */
@@ -535,10 +589,70 @@ static struct hda_verb ad1986a_init_verbs[] = {
 	{ } /* end */
 };
 
+/* additional verbs for 3-stack model */
+static struct hda_verb ad1986a_3st_init_verbs[] = {
+ 	/* Mic and line-in selectors */
+	{0x0f, AC_VERB_SET_CONNECT_SEL, 0x2},
+	{0x10, AC_VERB_SET_CONNECT_SEL, 0x1},
+ 	{ } /* end */
+};
+
+static struct hda_verb ad1986a_ch2_init[] = {
+	/* Surround out -> Line In */
+	{ 0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	{ 0x1c, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
+	/* CLFE -> Mic in */
+	{ 0x1d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	{ 0x1d, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
+	{ } /* end */
+};
+
+static struct hda_verb ad1986a_ch4_init[] = {
+	/* Surround out -> Surround */
+	{ 0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x1c, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
+	/* CLFE -> Mic in */
+	{ 0x1d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	{ 0x1d, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
+	{ } /* end */
+};
+
+static struct hda_verb ad1986a_ch6_init[] = {
+	/* Surround out -> Surround out */
+	{ 0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x1c, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
+	/* CLFE -> CLFE */
+	{ 0x1d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x1d, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
+	{ } /* end */
+};
+
+static struct hda_channel_mode ad1986a_modes[3] = {
+	{ 2, ad1986a_ch2_init },
+	{ 4, ad1986a_ch4_init },
+	{ 6, ad1986a_ch6_init },
+};
+
+/* models */
+enum { AD1986A_6STACK, AD1986A_3STACK, AD1986A_LAPTOP };
+
+static struct hda_board_config ad1986a_cfg_tbl[] = {
+	{ .modelname = "6stack",	.config = AD1986A_6STACK },
+	{ .modelname = "3stack",	.config = AD1986A_3STACK },
+	{ .pci_subvendor = 0x10de, .pci_subdevice = 0xcb84,
+	  .config = AD1986A_3STACK }, /* ASUS A8N-VM CSM */
+	{ .modelname = "laptop",	.config = AD1986A_LAPTOP },
+	{ .pci_subvendor = 0x144d, .pci_subdevice = 0xc01e,
+	  .config = AD1986A_LAPTOP }, /* FSC V2060 */
+	{ .pci_subvendor = 0x17c0, .pci_subdevice = 0x2017,
+	  .config = AD1986A_LAPTOP }, /* Samsung M50 */
+	{}
+};
 
 static int patch_ad1986a(struct hda_codec *codec)
 {
 	struct ad198x_spec *spec;
+	int board_config;
 
 	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
 	if (spec == NULL)
@@ -562,6 +676,25 @@ static int patch_ad1986a(struct hda_codec *codec)
 
 	codec->patch_ops = ad198x_patch_ops;
 
+	/* override some parameters */
+	board_config = snd_hda_check_board_config(codec, ad1986a_cfg_tbl);
+	switch (board_config) {
+	case AD1986A_3STACK:
+		spec->num_mixers = 2;
+		spec->mixers[1] = ad1986a_3st_mixers;
+		spec->num_init_verbs = 2;
+		spec->init_verbs[1] = ad1986a_3st_init_verbs;
+		spec->channel_mode = ad1986a_modes;
+		spec->num_channel_mode = ARRAY_SIZE(ad1986a_modes);
+		break;
+	case AD1986A_LAPTOP:
+		spec->mixers[0] = ad1986a_laptop_mixers;
+		spec->multiout.max_channels = 2;
+		spec->multiout.num_dacs = 1;
+		spec->multiout.dac_nids = ad1986a_laptop_dac_nids;
+		break;
+	}
+
 	return 0;
 }
 
@@ -1802,14 +1935,11 @@ static int ad1988_auto_create_extra_out(struct hda_codec *codec, hda_nid_t pin,
 
 	idx = ad1988_pin_idx(pin);
 	nid = ad1988_idx_to_dac(codec, idx);
-	if (! spec->multiout.dac_nids[0]) {
-		/* use this as the primary output */
-		spec->multiout.dac_nids[0] = nid;
-		if (! spec->multiout.num_dacs)
-			spec->multiout.num_dacs = 1;
-	} else 
-		/* specify the DAC as the extra output */
+	/* specify the DAC as the extra output */
+	if (! spec->multiout.hp_nid)
 		spec->multiout.hp_nid = nid;
+	else
+		spec->multiout.extra_out_nid[0] = nid;
 	/* control HP volume/switch on the output mixer amp */
 	sprintf(name, "%s Playback Volume", pfx);
 	if ((err = add_control(spec, AD_CTL_WIDGET_VOL, name,
@@ -1928,7 +2058,7 @@ static void ad1988_auto_init_extra_out(struct hda_codec *codec)
 	struct ad198x_spec *spec = codec->spec;
 	hda_nid_t pin;
 
-	pin = spec->autocfg.speaker_pin;
+	pin = spec->autocfg.speaker_pins[0];
 	if (pin) /* connect to front */
 		ad1988_auto_set_output_and_unmute(codec, pin, PIN_OUT, 0);
 	pin = spec->autocfg.hp_pin;
@@ -1977,13 +2107,13 @@ static int ad1988_parse_auto_config(struct hda_codec *codec)
 		return err;
 	if ((err = ad1988_auto_fill_dac_nids(codec, &spec->autocfg)) < 0)
 		return err;
-	if (! spec->autocfg.line_outs && ! spec->autocfg.speaker_pin &&
-	    ! spec->autocfg.hp_pin)
+	if (! spec->autocfg.line_outs)
 		return 0; /* can't find valid BIOS pin config */
 	if ((err = ad1988_auto_create_multi_out_ctls(spec, &spec->autocfg)) < 0 ||
-	    (err = ad1988_auto_create_extra_out(codec, spec->autocfg.speaker_pin,
+	    (err = ad1988_auto_create_extra_out(codec,
+						spec->autocfg.speaker_pins[0],
 						"Speaker")) < 0 ||
-	    (err = ad1988_auto_create_extra_out(codec, spec->autocfg.speaker_pin,
+	    (err = ad1988_auto_create_extra_out(codec, spec->autocfg.hp_pin,
 						"Headphone")) < 0 ||
 	    (err = ad1988_auto_create_analog_input_ctls(spec, &spec->autocfg)) < 0)
 		return err;
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index bc1932ee67..b6ec6976a0 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -2043,14 +2043,11 @@ static int alc880_auto_create_extra_out(struct alc_spec *spec, hda_nid_t pin,
 
 	if (alc880_is_fixed_pin(pin)) {
 		nid = alc880_idx_to_dac(alc880_fixed_pin_idx(pin));
-		if (! spec->multiout.dac_nids[0]) {
-			/* use this as the primary output */
-			spec->multiout.dac_nids[0] = nid;
-			if (! spec->multiout.num_dacs)
-				spec->multiout.num_dacs = 1;
-		} else 
-			/* specify the DAC as the extra output */
+		/* specify the DAC as the extra output */
+		if (! spec->multiout.hp_nid)
 			spec->multiout.hp_nid = nid;
+		else
+			spec->multiout.extra_out_nid[0] = nid;
 		/* control HP volume/switch on the output mixer amp */
 		nid = alc880_idx_to_mixer(alc880_fixed_pin_idx(pin));
 		sprintf(name, "%s Playback Volume", pfx);
@@ -2063,12 +2060,6 @@ static int alc880_auto_create_extra_out(struct alc_spec *spec, hda_nid_t pin,
 			return err;
 	} else if (alc880_is_multi_pin(pin)) {
 		/* set manual connection */
-		if (! spec->multiout.dac_nids[0]) {
-			/* use this as the primary output */
-			spec->multiout.dac_nids[0] = alc880_idx_to_dac(alc880_multi_pin_idx(pin));
-			if (! spec->multiout.num_dacs)
-				spec->multiout.num_dacs = 1;
-		}
 		/* we have only a switch on HP-out PIN */
 		sprintf(name, "%s Playback Switch", pfx);
 		if ((err = add_control(spec, ALC_CTL_WIDGET_MUTE, name,
@@ -2152,7 +2143,7 @@ static void alc880_auto_init_extra_out(struct hda_codec *codec)
 	struct alc_spec *spec = codec->spec;
 	hda_nid_t pin;
 
-	pin = spec->autocfg.speaker_pin;
+	pin = spec->autocfg.speaker_pins[0];
 	if (pin) /* connect to front */
 		alc880_auto_set_output_and_unmute(codec, pin, PIN_OUT, 0);
 	pin = spec->autocfg.hp_pin;
@@ -2188,15 +2179,15 @@ static int alc880_parse_auto_config(struct hda_codec *codec)
 	if ((err = snd_hda_parse_pin_def_config(codec, &spec->autocfg,
 						alc880_ignore)) < 0)
 		return err;
-	if (! spec->autocfg.line_outs && ! spec->autocfg.speaker_pin &&
-	    ! spec->autocfg.hp_pin)
+	if (! spec->autocfg.line_outs)
 		return 0; /* can't find valid BIOS pin config */
 
 	if ((err = alc880_auto_fill_dac_nids(spec, &spec->autocfg)) < 0 ||
 	    (err = alc880_auto_create_multi_out_ctls(spec, &spec->autocfg)) < 0 ||
-	    (err = alc880_auto_create_extra_out(spec, spec->autocfg.speaker_pin,
+	    (err = alc880_auto_create_extra_out(spec,
+						spec->autocfg.speaker_pins[0],
 						"Speaker")) < 0 ||
-	    (err = alc880_auto_create_extra_out(spec, spec->autocfg.speaker_pin,
+	    (err = alc880_auto_create_extra_out(spec, spec->autocfg.hp_pin,
 						"Headphone")) < 0 ||
 	    (err = alc880_auto_create_analog_input_ctls(spec, &spec->autocfg)) < 0)
 		return err;
@@ -2744,7 +2735,7 @@ static int alc260_auto_create_multi_out_ctls(struct alc_spec *spec,
 			return err;
 	}
 
-	nid = cfg->speaker_pin;
+	nid = cfg->speaker_pins[0];
 	if (nid) {
 		err = alc260_add_playback_controls(spec, nid, "Speaker");
 		if (err < 0)
@@ -2817,7 +2808,7 @@ static void alc260_auto_init_multi_out(struct hda_codec *codec)
 	if (nid)
 		alc260_auto_set_output_and_unmute(codec, nid, PIN_OUT, 0);
 	
-	nid = spec->autocfg.speaker_pin;
+	nid = spec->autocfg.speaker_pins[0];
 	if (nid)
 		alc260_auto_set_output_and_unmute(codec, nid, PIN_OUT, 0);
 
@@ -3761,7 +3752,7 @@ static int alc262_auto_create_multi_out_ctls(struct alc_spec *spec, const struct
 			return err;
 	}
 
-	nid = cfg->speaker_pin;
+	nid = cfg->speaker_pins[0];
 	if (nid) {
 		if (nid == 0x16) {
 			if ((err = add_control(spec, ALC_CTL_WIDGET_VOL, "Speaker Playback Volume",
@@ -3771,10 +3762,6 @@ static int alc262_auto_create_multi_out_ctls(struct alc_spec *spec, const struct
 					       HDA_COMPOSE_AMP_VAL(nid, 2, 0, HDA_OUTPUT))) < 0)
 				return err;
 		} else {
-			if (! cfg->line_out_pins[0])
-				if ((err = add_control(spec, ALC_CTL_WIDGET_VOL, "Speaker Playback Volume",
-					       HDA_COMPOSE_AMP_VAL(0x0c, 3, 0, HDA_OUTPUT))) < 0)
-					return err;
 			if ((err = add_control(spec, ALC_CTL_WIDGET_MUTE, "Speaker Playback Switch",
 					       HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT))) < 0)
 				return err;
@@ -3791,10 +3778,6 @@ static int alc262_auto_create_multi_out_ctls(struct alc_spec *spec, const struct
 					       HDA_COMPOSE_AMP_VAL(nid, 2, 0, HDA_OUTPUT))) < 0)
 				return err;
 		} else {
-			if (! cfg->line_out_pins[0])
-				if ((err = add_control(spec, ALC_CTL_WIDGET_VOL, "Headphone Playback Volume",
-					       HDA_COMPOSE_AMP_VAL(0x0c, 3, 0, HDA_OUTPUT))) < 0)
-					return err;
 			if ((err = add_control(spec, ALC_CTL_WIDGET_MUTE, "Headphone Playback Switch",
 					       HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT))) < 0)
 				return err;
@@ -3888,8 +3871,7 @@ static int alc262_parse_auto_config(struct hda_codec *codec)
 	if ((err = snd_hda_parse_pin_def_config(codec, &spec->autocfg,
 						alc262_ignore)) < 0)
 		return err;
-	if (! spec->autocfg.line_outs && ! spec->autocfg.speaker_pin &&
-	    ! spec->autocfg.hp_pin)
+	if (! spec->autocfg.line_outs)
 		return 0; /* can't find valid BIOS pin config */
 	if ((err = alc262_auto_create_multi_out_ctls(spec, &spec->autocfg)) < 0 ||
 	    (err = alc262_auto_create_analog_input_ctls(spec, &spec->autocfg)) < 0)
@@ -4551,8 +4533,7 @@ static int alc861_parse_auto_config(struct hda_codec *codec)
 	if ((err = snd_hda_parse_pin_def_config(codec, &spec->autocfg,
 						alc861_ignore)) < 0)
 		return err;
-	if (! spec->autocfg.line_outs && ! spec->autocfg.speaker_pin &&
-	    ! spec->autocfg.hp_pin)
+	if (! spec->autocfg.line_outs)
 		return 0; /* can't find valid BIOS pin config */
 
 	if ((err = alc861_auto_fill_dac_nids(spec, &spec->autocfg)) < 0 ||
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index 35c2823a0a..51ddf959e9 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -51,6 +51,7 @@ struct sigmatel_spec {
 	unsigned int line_switch: 1;
 	unsigned int mic_switch: 1;
 	unsigned int alt_switch: 1;
+	unsigned int hp_detect: 1;
 
 	/* playback */
 	struct hda_multi_out multiout;
@@ -691,13 +692,7 @@ static int stac92xx_auto_fill_dac_nids(struct hda_codec *codec, const struct aut
 					AC_VERB_GET_CONNECT_LIST, 0) & 0xff;
 	}
 
-	if (cfg->line_outs)
-		spec->multiout.num_dacs = cfg->line_outs;
-	else if (cfg->hp_pin) {
-		spec->multiout.dac_nids[0] = snd_hda_codec_read(codec, cfg->hp_pin, 0,
-					AC_VERB_GET_CONNECT_LIST, 0) & 0xff;
-		spec->multiout.num_dacs = 1;
-	}
+	spec->multiout.num_dacs = cfg->line_outs;
 
 	return 0;
 }
@@ -766,11 +761,13 @@ static int stac92xx_auto_create_hp_ctls(struct hda_codec *codec, struct auto_pin
 		return 0;
 
 	wid_caps = get_wcaps(codec, pin);
-	if (wid_caps & AC_WCAP_UNSOL_CAP)
+	if (wid_caps & AC_WCAP_UNSOL_CAP) {
 		/* Enable unsolicited responses on the HP widget */
 		snd_hda_codec_write(codec, pin, 0,
 				AC_VERB_SET_UNSOLICITED_ENABLE,
 				STAC_UNSOL_ENABLE);
+		spec->hp_detect = 1;
+	}
 
 	nid = snd_hda_codec_read(codec, pin, 0, AC_VERB_GET_CONNECT_LIST, 0) & 0xff;
 	for (i = 0; i < cfg->line_outs; i++) {
@@ -804,9 +801,6 @@ static int stac92xx_auto_create_analog_input_ctls(struct hda_codec *codec, const
 	for (i = 0; i < AUTO_PIN_LAST; i++) {
 		int index = -1;
 		if (cfg->input_pins[i]) {
-			/* Enable active pin widget as an input */
-			stac92xx_auto_set_pinctl(codec, cfg->input_pins[i], AC_PINCTL_IN_EN);
-
 			imux->items[imux->num_items].label = auto_pin_cfg_labels[i];
 
 			for (j=0; j<spec->num_muxes; j++) {
@@ -855,10 +849,8 @@ static int stac92xx_parse_auto_config(struct hda_codec *codec, hda_nid_t dig_out
 
 	if ((err = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL)) < 0)
 		return err;
-	if (! spec->autocfg.line_outs && ! spec->autocfg.hp_pin)
+	if (! spec->autocfg.line_outs)
 		return 0; /* can't find valid pin config */
-	stac92xx_auto_init_multi_out(codec);
-	stac92xx_auto_init_hp_out(codec);
 	if ((err = stac92xx_add_dyn_out_pins(codec, &spec->autocfg)) < 0)
 		return err;
 	if ((err = stac92xx_auto_fill_dac_nids(codec, &spec->autocfg)) < 0)
@@ -873,14 +865,10 @@ static int stac92xx_parse_auto_config(struct hda_codec *codec, hda_nid_t dig_out
 	if (spec->multiout.max_channels > 2)
 		spec->surr_switch = 1;
 
-	if (spec->autocfg.dig_out_pin) {
+	if (spec->autocfg.dig_out_pin)
 		spec->multiout.dig_out_nid = dig_out;
-		stac92xx_auto_set_pinctl(codec, spec->autocfg.dig_out_pin, AC_PINCTL_OUT_EN);
-	}
-	if (spec->autocfg.dig_in_pin) {
+	if (spec->autocfg.dig_in_pin)
 		spec->dig_in_nid = dig_in;
-		stac92xx_auto_set_pinctl(codec, spec->autocfg.dig_in_pin, AC_PINCTL_IN_EN);
-	}
 
 	if (spec->kctl_alloc)
 		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
@@ -890,6 +878,29 @@ static int stac92xx_parse_auto_config(struct hda_codec *codec, hda_nid_t dig_out
 	return 1;
 }
 
+/* add playback controls for HP output */
+static int stac9200_auto_create_hp_ctls(struct hda_codec *codec,
+					struct auto_pin_cfg *cfg)
+{
+	struct sigmatel_spec *spec = codec->spec;
+	hda_nid_t pin = cfg->hp_pin;
+	unsigned int wid_caps;
+
+	if (! pin)
+		return 0;
+
+	wid_caps = get_wcaps(codec, pin);
+	if (wid_caps & AC_WCAP_UNSOL_CAP) {
+		/* Enable unsolicited responses on the HP widget */
+		snd_hda_codec_write(codec, pin, 0,
+				AC_VERB_SET_UNSOLICITED_ENABLE,
+				STAC_UNSOL_ENABLE);
+		spec->hp_detect = 1;
+	}
+
+	return 0;
+}
+
 static int stac9200_parse_auto_config(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec = codec->spec;
@@ -901,14 +912,13 @@ static int stac9200_parse_auto_config(struct hda_codec *codec)
 	if ((err = stac92xx_auto_create_analog_input_ctls(codec, &spec->autocfg)) < 0)
 		return err;
 
-	if (spec->autocfg.dig_out_pin) {
+	if ((err = stac9200_auto_create_hp_ctls(codec, &spec->autocfg)) < 0)
+		return err;
+
+	if (spec->autocfg.dig_out_pin)
 		spec->multiout.dig_out_nid = 0x05;
-		stac92xx_auto_set_pinctl(codec, spec->autocfg.dig_out_pin, AC_PINCTL_OUT_EN);
-	}
-	if (spec->autocfg.dig_in_pin) {
+	if (spec->autocfg.dig_in_pin)
 		spec->dig_in_nid = 0x04;
-		stac92xx_auto_set_pinctl(codec, spec->autocfg.dig_in_pin, AC_PINCTL_IN_EN);
-	}
 
 	if (spec->kctl_alloc)
 		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
@@ -921,9 +931,31 @@ static int stac9200_parse_auto_config(struct hda_codec *codec)
 static int stac92xx_init(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec = codec->spec;
+	struct auto_pin_cfg *cfg = &spec->autocfg;
+	int i;
 
 	snd_hda_sequence_write(codec, spec->init);
 
+	/* set up pins */
+	if (spec->hp_detect) {
+		/* fake event to set up pins */
+		codec->patch_ops.unsol_event(codec, STAC_HP_EVENT << 26);
+	} else {
+		stac92xx_auto_init_multi_out(codec);
+		stac92xx_auto_init_hp_out(codec);
+	}
+	for (i = 0; i < AUTO_PIN_LAST; i++) {
+		if (cfg->input_pins[i])
+			stac92xx_auto_set_pinctl(codec, cfg->input_pins[i],
+						 AC_PINCTL_IN_EN);
+	}
+	if (cfg->dig_out_pin)
+		stac92xx_auto_set_pinctl(codec, cfg->dig_out_pin,
+					 AC_PINCTL_OUT_EN);
+	if (cfg->dig_in_pin)
+		stac92xx_auto_set_pinctl(codec, cfg->dig_in_pin,
+					 AC_PINCTL_IN_EN);
+
 	return 0;
 }
 
